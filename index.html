<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Chop To It!</title>
  <link rel="icon" type="image/png" href="favicon256.png">
  <style>
    html, body {
      margin: 0;
      background: #000;
      color: #fff;
    }
    canvas {
      display: block;
      margin: auto;
      background: #000;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>
  <script src="dayNightCycle.js"></script>
</head>
<body>

<script>
const config = {
  type: Phaser.AUTO,
  width: 800,
  height: 600,
  backgroundColor: '#000',
  physics: { default: 'arcade', arcade: { gravity: { y: 400 } } },
  scene: {
    preload,
    create,
    update
  }
};

const game = new Phaser.Game(config);

// Feature toggles for easy testing
const FEATURES = {
  birds: true,
  movingTargets: true,
  specialTargets: true,
  weather: true,
  clouds: true,
};

const CLOUD_AREA_HEIGHT = 200;

// Core player state: gold, storage level, and carrying capacity
const player = {
  gold: 0,
  storageLevel: 1,
  maxStorage: 10, // 10 items per level
  weaponLevel: 1,
};

function formatGold(amount) {
  if (amount < 1000) return amount.toString();
  const units = ['k', 'M', 'B', 'T'];
  let unitIndex = -1;
  let value = amount;
  while (value >= 1000 && unitIndex < units.length - 1) {
    value /= 1000;
    unitIndex++;
  }
  const rounded = Math.round(value * 10) / 10;
  const display = rounded % 1 === 0 ? rounded.toFixed(0) : rounded;
  return `${display}${units[unitIndex]}`;
}

let goldText;
let fame = 0;
let fameText;
let lastGoldGain = 0;
let pendingCoins = 0;
let swingActive = false;
let cursor;
let redZone;
let yellowZone;
let greenZone;
let swingBar;
let bloodPool;
let stageBlood;
let bloodEmitter;
let dripEmitter;
let headEmitter;
let splatEmitter;
let fireworkEmitter;
let fireworkCloseEmitter;
let bloodFireworkEmitter;
let rainEmitter;
let rainParts;
let fogEmitter;
let fogParts;
let windEmitter;
let windParts;
let cloudLayerFar;
let cloudLayerNear;
let missText;
let missStreak = 0;
const VERSION = 'Pre Alpha —v2.97';
let versionText;
let inputEnabled = true;
let killCount = 0;
let killText;
let killStreak = 0;
let streakMultiplierText;
let xp = 0;
let level = 1;
let xpThreshold = 10;
let xpText;
let xpBarFill;
let baseSwingSpeed = 5;
let speedMultiplier = 1;
let shopButton;
let shopContainer;
let shopOverlay;
// Global overlays for fading: screenFadeOverlay dims the whole screen
// while backgroundFadeOverlay only darkens the backdrop.
let screenFadeOverlay;
let backgroundFadeOverlay;
let tradeOverlay;
let tradeContainer;
let tradeTitle;
let tradeItemIndex = null;
let tradeMode = 'buy';
let tradeBuyBtns = [];
let tradeSellBtns = [];
let travelButton;
let storageButton;
let weaponsButton;
let travelContainer;
let travelOverlay;
let storageOverlay;
let storageContainer;
let storageCostText;
let storageImage;
let upgradeButton;
let weaponsOverlay;
let weaponsContainer;
let weaponsCostText;
let weaponsImage;
let weaponUpgradeButton;
let travelRegion = null;
// The dimming overlay previously used during menu transitions caused a
// distracting flash when switching cities. To remove it while keeping the
// rest of the code functional, we replace it with a no-op stub.
// const backOverlay = {
//   visible: false,
//   setVisible() {},
//   setAlpha() {},
// };
// let backOverlayWasVisible = false;
let locationText;
let currentCity = 'Durham';
let skyRect;
let backgroundRect;
let stage;
let travelList;
let startContainer;
let logoContainer;
let hideMeterEvent;
let headResetEvent;
let neckPumpEvent;
let prisoner;
let prisonerBody;
let prisonerHead;
let prisonerHeadSprite;
let prisonerHeadKey = 'prisonerHead1';
let prisonerBodyKey = 'prisonerBody1';
let leftEscort;
let rightEscort;
let aimArrow;
let arrowTween;
let arrowPowerTween;
let slashTween;
let awaitingAngle = false;
let awaitingPower = false;
let selectedAngle = 0;
let pendingBlood = 0;
let pendingSpawnSide = null;
let prisonerClass;
let swingSpeed = 5;
let executioner;
let executionerIntro = true;
let executionerWeapon;
let gameStarted = false;

// Medieval calendar variables
const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
let currentDay = 1;
let currentMonth = 0;
let dateText;
let dateBg;

// Daily trading modifiers
let dailyBuySpecial = null;
let dailySellSpecial = null;

// Market chatter
const marketQuotes = [
  "Oooh I'm desperate for turnips to help with me piles!",
  "A pox upon high prices, I say!",
  "Bring forth more mead, my throat be parched!",
  "Rumour says the plague's back, stock up on salt!",
  "I swapped me cow for beans once, ne'er again!"
];
let currentQuote = '';
let marketChatterText;
let marketPrisoner;

// Group to hold fallen bodies that pile up at the bottom
let bodyGroup;
let targetGroup;
let chest;

function setGoldChestVisible(visible) {
  if (chest) chest.setVisible(visible);
  if (goldText) goldText.setVisible(visible);
}

let currentWeather = 'clear';
let windForce = { x: 0, y: 0 };
let roundCount = 0;
let weatherText;
let weatherIndicator;
let weatherIndicatorBg;

// Inventory for trading market items
let inventory = {};
// Multiplier applied to fame gains
let fameMultiplier = 1;

const baseSizes = { red: 60, yellow: 40, green: 20 };
let zoneMods = { red: 0, yellow: 0, green: 0 };

const classes = [
  { name: 'Peasant', color: 0x777777, speed: 5, weight: 50 },
  { name: 'Merchant', color: 0x996633, speed: 6, weight: 25 },
  { name: 'Knight', color: 0x0033cc, speed: 7, weight: 15 },
  { name: 'Clergy', color: 0x800080, speed: 8, weight: 7 },
  { name: 'Lord', color: 0xffff00, speed: 9, weight: 3 }
];

const weapons = [
  {
    name: 'Excalibur',
    type: 'Sword',
    cost: 50,
    desc: 'Legendary blade of kings, widens red zone for precise justice.',
    effects: { red: 20 }
  },
  {
    name: 'Gungnir',
    type: 'Spear',
    cost: 100,
    desc: "Odin's unstoppable spear expands yellow zone for deadlier punishment strikes.",
    effects: { red: 10, yellow: 20 }
  },
  {
    name: 'Mjolnir',
    type: 'Hammer',
    cost: 200,
    desc: "Thunder god's hammer broadens green zone to shatter stubborn necks.",
    effects: { red: 10, yellow: 10, green: 10 }
  },
  {
    name: 'Masamune',
    type: 'Katana',
    cost: 400,
    desc: "Famed smith's katana enlarges all zones ensuring flawless beheadings everytime.",
    effects: { red: 10, yellow: 10, green: 10 }
  }
];

// Upgrades that boost fame gain or provide passive bonuses
const gameUpgrades = [
  { name: 'Grand Stage', cost: 150, fameReq: 0, desc: 'Bigger stage draws crowds. Fame x1.1', mult: 1.1 },
  { name: 'Traveling Caravan', cost: 300, fameReq: 3, desc: 'Musicians and banners. Fame x1.2', mult: 1.2 },
  { name: 'Royal Horse', cost: 600, fameReq: 6, desc: 'Arrive in style. Fame x1.3', mult: 1.3 }
];

// Items available in the trading market
const marketItems = [
  { name: 'Potatoes', buy: 2, sell: 1, fameReq: 0 },
  { name: 'Mead', buy: 5, sell: 3, fameReq: 0 },
  { name: 'Salt', buy: 8, sell: 4, fameReq: 3 },
  { name: 'Silver Cup', buy: 20, sell: 10, fameReq: 5 },
  { name: 'Gemstones', buy: 50, sell: 25, fameReq: 8 }
];

// Places the player can visit
const cities = [
  { name: 'York', desc: 'Historic northern city.', fameReq: 0, region: 'north', /* bgColor: 0x2d2d2d, */
    modifiers: { Potatoes: { buy: 0.9, sell: 1.1 } } },
  { name: 'Durham', desc: 'Northern cathedral city.', fameReq: 1, region: 'north', /* bgColor: 0x34342d, */
    modifiers: { Potatoes: { buy: 0.9, sell: 1.1 } } },
  { name: 'Chester', desc: 'Fortified Roman town.', fameReq: 2, region: 'north', /* bgColor: 0x342d34, */
    modifiers: { 'Silver Cup': { buy: 0.85, sell: 1.15 } } },
  { name: 'Hull', desc: 'North Sea trading port.', fameReq: 3, region: 'north', /* bgColor: 0x2d342d, */
    modifiers: { Gemstones: { buy: 0.8, sell: 1.2 } } },
  { name: 'Newcastle', desc: 'City on the Tyne.', fameReq: 4, region: 'north', /* bgColor: 0x2d2d34, */
    modifiers: { Potatoes: { buy: 0.9, sell: 1.1 } } },
  { name: 'Lincoln', desc: 'Cathedral and castle city.', fameReq: 5, region: 'north', /* bgColor: 0x342d2d, */
    modifiers: { Salt: { buy: 0.9, sell: 1.1 } } },
  { name: 'Canterbury', desc: 'Seat of the Archbishop.', fameReq: 6, region: 'south', /* bgColor: 0x2d2d34, */
    modifiers: { Mead: { buy: 0.9, sell: 1.1 } } },
  { name: 'London', desc: 'Bustling capital of the realm.', fameReq: 7, region: 'south', /* bgColor: 0x34342d, */
    modifiers: { Salt: { buy: 0.9, sell: 1.1 } } },
  { name: 'Dover', desc: 'Channel crossing hub.', fameReq: 8, region: 'south', /* bgColor: 0x2d342d, */
    modifiers: { Salt: { buy: 0.9, sell: 1.1 } } },
  { name: 'Norwich', desc: 'Town of fine artisans.', fameReq: 9, region: 'south', /* bgColor: 0x342d2d, */
    modifiers: { Gemstones: { buy: 0.8, sell: 1.2 } } },
  { name: 'Winchester', desc: 'Former royal seat.', fameReq: 10, region: 'south', /* bgColor: 0x2d3434, */
    modifiers: { Mead: { buy: 0.9, sell: 1.1 } } },
  { name: 'Colchester', desc: 'Ancient Roman city.', fameReq: 11, region: 'south', /* bgColor: 0x34342d, */
    modifiers: { Mead: { buy: 0.9, sell: 1.1 } } },
  { name: 'Oxford', desc: 'Home of great learning.', fameReq: 12, region: 'south', /* bgColor: 0x2d3434, */
    modifiers: { 'Silver Cup': { buy: 0.85, sell: 1.15 } } },
  { name: 'Southampton', desc: 'Southern port city.', fameReq: 13, region: 'south', /* bgColor: 0x2d2d34, */
    modifiers: { Gemstones: { buy: 0.8, sell: 1.2 } } },
  { name: 'Gloucester', desc: 'Historic Roman city.', fameReq: 14, region: 'south', /* bgColor: 0x34342d, */
    modifiers: { Potatoes: { buy: 0.9, sell: 1.1 } } }
];

// Mapping of cities to their background image files. Keys are the city names
// and values are the corresponding PNG filenames.
const cityBackgrounds = {
  York: 'background_york.png',
  Canterbury: 'background_canterbury.png',
  London: 'background_london.png',
  Dover: 'background_dover.png',
  Durham: 'background_durham.png',
  Norwich: 'background_norwich.png',
  Winchester: 'background_winchester.png',
  Chester: 'background_chester.png',
  Hull: 'background_hull.png',
  Newcastle: 'background_newcastle.png',
  Colchester: 'background-colchester.png',
  Lincoln: 'background-lincoln.png',
  Oxford: 'background-oxford.png',
  Southampton: 'background-southhampton.png',
  Gloucester: 'background-gloucester.png',
};

// List of travel background images used during travel scenes.
const travelBackgrounds = Array.from({ length: 14 }, (_, i) => `background_travel${i + 1}.png`);

// Rough geographic coordinates for each city used to estimate travel time
const cityCoords = {
  Winchester: [51.06, -1.31],
  York: [53.96, -1.08],
  Dover: [51.13, 1.31],
  Durham: [54.78, -1.58],
  Canterbury: [51.28, 1.08],
  London: [51.5, -0.1],
  Chester: [53.19, -2.89],
  Norwich: [52.63, 1.3],
  Hull: [53.74, -0.34],
  Newcastle: [54.97, -1.61],
  Colchester: [51.89, 0.9],
  Lincoln: [53.23, -0.54],
  Oxford: [51.75, -1.26],
  Southampton: [50.9, -1.4],
  Gloucester: [51.87, -2.24],
};

// Calculate great-circle distance between two coordinate pairs in miles
function distanceMiles(a, b) {
  const [lat1, lon1] = cityCoords[a];
  const [lat2, lon2] = cityCoords[b];
  const R = 6371e3; // metres
  const phi1 = lat1 * Math.PI / 180;
  const phi2 = lat2 * Math.PI / 180;
  const dPhi = (lat2 - lat1) * Math.PI / 180;
  const dLambda = (lon2 - lon1) * Math.PI / 180;
  const aa = Math.sin(dPhi / 2) ** 2 + Math.cos(phi1) * Math.cos(phi2) * Math.sin(dLambda / 2) ** 2;
  const c = 2 * Math.atan2(Math.sqrt(aa), Math.sqrt(1 - aa));
  return (R * c) / 1609.34;
}

// Average pace roughly 24 miles per day
function getTravelDays(from, to) {
  if (from === to) return 0;
  const miles = distanceMiles(from, to);
  return Math.max(1, Math.round(miles / 24));
}

// Format the current calendar date
function getDateString() {
  return `${currentDay} ${months[currentMonth]}`;
}

// Apply random price changes, city modifiers and daily specials
function refreshMarketPrices() {
  const city = cities.find(c => c.name === currentCity);
  marketItems.forEach(m => {
    let buyMult = Phaser.Math.FloatBetween(0.9, 1.1);
    let sellMult = Phaser.Math.FloatBetween(0.9, 1.1);
    if (city && city.modifiers && city.modifiers[m.name]) {
      const mod = city.modifiers[m.name];
      if (mod.buy) buyMult *= mod.buy;
      if (mod.sell) sellMult *= mod.sell;
    }
    if (m.name === dailyBuySpecial) buyMult *= 0.75;
    if (m.name === dailySellSpecial) sellMult *= 1.25;
    m.currentBuy = Math.max(1, Math.round(m.buy * buyMult));
    m.currentSell = Math.max(1, Math.round(m.sell * sellMult));
  });
}

function chooseTargetType() {
  if (!FEATURES.specialTargets) return 'standard';
  const r = Phaser.Math.Between(1, 100);
  if (r <= 5) return killStreak >= 10 ? 'royal' : 'standard';
  if (r <= 15) return 'holyMonk';
  if (r <= 35) return killStreak >= 8 ? 'explodingBarrel' : 'standard';
  if (r <= 65) return 'woodenShield';
  return 'standard';
}

function createTargetAppearance(scene, target, type) {
  target.removeAll(true);
  switch (type) {
    case 'woodenShield': {
      const c = scene.add.circle(0, 0, 20, 0x8b4513);
      const m = scene.add.circle(0, 0, 6, 0xcccccc);
      target.add([c, m]);
      break;
    }
    case 'explodingBarrel': {
      const b = scene.add.rectangle(0, 0, 30, 40, 0x663300);
      const f = scene.add.rectangle(0, -22, 4, 8, 0xff0000);
      target.add([b, f]);
      break;
    }
    case 'holyMonk': {
      const m = scene.add.rectangle(0, 0, 30, 40, 0xffffcc);
      target.add(m);
      break;
    }
      case 'royal': {
        const o = scene.add.circle(0, 0, 20, 0xffff00);
        const txt = scene.add.text(0, 0, 'R', { font: '16px monospace', fill: '#000' })
          .setOrigin(0.5);
        target.add([o, txt]);
        break;
      }
      case 'bird': {
        const base = target.birdKind === 'dove' ? 'birdWhite' : 'birdBlack';
        const direction = target.fromRight ? 'Right' : 'Left';
        const key = base + direction;
        const img = scene.add.image(0, 0, key).setOrigin(0.5);
        target.add(img);
        target.birdSprite = img;
        break;
      }
      default: {
        const outer = scene.add.circle(0, 0, 20, 0xff0000);
        const inner = scene.add.circle(0, 0, 8, 0xffffff);
        target.add([outer, inner]);
      }
  }
}



function applyRandomWeather(scene) {
  const clearChance = 0.5;
  if (!FEATURES.weather || Math.random() < clearChance) {
    currentWeather = 'clear';
  } else {
    currentWeather = Phaser.Utils.Array.GetRandom(['rain', 'wind', 'fog']);
  }
  windForce = { x: 0, y: 0 };
  weatherText.setText(currentWeather.toUpperCase());
  if (rainEmitter) rainEmitter.stop();
  if (fogEmitter) fogEmitter.stop();
  if (windEmitter) windEmitter.stop();
  let letter = '';
  let arrow = '';
  targetGroup.getChildren().forEach(t => {
    if (t.fogTween) { t.fogTween.stop(); t.fogTween = null; }
    t.setAlpha(1);
    if (t.jester && t.jester.fogTween) { t.jester.fogTween.stop(); t.jester.fogTween = null; }
    if (t.jester) t.jester.setAlpha(1);
  });
  if (currentWeather === 'wind') {
    windForce.x = Phaser.Math.Between(-100, 100);
    windForce.y = Phaser.Math.Between(-100, 100);
    letter = 'W';
    arrow = arrowForWind(windForce.x, windForce.y);
    if (windEmitter) {
      windEmitter.setSpeedX({ min: windForce.x - 20, max: windForce.x + 20 });
      windEmitter.setSpeedY({ min: windForce.y - 20, max: windForce.y + 20 });
      const zone = new Phaser.Geom.Rectangle(-20, 0, 840, 600);
      windEmitter.setEmitZone({ type: 'random', source: zone });
      windEmitter.start();
    }
  } else if (currentWeather === 'fog') {
    letter = 'F';
    targetGroup.getChildren().forEach(t => {
      t.fogTween = scene.tweens.add({ targets: t, alpha: 0.4, yoyo: true, repeat: -1, duration: 800 });
      if (t.jester) {
        t.jester.fogTween = scene.tweens.add({ targets: t.jester, alpha: 0.4, yoyo: true, repeat: -1, duration: 800 });
      }
    });
    if (fogEmitter) fogEmitter.start();
  } else if (currentWeather === 'rain') {
    letter = 'R';
    if (rainEmitter) rainEmitter.start();
  } else if (currentWeather === 'clear') {
    letter = 'C';
  }
  weatherIndicator.setText(letter + arrow);
}

function arrowForWind(x, y) {
  const angle = Math.atan2(y, x);
  const arrows = ['→', '↘', '↓', '↙', '←', '↖', '↑', '↗'];
  let idx = Math.round(angle / (Math.PI / 4));
  if (idx < 0) idx += 8;
  return arrows[idx % 8];
}

// Display the day's market chatter
function updateMarketChatter() {
  if (marketChatterText) {
    marketChatterText.setText(`"${currentQuote}"`);
    if (marketPrisoner) {
      const color = Phaser.Utils.Array.GetRandom(classes).color;
      marketPrisoner.list[0].setTint(color);
      const txt = marketChatterText;
      marketPrisoner.x = txt.x + txt.width / 2 + 10;
      marketPrisoner.y = txt.y + txt.height / 2;
    }
  }
}

// Refresh prices, specials and chatter at the start of a new day
function dailyMarketUpdate() {
  dailyBuySpecial = Phaser.Utils.Array.GetRandom(marketItems).name;
  do {
    dailySellSpecial = Phaser.Utils.Array.GetRandom(marketItems).name;
  } while (dailySellSpecial === dailyBuySpecial);
  currentQuote = Phaser.Utils.Array.GetRandom(marketQuotes);
  refreshMarketPrices();
  updateMarketUI();
  updateMarketChatter();
}

// Advance the calendar by a number of days
function advanceDays(days = 1) {
  for (let i = 0; i < days; i++) {
    currentDay++;
    if (currentDay > 30) {
      currentDay = 1;
      currentMonth = (currentMonth + 1) % months.length;
    }
  }
  if (dateText) dateText.setText(getDateString());
  dailyMarketUpdate();
}

// Alias used by the day/night cycle to advance time
function advanceCalendarDays(days = 1) {
  advanceDays(days);
}

function isMenuOpen() {
  return (shopContainer && shopContainer.visible) ||
         (travelContainer && travelContainer.visible) ||
         (storageContainer && storageContainer.visible) ||
         (weaponsContainer && weaponsContainer.visible) ||
         (tradeContainer && tradeContainer.visible);
}

function releaseQueuedCoins(scene) {
  if (pendingCoins > 0 && !isMenuOpen()) {
    for (let i = 0; i < pendingCoins; i++) {
      scene.time.delayedCall(i * 100, () => spawnCoin(scene));
    }
    pendingCoins = 0;
  }
}

function addGold(scene, amount) {
  if (amount <= 0) return;
  player.gold += amount;
  goldText.setText(formatGold(player.gold));
  if (isMenuOpen()) {
    pendingCoins += amount;
  } else {
    for (let i = 0; i < amount; i++) {
      scene.time.delayedCall(i * 100, () => spawnCoin(scene));
    }
  }
}

function spawnCoin(scene) {
  if (isMenuOpen()) {
    pendingCoins++;
    return;
  }
  const coin = scene.add.circle(chest.x, -20, 8, 0xffd700).setDepth(101);
  scene.tweens.add({
    targets: coin,
    y: chest.y - chest.height / 2,
    duration: 800,
    ease: 'Cubic.easeIn',
    onComplete: () => {
      coin.destroy();
      openChest(scene);
    },
  });
}

function openChest(scene) {
  chest.setFillStyle(0xdaa520);
  scene.time.delayedCall(300, () => chest.setFillStyle(0x8b4513));
}

function pickClass() {
  const total = classes.reduce((s, c) => s + c.weight, 0);
  let r = Phaser.Math.Between(1, total);
  for (const c of classes) {
    r -= c.weight;
    if (r <= 0) return c;
  }
  return classes[0];
}

function preload() {
  this.load.image('logo', 'logo.png');
  this.load.image('shop', 'shop.png');
  this.load.image('platform', 'platform.png');
  this.load.image('executionerHead', 'executionerhead.png');
  this.load.image('executionerBody', 'executionerbody.png');
  this.load.image('escortHead', 'escorthead.png');
  this.load.image('escortBody', 'escortbody.png');
  this.load.image('signTravel', 'sign_travel.png');
  this.load.image('signStorage', 'sign_storage.png');
  this.load.image('signWeapons', 'sign_weapons.png');
  this.load.image('signClose', 'sign_close.png');
  this.load.image('mapNorth', 'map_north.png');
  this.load.image('mapSouth', 'map_south.png');
  // Storage upgrade assets
  this.load.image('backgroundStorage', 'background_storage.png');
  this.load.image('upgradeButton', 'upgrade_button.png');
  for (let i = 1; i <= 16; i++) {
    this.load.image(`storage${i}`, `storage_${i}.png`);
  }
  // Weapons upgrade assets
  this.load.image('backgroundWeapons', 'background_weapons.png');
  for (let i = 1; i <= 30; i++) {
    this.load.image(`weapons${i}`, `weapons${i}.png`);
  }
  this.load.image('background', 'background.png');
  this.load.image('backgroundSky', 'background_bluesky.png');
  this.load.image('prisonerHead1', 'prisonerhead.png');
  this.load.image('prisonerBody1', 'prisonerbody.png');
  this.load.image('prisonerHead2', 'prisonerhead2.png');
  this.load.image('prisonerBody2', 'prisonerbody2.png');
  this.load.image('prisonerHead3', 'prisonerhead3.png');
  this.load.image('prisonerBody3', 'prisonerbody3.png');
  this.load.image('priestHead', 'prisonerhead_priest.png');
  this.load.image('priestBody', 'prisonerbody_priest.png');
  this.load.image('jesterHead1', 'jesterhead.png');
  this.load.image('jesterBody1', 'jesterbody.png');
  this.load.image('jesterHead2', 'jesterhead2.png');
  this.load.image('jesterBody2', 'jesterbody2.png');
  this.load.image('jesterHead3', 'jesterhead3.png');
  this.load.image('jesterBody3', 'jesterbody3.png');
  this.load.image('jesterHead4', 'jesterhead4.png');
  this.load.image('jesterBody4', 'jesterbody4.png');
  this.load.image('birdBlackLeft', 'bird_black_left.png');
  this.load.image('birdBlackRight', 'bird_black_right.png');
  this.load.image('birdWhiteLeft', 'bird_white_left.png');
  this.load.image('birdWhiteRight', 'bird_white_right.png');
  // Load city backgrounds using explicit file mappings to handle inconsistent
  // naming.
  Object.entries(cityBackgrounds).forEach(([name, file]) => {
    const key = `background-${name.toLowerCase()}`;
    this.load.image(key, file);
  });
  // Load dedicated travel backgrounds.
  travelBackgrounds.forEach((file, i) => {
    const key = `background-travel${i + 1}`;
    this.load.image(key, file);
  });
}

function create() {
  const scene = this;

  // Background and stage art
  skyRect = scene.add.image(400, 300, 'backgroundSky');
  skyRect.setDisplaySize(800, 600);
  // Render sky behind celestial bodies
  skyRect.setDepth(-5);

  backgroundRect = scene.add.image(400, 300, 'background');
  backgroundRect.setDisplaySize(800, 600);
  backgroundRect.setDepth(-2);
  // Apply the initial background for the starting city
  updateBackground(scene);

  // Parallax cloud layers
  if (FEATURES.clouds) {
    const gfx = scene.make.graphics({ x: 0, y: 0, add: false });
    // draw a more detailed small cloud with subtle shading
    gfx.fillStyle(0xdddddd, 0.6);
    gfx.fillEllipse(50, 45, 60, 20);
    gfx.fillStyle(0xffffff, 0.9);
    gfx.fillCircle(30, 30, 20);
    gfx.fillCircle(50, 20, 25);
    gfx.fillCircle(70, 30, 20);
    gfx.fillCircle(40, 40, 18);
    gfx.fillCircle(60, 40, 18);
    gfx.generateTexture('cloud-small', 100, 60);
    gfx.clear();
    // draw a more detailed large cloud
    gfx.fillStyle(0xdddddd, 0.6);
    gfx.fillEllipse(70, 45, 80, 25);
    gfx.fillStyle(0xffffff, 0.9);
    gfx.fillCircle(40, 30, 25);
    gfx.fillCircle(70, 20, 35);
    gfx.fillCircle(100, 30, 25);
    gfx.fillCircle(55, 45, 20);
    gfx.fillCircle(85, 45, 20);
    gfx.generateTexture('cloud-big', 140, 60);
    gfx.destroy();

    cloudLayerFar = scene.add.group();
    cloudLayerNear = scene.add.group();

    for (let i = 0; i < 5; i++) {
      const cloud = scene.add.image(
        Phaser.Math.Between(0, config.width),
        Phaser.Math.Between(20, CLOUD_AREA_HEIGHT),
        'cloud-small'
      );
      cloud.setDepth(-3);
      cloud.setTint(0x888888);
      cloud.setAlpha(Phaser.Math.FloatBetween(0.3, 0.5));
      cloud.setScale(Phaser.Math.FloatBetween(0.8, 1.2));
      cloudLayerFar.add(cloud);
    }

    for (let i = 0; i < 3; i++) {
      const cloud = scene.add.image(
        Phaser.Math.Between(0, config.width),
        Phaser.Math.Between(40, CLOUD_AREA_HEIGHT),
        'cloud-big'
      );
      cloud.setDepth(-1);
      cloud.setAlpha(Phaser.Math.FloatBetween(0.6, 0.9));
      cloud.setScale(Phaser.Math.FloatBetween(0.8, 1.2));
      cloudLayerNear.add(cloud);
    }
  }

  // Initialize day/night cycle
  this.dayNight = new DayNightCycle({ dayLengthSeconds: 180 });
  // Place the lighting overlay behind the start screen so the logo remains
  // unobstructed during the initial splash.
  this.dayNight.init(scene, { backCloudsDepth: -3, overlayDepth: 11 });
  this.dayNight.onFullDay(() => { advanceCalendarDays(1); });
  // Only begin a new execution round if the player isn't already interacting
  // with the swing meter. This prevents the meter from resetting unexpectedly
  // while awaiting input.
  this.dayNight.onHourlyExecution(() => {
    if (gameStarted && !swingActive && !awaitingAngle && !awaitingPower) {
      startExecutionRound();
    }
  });

  stage = scene.add.image(400, 520, 'platform').setDepth(0);
  stageBlood = scene.add.rectangle(400, 520, 1, 10, 0x770000)
    .setOrigin(0.5, 1)
    .setVisible(false)
    .setDepth(0.4);
  // Overlay that only dims the background behind characters
  backgroundFadeOverlay = scene.add.rectangle(400, 300, 800, 600, 0x000000, 1)
    .setDepth(-1)
    .setAlpha(0)
    .setVisible(false);

  // Overlay used for fading the entire screen during menus and transitions.
  screenFadeOverlay = scene.add.rectangle(400, 300, 800, 600, 0x000000, 1)
    .setDepth(29)
    .setAlpha(0)
    .setVisible(false);



  // Executioner, starts off-screen and walks in on first spawn
  // Place him behind the prisoner but in front of the background
  executioner = scene.add.container(400, 460).setDepth(0.5);
  executionerWeapon = scene.add.image(0, -20, `weapons${player.weaponLevel}`)
    .setOrigin(0.5)
    .setAngle(135);
  const execBody = scene.add.image(0, 50, 'executionerBody')
    .setOrigin(0.5, 1);
  const execHead = scene.add.image(0, -30, 'executionerHead')
    .setOrigin(0.5, 0.5);
  executioner.add([executionerWeapon, execBody, execHead]);
  executioner.setVisible(false);

  // Condemned figure with separate head and body
  prisoner = scene.add.container(400, 460).setDepth(1);
  // Pivot the body around the feet so it can topple realistically
  // Position it so the top still aligns with the neck
  prisonerBody = scene.add.image(0, 50, prisonerBodyKey)
    .setOrigin(0.5, 1);
  prisonerHead = scene.add.container(0, -20);
  prisonerHeadSprite = scene.add.image(0, 0, prisonerHeadKey).setOrigin(0.5);
  prisonerHead.add(prisonerHeadSprite);
  // Aim arrow points upward for angle selection
  // Larger arrow for angle and power selection
  aimArrow = scene.add.triangle(0, -25, 0, -40, -12, 0, 12, 0, 0xffff00)
    .setOrigin(0.5, 1)
    .setVisible(false);
  prisonerHead.add(aimArrow);
  prisoner.add([prisonerBody, prisonerHead]);
  prisoner.setVisible(false);

  // Escort guards
  leftEscort = scene.add.container(0, 0);
  const leftBody = scene.add.image(0, 50, 'escortBody')
    .setOrigin(0.5, 1);
  const leftHead = scene.add.image(0, -20, 'escortHead')
    .setOrigin(0.5, 0.5);
  leftEscort.add([leftBody, leftHead]);
  rightEscort = scene.add.container(0, 0);
  const rightBody = scene.add.image(0, 50, 'escortBody')
    .setOrigin(0.5, 1);
  const rightHead = scene.add.image(0, -20, 'escortHead')
    .setOrigin(0.5, 0.5);
  rightEscort.add([rightBody, rightHead]);
  leftEscort.setVisible(false);
  rightEscort.setVisible(false);

  // Gold chest and counter
  chest = scene.add.rectangle(config.width - 60, config.height - 40, 80, 50, 0x8b4513)
    .setOrigin(0.5, 1)
    .setDepth(100)
    .setVisible(false);
  goldText = scene.add.text(chest.x, chest.y - chest.height - 10, formatGold(player.gold), { font: '20px monospace', fill: '#ffff88' })
    .setOrigin(0.5, 1)
    .setVisible(false);
  fameText = scene.add.text(16, 40, 'Fame: 0', { font: '20px monospace', fill: '#88ffff' });
  fameText.setY(fameText.y + 50);
  missText = scene.add.text(16, 64, 'Misses: 0', { font: '20px monospace', fill: '#ff8888' });
  missText.setY(missText.y + 50);
  killText = scene.add.text(16, 88, 'Kills: 0', { font: '20px monospace', fill: '#ffffff' });
  killText.setY(killText.y + 50);
  // Hide the old weather label at the top
  weatherText = scene.add.text(400, 96, '', { font: '20px monospace', fill: '#ffffff' })
    .setOrigin(0.5, 0)
    .setDepth(50)
    .setVisible(false);
  weatherText.setY(weatherText.y + 50);
  weatherIndicatorBg = scene.add.circle(25, 571, 24, 0x000000)
    .setOrigin(0.5)
    .setDepth(49)
    .setVisible(false);
  weatherIndicator = scene.add.text(25, 571, '', { font: '20px monospace', fill: '#ffffff' })
    .setOrigin(0.5)
    .setDepth(50)
    .setVisible(false);

  // Debug cheat: hold the weather icon for 10 seconds to gain resources
  let weatherHoldEvent = null;
  function cancelWeatherHold() {
    if (weatherHoldEvent) {
      weatherHoldEvent.remove(false);
      weatherHoldEvent = null;
    }
  }
  [weatherIndicatorBg, weatherIndicator].forEach(icon => {
    icon.setInteractive();
    icon.on('pointerdown', () => {
      cancelWeatherHold();
      weatherHoldEvent = scene.time.delayedCall(10000, () => {
        addGold(scene, 1000000);
        fame += 500;
        fameText.setText(`Fame: ${Math.floor(fame)}`);
        weatherHoldEvent = null;
      });
    });
    icon.on('pointerup', cancelWeatherHold);
    icon.on('pointerout', cancelWeatherHold);
  });
  locationText = scene.add.text(400, 16, currentCity, { font: '20px monospace', fill: '#ffffff' })
    .setOrigin(0.5, 0);
  locationText.setY(locationText.y + 50);
  dateBg = scene.add.rectangle(400, 52, 80, 28, 0xffffff)
    .setOrigin(0.5)
    .setDepth(49)
    .setVisible(false);
  dateBg.setY(dateBg.y + 50);
  dateText = scene.add.text(400, 52, getDateString(), { font: '16px monospace', fill: '#000000' })
    .setOrigin(0.5)
    .setDepth(50)
    .setVisible(false);
  dateText.setY(dateText.y + 50);
  xpText = scene.add.text(400, 580, 'Level 1 - 0/10 XP', { font: '20px monospace', fill: '#88ff88' })
    .setOrigin(0.5, 1);
  xpBarFill = scene.add.rectangle(250, 584, 0, 12, 0x00ff00).setOrigin(0, 1);
  updateXPUI();
  streakMultiplierText = scene.add.text(460, 520, 'x0', { font: '48px monospace', fill: '#ff0000' })
    .setOrigin(0.5, 1)
    .setDepth(2)
    .setStroke('#000000', 4);
  versionText = scene.add.text(790, 590, VERSION, { font: '14px monospace', fill: '#ffffff' })
    .setOrigin(1, 1)
    .setDepth(11);


  // Logo drop animation before showing the start screen
  // Ensure the logo appears above the start screen background
  logoContainer = scene.add.container(400, -200).setDepth(13);
  const rope = scene.add.rectangle(0, 0, 12, 125, 0xffffff)
    .setOrigin(0.5, 0);
  const logo = scene.add.image(0, 125, 'logo')
    .setOrigin(513 / 1024, 127 / 1024)
    .setScale(0.5);
  logoContainer.add([rope, logo]);
  scene.tweens.add({
    targets: logoContainer,
    y: 0,
    ease: 'Bounce',
    duration: 600,
    onComplete: () => {
      scene.tweens.timeline({
        targets: logoContainer,
        tweens: [
          { angle: { from: -15, to: 15 }, duration: 300, yoyo: true, ease: 'Sine.easeInOut' },
          { angle: { from: -10, to: 10 }, duration: 400, yoyo: true, ease: 'Sine.easeInOut' },
          { angle: { from: -5, to: 5 }, duration: 500, yoyo: true, ease: 'Sine.easeInOut' },
          { angle: 0, duration: 600, ease: 'Sine.easeInOut' }
        ]
      });
    }
  });

  // Start screen
  startContainer = scene.add.container(0, 0).setDepth(12);
  const startBg = scene.add.rectangle(400, 300, 800, 600, 0x000000, 1)
    .setDepth(10)
    .setInteractive();
  const startText = scene.add.text(400, 560, '[ CLICK TO PLAY ]', { font: '32px monospace', fill: '#ffffff' })
    .setOrigin(0.5)
    .setDepth(10)
    .setVisible(false)
    .setInteractive();

  function beginGame() {
    scene.tweens.add({
      targets: startContainer,
      alpha: 0,
      duration: 500,
      onComplete: () => {
        startContainer.setVisible(false);
        startContainer.setAlpha(1);
        logoContainer.setVisible(false);
        weatherIndicatorBg.setVisible(true);
        weatherIndicator.setVisible(true);
        dateBg.setVisible(true);
        dateText.setVisible(true);
        setGoldChestVisible(true);
        gameStarted = true;
        if (executionerIntro) {
          introExecutioner(scene, () => spawnPrisoner(scene, false));
        } else {
          spawnPrisoner(scene, false);
        }
      }
    });
  }

  startBg.on('pointerdown', beginGame);
  startText.on('pointerdown', beginGame);
  startContainer.add([startBg, startText]);
  startContainer.setVisible(true);

  scene.time.delayedCall(3000, () => {
    startText.setVisible(true);
  });

  // Swing meter base
  const meterY = 550;
  swingBar = scene.add.rectangle(400, meterY, 300, 20, 0x333333).setVisible(false);
  redZone = scene.add.rectangle(400, meterY, baseSizes.red, 20, 0xff0000).setVisible(false);
  yellowZone = scene.add.rectangle(400, meterY, baseSizes.yellow, 20, 0xffff00).setVisible(false);
  greenZone = scene.add.rectangle(400, meterY, baseSizes.green, 20, 0x00ff00).setVisible(false);
  cursor = scene.add.rectangle(250, meterY, 10, 20, 0xffffff).setVisible(false);

  // Blood pool
  bloodPool = scene.add.rectangle(400, 600, 800, 1, 0x770000)
    .setOrigin(0.5, 1)
    .setVisible(false)
    // Render in front of heads so they appear to sink into the pool
    .setDepth(0.9);

  // Blood particle emitter
  const g = scene.add.graphics();
  g.fillStyle(0xff0000, 1);
  g.fillCircle(2, 2, 2);
  g.generateTexture('blood', 4, 4);
  g.destroy();
  const particles = scene.add.particles('blood').setDepth(1);
  bloodEmitter = particles.createEmitter({
    speed: { min: 150, max: 250 },
    angle: { min: 260, max: 280 }, // shoot upward like a fountain
    gravityY: 400,
    lifespan: 800,
    scale: { start: 1, end: 0 },
    quantity: 0,
    on: false
  });
  headEmitter = particles.createEmitter({
    speed: { min: 180, max: 280 },
    angle: { min: 80, max: 100 }, // downward from flying head
    gravityY: 400,
    lifespan: 1000,
    frequency: 20,
    scale: { start: 1, end: 0 },
    quantity: 0,
    on: false
  });
  dripEmitter = particles.createEmitter({
    speed: { min: 20, max: 40 },
    angle: 90,
    gravityY: 300,
    lifespan: 1000,
    scale: { start: 0.5, end: 0 },
    quantity: 0,
    on: false
  });
  splatEmitter = particles.createEmitter({
    speed: { min: 100, max: 200 },
    angle: { min: 240, max: 300 },
    gravityY: 400,
    lifespan: 800,
    scale: { start: 1, end: 0 },
    quantity: 0,
    on: false
  });
  bloodFireworkEmitter = particles.createEmitter({
    speed: { min: 150, max: 250 },
    angle: { min: 0, max: 360 },
    gravityY: 400,
    lifespan: 800,
    scale: { start: 1, end: 0 },
    quantity: 0,
    on: false
  });
  const gSpark = scene.add.graphics();
  gSpark.fillStyle(0xffcc00, 1);
  gSpark.fillCircle(2, 2, 2);
  gSpark.generateTexture('spark', 4, 4);
  gSpark.destroy();
  const fwParts = scene.add.particles('spark').setDepth(5);
  fireworkEmitter = fwParts.createEmitter({
    speed: { min: 150, max: 250 },
    angle: { min: 250, max: 290 },
    gravityY: 200,
    lifespan: 1000,
    scale: { start: 1, end: 0 },
    blendMode: 'ADD',
    quantity: 0,
    on: false
  });
  const gPix = scene.add.graphics();
  gPix.fillStyle(0xffffff, 1);
  gPix.fillRect(0, 0, 2, 2);
  gPix.generateTexture('pixel', 2, 2);
  gPix.destroy();
  const fwCloseParts = scene.add.particles('pixel').setDepth(6);
  fireworkCloseEmitter = fwCloseParts.createEmitter({
    speed: { min: 20, max: 60 },
    lifespan: 600,
    scale: { start: 1, end: 0 },
    blendMode: 'ADD',
    quantity: 0,
    on: false
  });

  // Weather particle textures
  const gWeather = scene.add.graphics();
  gWeather.fillStyle(0x99ccff, 1);
  gWeather.fillRect(0, 0, 2, 10);
  gWeather.generateTexture('raindrop', 2, 10);
  gWeather.clear();
  gWeather.fillStyle(0xffffff, 0.6);
  gWeather.fillRect(0, 0, 20, 8);
  gWeather.generateTexture('fog', 20, 8);
  gWeather.destroy();
  // Place weather effects behind UI overlays so menus appear on top
  rainParts = scene.add.particles('raindrop').setDepth(28);
  rainEmitter = rainParts.createEmitter({
    x: { min: 0, max: 800 },
    y: 0,
    lifespan: 800,
    speedY: { min: 400, max: 600 },
    quantity: 15,
    frequency: 100,
    on: false
  });
  fogParts = scene.add.particles('fog').setDepth(28);
  fogEmitter = fogParts.createEmitter({
    x: { min: -50, max: 850 },
    y: { min: 300, max: 580 },
    lifespan: 6000,
    speedX: { min: -20, max: 20 },
    speedY: { min: -5, max: 5 },
    quantity: 6,
    alpha: { start: 0.8, end: 0.1 },
    on: false
  });

  const windG = scene.add.graphics();
  windG.fillStyle(0x996633, 1);
  windG.fillCircle(2, 2, 2);
  windG.generateTexture('leaf', 4, 4);
  windG.destroy();
  windParts = scene.add.particles('leaf').setDepth(28);
  windEmitter = windParts.createEmitter({
    lifespan: 4000,
    // Increase particle output dramatically so the wind effect is visible
    quantity: 10,
    frequency: 20,
    scale: { start: 1, end: 0 },
    rotate: { min: -180, max: 180 },
    on: false
  });



  // Physics group to accumulate fallen bodies
  bodyGroup = scene.physics.add.group();
  // Targets should remain stationary until hit
  targetGroup = scene.physics.add.group({
    allowGravity: false,
    immovable: true
  });
  scene.physics.add.overlap(prisonerHead, targetGroup, (_, target) => {
    handleTargetHit(scene, target, prisonerHead);
  });
  // Enable collisions between bodies so they pile up
  scene.physics.add.collider(bodyGroup, bodyGroup);
  // Stop corpses completely after two bounces
  scene.physics.world.on('worldbounds', (body, up, down) => {
    const obj = body.gameObject;
    if (!obj || !obj.isCorpse) return;
    if (down) {
      if (obj.jester && !obj.jester.running) {
        obj.jester.running = true;
        const offX = obj.jester.startFromRight ? 900 : -100;
        obj.scene.tweens.add({
          targets: obj.jester,
          x: offX,
          duration: 1500,
          ease: 'Linear',
          onComplete: () => obj.jester.destroy()
        });
      }
      obj.bounceCount = (obj.bounceCount || 0) + 1;
      if (obj.bounceCount >= 2) {
        // Lay the corpse on its side most of the time
        if (Math.random() < 0.9) {
          const sign = Math.random() < 0.5 ? -1 : 1;
          obj.setRotation(sign * Phaser.Math.DegToRad(90));
        }

        body.setBounce(0);
        body.setVelocity(0, 0);
        body.setAngularVelocity(0);
        body.setAllowGravity(false);
        body.setImmovable(true);
        body.moves = false;

        // Disable physics so the frozen body no longer collides
        obj.scene.physics.world.disable(obj);
      }
    }
  });

  scene.time.addEvent({
    delay: 400,
    loop: true,
    callback: () => {
      if (stageBlood.visible && stageBlood.displayWidth > 0) {
        const half = stageBlood.displayWidth / 2;
        const x = Phaser.Math.Between(stageBlood.x - half, stageBlood.x + half);
        dripEmitter.emitParticleAt(x, stageBlood.y, 1);
      }
    }
  });

  scene.time.addEvent({
    delay: 2000,
    loop: true,
    callback: () => {
      bodyGroup.getChildren().forEach(obj => {
        if (obj.isCorpse && (!obj.body || !obj.body.enable)) {
          if (Phaser.Math.Between(0, 100) < 5) {
            splatEmitter.explode(5, obj.x, obj.y);
          }
        }
      });
    }
  });

  
  // Storage and weapons signs
  storageButton = scene.add.image(0, 0, 'signStorage')
    .setOrigin(0, 0)
    .setDisplaySize(107, 71)
    .setInteractive()
    .on('pointerdown', () => { toggleStorage(scene); });
  weaponsButton = scene.add.image(120, 0, 'signWeapons')
    .setOrigin(0, 0)
    .setDisplaySize(107, 71)
    .setInteractive()
    .on('pointerdown', () => { toggleWeapons(scene); });

  // Shop button
  // Move the shop button slightly right to make room for the travel sign
  shopButton = scene.add.image(800, 0, 'shop')
    .setOrigin(1, 0)
    .setDisplaySize(107, 71)
    .setInteractive()
    .on('pointerdown', () => {
      toggleShop(scene);
    });

  // Travel button
  travelButton = scene.add.image(680, 0, 'signTravel')
    .setOrigin(1, 0)
    .setDisplaySize(107, 71)
    .setInteractive()
    .on('pointerdown', () => { toggleTravel(scene); });

  // Storage upgrade container and overlay
  storageOverlay = scene.add.rectangle(400, 300, 800, 600, 0x000000, 0)
    .setVisible(false)
    .setDepth(30);
  storageContainer = scene.add.container(0, 0).setVisible(false).setDepth(31);
  const storageSky = scene.add.image(400, 300, 'backgroundSky')
    .setDisplaySize(800, 600);
  const storageBg = scene.add.image(400, 300, 'backgroundStorage')
    .setDisplaySize(800, 600);
  storageImage = scene.add.image(400, 560, `storage${player.storageLevel}`)
    .setOrigin(0.5, 1);
  storageCostText = scene.add.text(400, 250, '', { font: '24px monospace', fill: '#ffd700' })
    .setOrigin(0.5)
    .setStroke('#000000', 3);
  upgradeButton = scene.add.image(400, 290, 'upgradeButton')
    .setOrigin(0.5, 0)
    .setScale(0.5)
    .setInteractive()
    .on('pointerdown', () => { upgradeStorage(scene); });
  const storageClose = scene.add.image(700, 0, 'signClose')
    .setOrigin(0, 0)
    .setDisplaySize(100, 100)
    .setInteractive()
    .on('pointerdown', () => { toggleStorage(scene); });
  storageContainer.add([storageSky, storageBg, storageImage, upgradeButton, storageCostText, storageClose]);
  updateStorageUI();

  // Weapons upgrade container and overlay
  weaponsOverlay = scene.add.rectangle(400, 300, 800, 600, 0x000000, 0)
    .setVisible(false)
    .setDepth(30);
  weaponsContainer = scene.add.container(0, 0).setVisible(false).setDepth(31);
  const weaponsSky = scene.add.image(400, 300, 'backgroundSky')
    .setDisplaySize(800, 600);
  const weaponsBg = scene.add.image(400, 300, 'backgroundWeapons')
    .setDisplaySize(800, 600);
  weaponsImage = scene.add.image(400, 300, `weapons${player.weaponLevel}`)
    .setOrigin(0.5);
  weaponsCostText = scene.add.text(400, 460, '', { font: '24px monospace', fill: '#ffd700' })
    .setOrigin(0.5)
    .setStroke('#000000', 3);
  weaponUpgradeButton = scene.add.image(400, 500, 'upgradeButton')
    .setOrigin(0.5, 0)
    .setScale(0.5)
    .setInteractive()
    .on('pointerdown', () => { upgradeWeapon(scene); });
  const weaponsClose = scene.add.image(700, 0, 'signClose')
    .setOrigin(0, 0)
    .setDisplaySize(100, 100)
    .setInteractive()
    .on('pointerdown', () => { toggleWeapons(scene); });
  weaponsContainer.add([weaponsSky, weaponsBg, weaponsImage, weaponUpgradeButton, weaponsCostText, weaponsClose]);
  updateWeaponsUI();

  // Travel container and overlay
  travelOverlay = scene.add.rectangle(400, 300, 800, 600, 0x000000, 0)
    .setVisible(false)
    .setDepth(30);
  travelContainer = scene.add.container(50, 50).setVisible(false).setDepth(31);
  const travelBg = scene.add.rectangle(0, 0, 700, 500, 0x222222, 1).setOrigin(0, 0);
  travelBg.setStrokeStyle(2, 0xffffff);
  travelContainer.add(travelBg);
  travelList = scene.add.container(0, 40);
  travelContainer.add(travelList);
  travelRegion = null;
  showTravelMenu(scene);
  const travelClose = scene.add.image(600, 0, 'signClose')
    .setOrigin(0, 0)
    .setDisplaySize(100, 100)
    .setInteractive()
    .on('pointerdown', () => { toggleTravel(scene); });
  travelContainer.add(travelClose);
  updateTravelUI(scene);

  // Shop container and overlay
  shopOverlay = scene.add.rectangle(400, 300, 800, 600, 0x000000, 0)
    .setVisible(false)
    .setDepth(30);
  shopContainer = scene.add.container(50, 50).setVisible(false).setDepth(31);
  const shopBg = scene.add.rectangle(0, 0, 700, 500, 0x222222, 1).setOrigin(0, 0);
  shopBg.setStrokeStyle(2, 0xffffff);
  shopContainer.add(shopBg);

  // Tab buttons
  const weaponTab = scene.add.text(20, 10, 'Weapon Upgrades', { font: '18px monospace', fill: '#ffff00' })
    .setInteractive()
    .on('pointerdown', () => showShopTab(scene, 'weapons'));
  const upgradeTab = scene.add.text(300, 10, 'Game Upgrades', { font: '18px monospace', fill: '#ffffff' })
    .setInteractive()
    .on('pointerdown', () => showShopTab(scene, 'upgrades'));
  const marketTab = scene.add.text(520, 10, 'Trading Market', { font: '18px monospace', fill: '#ffffff' })
    .setInteractive()
    .on('pointerdown', () => showShopTab(scene, 'market'));
  shopContainer.add([weaponTab, upgradeTab, marketTab]);

  // Containers for each tab's contents
  const weaponList = scene.add.container(0, 40);
  const upgradeList = scene.add.container(0, 40).setVisible(false);
  const marketList = scene.add.container(0, 60).setVisible(false);
  shopContainer.add([weaponList, upgradeList, marketList]);

  // Weapon upgrade items
  let itemY = 0;
  weapons.forEach((w, idx) => {
    const title = scene.add.text(10, itemY, `${w.name} - ${w.type} - ${w.cost}g`, { font: '18px monospace', fill: '#ffffaa' });
    const desc = scene.add.text(20, itemY + 20, w.desc, { font: '14px monospace', fill: '#ffffff', wordWrap: { width: 520 } });
    const buy = scene.add.text(550, itemY, '[Buy]', { font: '18px monospace', fill: '#00ff00' })
      .setInteractive()
      .on('pointerdown', () => { buyWeapon(scene, idx); });
    weaponList.add([title, desc, buy]);
    w.ui = { buy };
    itemY += 70;
  });

  // Game upgrade items
  itemY = 0;
  gameUpgrades.forEach((g, idx) => {
    const title = scene.add.text(10, itemY, `${g.name} - ${g.cost}g`, { font: '18px monospace', fill: '#ffffaa' });
    const desc = scene.add.text(20, itemY + 20, g.desc, { font: '14px monospace', fill: '#ffffff', wordWrap: { width: 520 } });
    const buy = scene.add.text(550, itemY, '[Buy]', { font: '18px monospace', fill: '#00ff00' })
      .setInteractive()
      .on('pointerdown', () => { buyUpgrade(scene, idx); });
    upgradeList.add([title, desc, buy]);
    g.ui = { buy };
    itemY += 70;
  });

  // Market items displayed as a table
  itemY = 0;
  const cols = {
    name: 10,
    buy: 220,
    sell: 300,
    qty: 370,
    buyBtn: 440,
    sellBtn: 520
  };
  // Header row
  const headItem = scene.add.text(cols.name, itemY, 'Item', { font: '18px monospace', fill: '#ffffaa' });
  const headBuy = scene.add.text(cols.buy, itemY, 'Buy', { font: '18px monospace', fill: '#ffffaa' });
  const headSell = scene.add.text(cols.sell, itemY, 'Sell', { font: '18px monospace', fill: '#ffffaa' });
  const headQty = scene.add.text(cols.qty, itemY, 'Qty', { font: '18px monospace', fill: '#ffffaa' });
  marketList.add([headItem, headBuy, headSell, headQty]);
  itemY += 25;

  marketItems.forEach((m, idx) => {
    const name = scene.add.text(cols.name, itemY, m.name, { font: '18px monospace', fill: '#ffffaa' });
    const buyPrice = scene.add.text(cols.buy, itemY, '', { font: '18px monospace', fill: '#ffffaa' });
    const sellPrice = scene.add.text(cols.sell, itemY, '', { font: '18px monospace', fill: '#ffffaa' });
    const qtyText = scene.add.text(cols.qty, itemY, '', { font: '18px monospace', fill: '#ffffaa' });
    const buyBtn = scene.add.text(cols.buyBtn, itemY, '[Buy]', { font: '18px monospace', fill: '#00ff00' })
      .setInteractive()
      .on('pointerdown', () => { showTradeMenu(scene, idx, 'buy'); });
    const sellBtn = scene.add.text(cols.sellBtn, itemY, '[Sell]', { font: '18px monospace', fill: '#00ff00' })
      .setInteractive()
      .on('pointerdown', () => { showTradeMenu(scene, idx, 'sell'); });
    marketList.add([name, buyPrice, sellPrice, qtyText, buyBtn, sellBtn]);
    m.ui = { name, buyPrice, sellPrice, qtyText, buyBtn, sellBtn };
    itemY += 25;
  });
  marketChatterText = scene.add.text(350, 400, '', {
    font: '20px monospace',
    fill: '#ffaaaa',
    wordWrap: { width: 640 }
  }).setOrigin(0.5);
  const body = scene.add.image(0, 0, 'prisonerBody1').setOrigin(0.5, 1).setScale(1);
  const head = scene.add.image(0, -80, 'prisonerHead1').setOrigin(0.5).setScale(1);
  marketPrisoner = scene.add.container(0, 0, [body, head]);
  marketList.add([marketChatterText, marketPrisoner]);

  const closeBtn = scene.add.image(600, 0, 'signClose')
    .setOrigin(0, 0)
    .setDisplaySize(100, 100)
    .setInteractive()
    .on('pointerdown', () => { toggleShop(scene); });
  shopContainer.add(closeBtn);

  // Trade menu overlay for buying and selling quantities
  tradeOverlay = scene.add.rectangle(400, 300, 800, 600, 0x000000, 0)
    .setVisible(false)
    .setDepth(40);
  tradeContainer = scene.add.container(210, 200).setVisible(false).setDepth(41);
  const tradeBg = scene.add.rectangle(0, 0, 380, 140, 0x222222, 1).setOrigin(0, 0);
  tradeBg.setStrokeStyle(2, 0xffffff);
  tradeTitle = scene.add.text(190, 10, '', { font: '18px monospace', fill: '#ffffaa' })
    .setOrigin(0.5, 0);
  const b1 = scene.add.text(20, 50, '[Buy 1]', { font: '18px monospace', fill: '#00ff00' })
    .setInteractive()
    .on('pointerdown', () => { buyMarketItem(scene, tradeItemIndex, 1); hideTradeMenu(scene); });
  const b10 = scene.add.text(140, 50, '[Buy 10]', { font: '18px monospace', fill: '#00ff00' })
    .setInteractive()
    .on('pointerdown', () => { buyMarketItem(scene, tradeItemIndex, 10); hideTradeMenu(scene); });
  const bMax = scene.add.text(260, 50, '[Buy Max]', { font: '18px monospace', fill: '#00ff00' })
    .setInteractive()
    .on('pointerdown', () => {
      const item = marketItems[tradeItemIndex];
      const goldMax = Math.floor(player.gold / item.currentBuy);
      const space = player.maxStorage - getInventoryCount();
      const max = Math.min(goldMax, space);
      if (max > 0) buyMarketItem(scene, tradeItemIndex, max);
      hideTradeMenu(scene);
    });
  const s1 = scene.add.text(20, 90, '[Sell 1]', { font: '18px monospace', fill: '#00ff00' })
    .setInteractive()
    .on('pointerdown', () => { sellMarketItem(scene, tradeItemIndex, 1); hideTradeMenu(scene); });
  const s10 = scene.add.text(140, 90, '[Sell 10]', { font: '18px monospace', fill: '#00ff00' })
    .setInteractive()
    .on('pointerdown', () => { sellMarketItem(scene, tradeItemIndex, 10); hideTradeMenu(scene); });
  const sMax = scene.add.text(260, 90, '[Sell Max]', { font: '18px monospace', fill: '#00ff00' })
    .setInteractive()
    .on('pointerdown', () => {
      const item = marketItems[tradeItemIndex];
      const max = inventory[item.name] || 0;
      if (max > 0) sellMarketItem(scene, tradeItemIndex, max);
      hideTradeMenu(scene);
    });
  const tradeClose = scene.add.image(280, 0, 'signClose')
    .setOrigin(0, 0)
    .setDisplaySize(100, 100)
    .setInteractive()
    .on('pointerdown', () => { hideTradeMenu(scene); });
  tradeContainer.add([tradeBg, tradeTitle, b1, b10, bMax, s1, s10, sMax, tradeClose]);
  tradeBuyBtns = [b1, b10, bMax];
  tradeSellBtns = [s1, s10, sMax];

  // Store references for later use
  scene.weaponTab = weaponTab;
  scene.upgradeTab = upgradeTab;
  scene.marketTab = marketTab;
  scene.weaponList = weaponList;
  scene.upgradeList = upgradeList;
  scene.marketList = marketList;

  // Set up first day's prices and gossip
  dailyMarketUpdate();

  // Default to weapon tab
  showShopTab(scene, 'weapons');

  // Text popup
  scene.popupText = scene.add.text(400, 250, '', { font: '24px serif', fill: '#ffffff' })
    .setOrigin(0.5)
    .setVisible(false);

  // Input key for timing
  scene.input.keyboard.on('keydown-SPACE', () => {
    if (swingActive && inputEnabled) endSwing(scene);
  });
  scene.input.on('pointerdown', () => {
    if (awaitingAngle) {
      chooseAngle(scene);
    } else if (awaitingPower) {
      choosePower(scene);
    } else if (swingActive && inputEnabled) {
      endSwing(scene);
    }
  });

  // Targets spawn with each prisoner
}

let swingDirection = 1;

// Helper to fade the overlay that darkens the entire screen.
// Used for menu and travel fades.
let screenFadeTween = null;
function fadeScreenOverlay(scene, alpha, duration = 300, onComplete) {
  if (screenFadeTween) {
    screenFadeTween.stop();
  }
  screenFadeOverlay.setVisible(true);
  screenFadeTween = scene.tweens.add({
    targets: screenFadeOverlay,
    alpha,
    duration,
    onComplete: () => {
      screenFadeTween = null;
      if (alpha === 0) {
        screenFadeOverlay.setVisible(false);
      }
      if (onComplete) onComplete();
    }
  });
}

// Fade only the background layer for dramatic effects, e.g. executioner intro.
let backgroundFadeTween = null;
function fadeBackgroundOverlay(scene, alpha, duration = 300, onComplete) {
  if (backgroundFadeTween) {
    backgroundFadeTween.stop();
  }
  backgroundFadeOverlay.setVisible(true);
  backgroundFadeTween = scene.tweens.add({
    targets: backgroundFadeOverlay,
    alpha,
    duration,
    onComplete: () => {
      backgroundFadeTween = null;
      if (alpha === 0) {
        backgroundFadeOverlay.setVisible(false);
      }
      if (onComplete) onComplete();
    }
  });
}

function toggleShop(scene) {
  const visible = !shopContainer.visible;
  shopOverlay.setVisible(visible);
  shopContainer.setVisible(visible);
  setGoldChestVisible(!visible);
  if (dateBg) dateBg.setVisible(!visible);
  if (dateText) dateText.setVisible(!visible);
  if (visible) {
    // Fade the game behind the shop so it appears paused and dimmed
    fadeScreenOverlay(scene, 0.5);
    showShopTab(scene, scene.activeTab || 'weapons');
    if (hideMeterEvent) {
      hideMeterEvent.remove(false);
      hideMeterEvent = null;
    }
    swingActive = false;
    inputEnabled = false;
    cursor.setVisible(false);
    // backOverlayWasVisible = backOverlay.visible;
    // backOverlay.setVisible(false);
    scene.physics.world.pause();
    scene.tweens.pauseAll();
    // Pausing the entire scene's time also halts input processing, which
    // prevented shop buttons from receiving pointer events.  We only pause
    // physics and tweens so the game action freezes while keeping the UI
    // responsive.
  } else {
    // backOverlay.setVisible(backOverlayWasVisible);
    // Remove the dim when closing the shop
    fadeScreenOverlay(scene, 0);
    scene.physics.world.resume();
    scene.tweens.resumeAll();
    // No need to unpause the Time plugin since we never fully pause it for the
    // shop overlay.
    releaseQueuedCoins(scene);
    startSwingMeter(scene);
  }
}

function buyWeapon(scene, index) {
  const w = weapons[index];
  if (w.purchased) return;
  if (player.gold >= w.cost) {
    player.gold -= w.cost;
    goldText.setText(formatGold(player.gold));
    zoneMods.red += w.effects.red || 0;
    zoneMods.yellow += w.effects.yellow || 0;
    zoneMods.green += w.effects.green || 0;
    updateZones();
    w.purchased = true;
    if (w.ui && w.ui.buy) {
      w.ui.buy.setText('Bought').disableInteractive();
    }
  }
}

function updateZones() {
  // Increase total meter width by 4 pixels per level (2 per end)
  const baseYellow = baseSizes.yellow + (player.weaponLevel - 1) * (4 / 3);
  const scale = baseYellow / baseSizes.yellow;
  const baseRed = baseSizes.red * scale;
  const baseGreen = baseSizes.green * scale;

  redZone.displayWidth = baseRed + zoneMods.red;
  yellowZone.displayWidth = baseYellow + zoneMods.yellow;
  greenZone.displayWidth = baseGreen + zoneMods.green;
}

// Switch between shop tabs and update highlights
function showShopTab(scene, tab) {
  scene.activeTab = tab;
  scene.weaponList.setVisible(tab === 'weapons');
  scene.upgradeList.setVisible(tab === 'upgrades');
  scene.marketList.setVisible(tab === 'market');
  scene.weaponTab.setFill(tab === 'weapons' ? '#ffff00' : '#ffffff');
  scene.upgradeTab.setFill(tab === 'upgrades' ? '#ffff00' : '#ffffff');
  scene.marketTab.setFill(tab === 'market' ? '#ffff00' : '#ffffff');
  if (tab === 'market') {
    updateMarketUI();
    updateMarketChatter();
  }
}

// Purchase a fame boosting upgrade
function buyUpgrade(scene, index) {
  const u = gameUpgrades[index];
  if (u.purchased || fame < u.fameReq) return;
  if (player.gold >= u.cost) {
    player.gold -= u.cost;
    goldText.setText(formatGold(player.gold));
    fameMultiplier = u.mult;
    u.purchased = true;
    if (u.ui && u.ui.buy) {
      u.ui.buy.setText('Bought').disableInteractive();
    }
  }
}

// Buying from the trading market
function buyMarketItem(scene, index, qty = 1) {
  const item = marketItems[index];
  if (fame < item.fameReq) return;
  const cost = item.currentBuy * qty;
  if (player.gold >= cost && getInventoryCount() + qty <= player.maxStorage) {
    player.gold -= cost;
    goldText.setText(formatGold(player.gold));
    inventory[item.name] = (inventory[item.name] || 0) + qty;
    updateMarketUI();
  }
}

// Selling items the player owns
function sellMarketItem(scene, index, qty = 1) {
  const item = marketItems[index];
  if ((inventory[item.name] || 0) >= qty) {
    inventory[item.name] -= qty;
    addGold(scene, item.currentSell * qty);
    updateMarketUI();
  }
}


// Update market text lines with prices and inventory
function updateMarketUI() {
  marketItems.forEach(m => {
    if (!m.ui) return;
    const qty = inventory[m.name] || 0;
    const locked = fame < m.fameReq;
    m.ui.name.setText(locked ? `${m.name} (F${m.fameReq})` : m.name);
    m.ui.buyPrice.setText(locked ? '-' : `${m.currentBuy}g`);
    m.ui.sellPrice.setText(locked ? '-' : `${m.currentSell}g`);
    m.ui.qtyText.setText(qty);
    const canBuy = !locked && player.gold >= m.currentBuy && getInventoryCount() < player.maxStorage;
    const canSell = qty >= 1;
    m.ui.buyBtn.setFill(canBuy ? '#00ff00' : '#777777');
    m.ui.sellBtn.setFill(canSell ? '#00ff00' : '#777777');
  });
}

function updateTravelUI(scene) {
  cities.forEach(c => {
    if (!c.ui) return;
    const locked = c.fameReq && fame < c.fameReq;
    const days = getTravelDays(currentCity, c.name);
    const title = c.name === currentCity ? c.name : `${c.name} — ${days} days`;
    c.ui.title.setText(title);
    const label = c.name === currentCity ? '[Here]' : locked ? '[Locked]' : '[Go]';
    c.ui.btn.setText(label);
    const color = c.name === currentCity || locked ? '#777777' : '#00ff00';
    c.ui.btn.setFill(color);
  });
}

function showTravelMenu(scene, region = travelRegion) {
  travelRegion = region;
  travelList.removeAll(true);
  cities.forEach(c => { if (c.ui) delete c.ui; });

  // If no region selected, present North/South options first with placeholders
  if (!travelRegion) {
    const northBtn = scene.add.text(10, 0, 'The North', { font: '18px monospace', fill: '#00ff00' })
      .setInteractive()
      .on('pointerdown', () => showTravelMenu(scene, 'north'));
    const southBtn = scene.add.text(360, 0, 'The South', { font: '18px monospace', fill: '#00ff00' })
      .setInteractive()
      .on('pointerdown', () => showTravelMenu(scene, 'south'));
    const northPlaceholder = scene.add
      .image(10, 30, 'mapNorth')
      .setOrigin(0, 0)
      .setDisplaySize(250, 400)
      .setInteractive()
      .on('pointerdown', () => showTravelMenu(scene, 'north'));
    const southPlaceholder = scene.add
      .image(360, 30, 'mapSouth')
      .setOrigin(0, 0)
      .setDisplaySize(250, 400)
      .setInteractive()
      .on('pointerdown', () => showTravelMenu(scene, 'south'));
    travelList.add([northBtn, southBtn, northPlaceholder, southPlaceholder]);
    return;
  }

  let cityY = 10;
  cities.filter(c => c.region === travelRegion).forEach(city => {
    const title = scene.add.text(10, cityY, '', { font: '18px monospace', fill: '#ffffaa', wordWrap: { width: 420 } });
    const btn = scene.add.text(500, cityY, '[Go]', { font: '18px monospace', fill: '#00ff00' })
      .setInteractive()
      .on('pointerdown', () => {
        travelToCity(scene, city);
      });
    travelList.add([title, btn]);
    city.ui = { title, btn };
    cityY += 30;
  });

  const backBtn = scene.add.text(10, cityY + 10, '[Back]', { font: '18px monospace', fill: '#ffff00' })
    .setInteractive()
    .on('pointerdown', () => showTravelMenu(scene, null));
  travelList.add(backBtn);

  updateTravelUI(scene);
}

function toggleTravel(scene, resume = true, withFade = true) {
  const visible = !travelContainer.visible;
  travelOverlay.setVisible(visible);
  travelContainer.setVisible(visible);
  setGoldChestVisible(!visible);
  if (dateBg) dateBg.setVisible(!visible);
  if (dateText) dateText.setVisible(!visible);
  if (visible) {
    // Dim the background while the travel menu is open
    if (withFade) fadeScreenOverlay(scene, 0.5);
    travelRegion = null;
    showTravelMenu(scene);
    updateTravelUI(scene);
    if (hideMeterEvent) {
      hideMeterEvent.remove(false);
      hideMeterEvent = null;
    }
    swingActive = false;
    inputEnabled = false;
    cursor.setVisible(false);
    // backOverlayWasVisible = backOverlay.visible;
    // backOverlay.setVisible(false);
    scene.physics.world.pause();
    scene.tweens.pauseAll();
    // Do not pause the global time system; doing so disables input events and
    // breaks the travel and shop interfaces.  Physics and tweens are paused to
    // freeze gameplay while menus are open.
  } else {
    // backOverlay.setVisible(backOverlayWasVisible);
    // Clear the dim when returning to gameplay
    if (withFade) fadeScreenOverlay(scene, 0);
    scene.physics.world.resume();
    scene.tweens.resumeAll();
    // Time was never paused for the travel overlay, so there is nothing to
    // resume beyond physics and tweens.
    releaseQueuedCoins(scene);
    if (resume) startSwingMeter(scene);
  }
}

// Toggle the storage upgrade screen
function toggleStorage(scene) {
  const visible = !storageContainer.visible;
  storageOverlay.setVisible(visible);
  storageContainer.setVisible(visible);
  setGoldChestVisible(!visible);
  if (dateBg) dateBg.setVisible(!visible);
  if (dateText) dateText.setVisible(!visible);
  if (visible) {
    fadeScreenOverlay(scene, 0.5);
    updateStorageUI();
    if (hideMeterEvent) {
      hideMeterEvent.remove(false);
      hideMeterEvent = null;
    }
    swingActive = false;
    inputEnabled = false;
    cursor.setVisible(false);
    scene.physics.world.pause();
    scene.tweens.pauseAll();
    storageButton.disableInteractive();
    shopButton.disableInteractive();
    weaponsButton.disableInteractive();
    travelButton.disableInteractive();
  } else {
    fadeScreenOverlay(scene, 0);
    scene.physics.world.resume();
    scene.tweens.resumeAll();
    storageButton.setInteractive();
    shopButton.setInteractive();
    weaponsButton.setInteractive();
    travelButton.setInteractive();
    releaseQueuedCoins(scene);
    startSwingMeter(scene);
  }
}

// Cost to upgrade to the next storage level
function getStorageUpgradeCost() {
  return 10 * Math.pow(2, player.storageLevel - 1);
}

// Refresh storage image, upgrade cost text, and interactivity
function updateStorageUI() {
  if (!storageImage) return;
  storageImage.setTexture(`storage${player.storageLevel}`);
  if (player.storageLevel >= 16) {
    storageCostText.setText('Max Level Reached');
    upgradeButton.disableInteractive();
    upgradeButton.setAlpha(0.5);
  } else {
    const cost = getStorageUpgradeCost();
    storageCostText.setText(`Upgrade Cost: ${formatGold(cost)} gold`);
    upgradeButton.setAlpha(1);
    upgradeButton.setInteractive();
  }
}

// Attempt to upgrade storage if the player can afford it
function upgradeStorage(scene) {
  if (player.storageLevel >= 16) return;
  const cost = getStorageUpgradeCost();
  if (player.gold >= cost) {
    player.gold -= cost;
    goldText.setText(formatGold(player.gold));
    upgradeButton.disableInteractive();
    scene.tweens.add({
      targets: storageImage,
      scale: 1.2,
      duration: 200,
      yoyo: true,
      onComplete: () => {
        player.storageLevel++;
        player.maxStorage = player.storageLevel * 10;
        updateStorageUI();
      },
    });
  }
}

// Toggle the weapons upgrade screen
function toggleWeapons(scene) {
  const visible = !weaponsContainer.visible;
  weaponsOverlay.setVisible(visible);
  weaponsContainer.setVisible(visible);
  setGoldChestVisible(!visible);
  if (dateBg) dateBg.setVisible(!visible);
  if (dateText) dateText.setVisible(!visible);
  if (visible) {
    fadeScreenOverlay(scene, 0.5);
    updateWeaponsUI();
    if (hideMeterEvent) {
      hideMeterEvent.remove(false);
      hideMeterEvent = null;
    }
    swingActive = false;
    inputEnabled = false;
    cursor.setVisible(false);
    scene.physics.world.pause();
    scene.tweens.pauseAll();
    storageButton.disableInteractive();
    shopButton.disableInteractive();
    weaponsButton.disableInteractive();
    travelButton.disableInteractive();
  } else {
    fadeScreenOverlay(scene, 0);
    scene.physics.world.resume();
    scene.tweens.resumeAll();
    storageButton.setInteractive();
    shopButton.setInteractive();
    weaponsButton.setInteractive();
    travelButton.setInteractive();
    releaseQueuedCoins(scene);
    startSwingMeter(scene);
  }
}

// Cost to upgrade to the next weapon level
function getWeaponUpgradeCost() {
  return 10 * Math.pow(2, player.weaponLevel - 1);
}

// Refresh weapon image, upgrade cost text, and interactivity
function updateWeaponsUI() {
  if (!weaponsImage) return;
  weaponsImage.setTexture(`weapons${player.weaponLevel}`);
  if (player.weaponLevel >= 30) {
    weaponsCostText.setText('Max Level Reached');
    weaponUpgradeButton.disableInteractive();
    weaponUpgradeButton.setAlpha(0.5);
  } else {
    const cost = getWeaponUpgradeCost();
    weaponsCostText.setText(`Upgrade Cost: ${formatGold(cost)} gold`);
    weaponUpgradeButton.setAlpha(1);
    weaponUpgradeButton.setInteractive();
  }
  updateExecutionerWeaponTexture();
}

// Attempt to upgrade weapon if the player can afford it
function upgradeWeapon(scene) {
  if (player.weaponLevel >= 30) return;
  const cost = getWeaponUpgradeCost();
  if (player.gold >= cost) {
    player.gold -= cost;
    goldText.setText(formatGold(player.gold));
    weaponUpgradeButton.disableInteractive();
    player.weaponLevel++;
    weaponsImage.setTexture(`weapons${player.weaponLevel}`);
    weaponsImage.setScale(4);
    updateExecutionerWeaponTexture();
    updateZones();
    scene.tweens.add({
      targets: weaponsImage,
      scale: 1,
      duration: 300,
      ease: 'Cubic.easeOut',
      onComplete: () => {
        updateWeaponsUI();
      }
    });
  }
}

// Update executioner's carried weapon to current level
function updateExecutionerWeaponTexture() {
  if (executionerWeapon) {
    executionerWeapon.setTexture(`weapons${player.weaponLevel}`);
  }
}

// Total items currently stored in inventory
function getInventoryCount() {
  return Object.values(inventory).reduce((s, v) => s + v, 0);
}

// Fade completely to black, change cities, then reveal the new scene.
function travelToCity(scene, city) {
  const days = getTravelDays(currentCity, city.name);
  toggleTravel(scene, false, false);
  setGoldChestVisible(false);
  // Clear any residual screen dim from the travel menu before pausing the scene
  if (screenFadeTween) {
    screenFadeTween.stop();
    screenFadeTween = null;
  }
  screenFadeOverlay.setAlpha(0);
  screenFadeOverlay.setVisible(false);
  scene.scene.launch('TravelScene', { city, days, mainScene: scene });
  scene.scene.pause();
}

function showTradeMenu(scene, index, mode = 'buy') {
  tradeItemIndex = index;
  tradeMode = mode;
  tradeTitle.setText(marketItems[index].name);
  const showBuy = mode === 'buy';
  tradeBuyBtns.forEach(btn => btn.setVisible(showBuy));
  tradeSellBtns.forEach(btn => btn.setVisible(!showBuy));
  tradeOverlay.setVisible(true);
  tradeContainer.setVisible(true);
  if (currentWeather === 'rain' && rainEmitter && rainParts) {
    rainEmitter.stop();
    rainEmitter.killAll();
    rainParts.setVisible(false);
  } else if (currentWeather === 'fog' && fogEmitter && fogParts) {
    fogEmitter.stop();
    fogEmitter.killAll();
    fogParts.setVisible(false);
  } else if (currentWeather === 'wind' && windEmitter && windParts) {
    windEmitter.stop();
    windEmitter.killAll();
    windParts.setVisible(false);
  }
  if (hideMeterEvent) {
    hideMeterEvent.remove(false);
    hideMeterEvent = null;
  }
  swingActive = false;
  inputEnabled = false;
  cursor.setVisible(false);
  // backOverlayWasVisible = backOverlay.visible;
  // backOverlay.setVisible(false);
  scene.physics.world.pause();
  scene.tweens.pauseAll();
  scene.time.paused = true;
}

function hideTradeMenu(scene) {
  tradeOverlay.setVisible(false);
  tradeContainer.setVisible(false);
  // backOverlay.setVisible(backOverlayWasVisible);
  scene.physics.world.resume();
  scene.tweens.resumeAll();
  scene.time.paused = false;
  if (currentWeather === 'rain' && rainEmitter && rainParts) {
    rainParts.setVisible(true);
    rainEmitter.start();
  } else if (currentWeather === 'fog' && fogEmitter && fogParts) {
    fogParts.setVisible(true);
    fogEmitter.start();
  } else if (currentWeather === 'wind' && windEmitter && windParts) {
    windParts.setVisible(true);
    windEmitter.start();
  }
  releaseQueuedCoins(scene);
  startSwingMeter(scene);
}

// function resetBackOverlay(scene) {
//   // Stop any existing fade tweens and return the background overlay
//   // to a fully transparent starting state.
//   scene.tweens.killTweensOf(backOverlay);
//   backOverlay.setAlpha(0);
//   backOverlay.setVisible(true);
// }

function resetForNewCity(scene) {
  killStreak = 0;
  streakMultiplierText.setText(`x${killStreak}`);
  missStreak = 0;
  missText.setText(`Misses: ${missStreak}`);
  bodyGroup.clear(true, true);
  targetGroup.getChildren().forEach(t => {
    if (t.jester) t.jester.destroy();
    t.destroy();
  });
  bloodPool.setVisible(false);
  bloodPool.displayHeight = 1;
  stageBlood.setVisible(false);
  stageBlood.displayWidth = 1;
  speedMultiplier = 1;
  swingSpeed = baseSwingSpeed;
  resetHead(scene);
  executioner.setVisible(false);
  prisoner.setVisible(false);
  leftEscort.setVisible(false);
  rightEscort.setVisible(false);
  introExecutioner(scene, () => spawnPrisoner(scene, false, false));
}

// Update the background image based on the current city. If a specific
// texture is missing fallback to the generic background.
function updateBackground(scene) {
  const key = `background-${currentCity.toLowerCase()}`;
  if (scene.textures.exists(key)) {
    backgroundRect.setTexture(key);
  } else {
    backgroundRect.setTexture('background');
  }
}

function selectCity(scene, city) {
  if (city.fameReq && fame < city.fameReq) return;
  if (city.name === currentCity) return;
  currentCity = city.name;
  // backgroundRect.setTint(city.bgColor); // disabled per request
  updateBackground(scene);
  locationText.setText(currentCity);
  // Ensure the travel UI overlay is hidden before starting the transition.
  // Force-close the travel menu in case it somehow remained visible
  // and ensure the dimming overlay disappears when travelling.
  travelOverlay.setVisible(false);
  travelContainer.setVisible(false);
  // Also hide other overlays in case they were inadvertently left open.
  shopOverlay.setVisible(false);
  shopContainer.setVisible(false);
  tradeOverlay.setVisible(false);
  tradeContainer.setVisible(false);
  // Reset the darkness overlay and begin the new city's intro fresh.
  // resetBackOverlay(scene);
  // Directly reset for the new city without fading the camera first.
  resetForNewCity(scene);
  applyRandomWeather(scene);
  roundCount = 1;
  // Extra safety: hide the travel overlay again in case any async events
  // re-enabled it during the city transition.
  travelOverlay.setVisible(false);
  setGoldChestVisible(true);
}

function savePrisoner(scene) {
  scene.tweens.add({
    targets: prisoner,
    x: 850,
    y: 460,
    duration: 2000,
    ease: 'Linear'
  });
}

function beheadPrisoner(scene, bloodAmount, angleDeg, power = 1) {
  if (headResetEvent) {
    headResetEvent.remove(false);
    headResetEvent = null;
  }
  const angle = angleDeg !== undefined ? angleDeg : Phaser.Math.Between(-110, -70);
  const rad = Phaser.Math.DegToRad(angle);
  const neckX = prisoner.x;
  const neckY = prisoner.y - 10;
  bloodEmitter.explode(bloodAmount, neckX, neckY);
  const headX0 = prisoner.x + prisonerHead.x;
  const headY0 = prisoner.y + prisonerHead.y;
  headEmitter.explode(bloodAmount / 2, headX0, headY0);

  if (lastGoldGain > 0) {
    showGoldGain(scene, lastGoldGain);
    lastGoldGain = 0;
  }

  // Create a physics body using the prisoner sprite for the falling corpse
  const corpse = scene.add.image(prisoner.x, prisoner.y + 50, prisonerBodyKey)
    .setOrigin(0.5, 1)
    .setDepth(0.5)
    .setTint(prisonerClass.color);
  scene.physics.world.enable(corpse);
  bodyGroup.add(corpse);
  corpse.isCorpse = true;
  corpse.bounceCount = 0;
  corpse.body.onWorldBounds = true;
  corpse.body.setBounce(0.05);
  corpse.body.setCollideWorldBounds(true);
  corpse.body.setDrag(50, 0);
  const corpseSpeed = 80 * power;
  // Throw the body based on the chosen slash angle and power
  corpse.body.setVelocity(Math.sin(rad) * corpseSpeed, Math.cos(rad) * corpseSpeed);
  // Spin faster so bodies topple onto their side
  corpse.body.setAngularVelocity(Phaser.Math.Between(-200, 200));

  // Pumping neck spurts while the body tumbles
  bloodEmitter.startFollow(corpse, 0, -50);
  bloodEmitter.setFrequency(60);
  bloodEmitter.setQuantity(Math.max(5, bloodAmount / 25));
  bloodEmitter.start();
  let pumpOn = true;
  if (neckPumpEvent) {
    neckPumpEvent.remove(false);
    neckPumpEvent = null;
  }
  neckPumpEvent = scene.time.addEvent({
    delay: 200,
    repeat: 6,
    callback: () => {
      pumpOn = !pumpOn;
      if (pumpOn) {
        bloodEmitter.start();
      } else {
        bloodEmitter.stop();
      }
    }
  });
  scene.time.delayedCall(1600, () => {
    bloodEmitter.stop();
    bloodEmitter.stopFollow();
    if (neckPumpEvent) {
      neckPumpEvent.remove(false);
      neckPumpEvent = null;
    }
  });

  // Reveal and grow the blood pool once the head is off
  bloodPool.setVisible(true);
  bloodPool.displayHeight = Math.min(bloodPool.displayHeight + 1, 100);
  stageBlood.setVisible(true);
  stageBlood.displayWidth = Math.min(stageBlood.displayWidth + 5, 300);

  // Hide the template prisoner while the physics body takes over
  prisoner.setVisible(false);

  // Spawn a new flying head sprite
  const flyingHead = scene.add.image(headX0, headY0, prisonerHeadKey)
    .setOrigin(0.5)
    .setDepth(0.8);
  scene.physics.world.enable(flyingHead);
  bodyGroup.add(flyingHead);
  flyingHead.isCorpse = true;
  flyingHead.isHead = true;
  flyingHead.bounceCount = 0;
  flyingHead.power = power;
  const hBody = flyingHead.body;
  scene.physics.add.overlap(flyingHead, targetGroup, (head, target) => {
    handleTargetHit(scene, target, head);
  });
  hBody.setAllowGravity(true);
  hBody.onWorldBounds = true;
  hBody.setCollideWorldBounds(true);
  hBody.checkCollision.left = false;
  hBody.checkCollision.right = false;
  hBody.checkCollision.up = false;
  hBody.setBounce(0.6);
  hBody.setDrag(50, 0);
  if (FEATURES.weather && currentWeather === 'rain') {
    hBody.setGravityY(0);
    flyingHead.rainGravityApplied = false;
  } else {
    hBody.setGravityY(0);
  }
  const speed = 250 * power;
  let vx = Math.sin(rad) * speed;
  if (FEATURES.weather && currentWeather === 'wind') {
    vx += windForce.x;
  }
  let vy = -Math.cos(rad) * speed;
  if (FEATURES.weather && currentWeather === 'wind') {
    vy += windForce.y;
  }
  hBody.setVelocity(vx, vy);
  hBody.setAngularVelocity(Phaser.Math.Between(-200, 200));

  headResetEvent = scene.time.delayedCall(2500, () => {
    headEmitter.stop();
    headEmitter.stopFollow();
    bloodEmitter.stop();
    bloodEmitter.stopFollow();
    if (neckPumpEvent) {
      neckPumpEvent.remove(false);
      neckPumpEvent = null;
    }
    headResetEvent = null;
  });

  // Continuous spurting from the flying head
  headEmitter.startFollow(flyingHead, 0, 15);
  headEmitter.setFrequency(20);
  headEmitter.setQuantity(Math.max(5, bloodAmount / 30));
  headEmitter.start();
}

function showAimArrow(scene, bloodAmount, nextSide) {
  pendingBlood = bloodAmount;
  pendingSpawnSide = nextSide;
  awaitingPower = false;
  if (arrowPowerTween) arrowPowerTween.stop();
  // Start the arrow pointing left and sweep over the top to the right
  aimArrow.setAngle(-90);
  aimArrow.setScale(1);
  aimArrow.setVisible(true);
  arrowTween = scene.tweens.add({
    targets: aimArrow,
    angle: { from: -90, to: 90 },
    duration: 800,
    yoyo: true,
    repeat: -1
  });
  awaitingAngle = true;
}

function chooseAngle(scene) {
  if (!awaitingAngle) return;
  awaitingAngle = false;
  if (arrowTween) arrowTween.stop();
  selectedAngle = aimArrow.angle;
  // start power selection tween
  // grow the arrow length only, keeping width constant
  aimArrow.scaleX = 1;
  arrowPowerTween = scene.tweens.add({
    targets: aimArrow,
    scaleY: { from: 0.5, to: 2 },
    duration: 800,
    yoyo: true,
    repeat: -1
  });
  aimArrow.setVisible(true);
  awaitingPower = true;
}

function choosePower(scene) {
  if (!awaitingPower) return;
  awaitingPower = false;
  if (arrowPowerTween) arrowPowerTween.stop();
  let power = aimArrow.scaleY;
  aimArrow.setVisible(false);
  slashExecutioner(scene, selectedAngle, () => {
    beheadPrisoner(scene, pendingBlood, selectedAngle, power);
    // give the head time to fly off screen before the next prisoner arrives
    scene.time.delayedCall(2600, () => {
      spawnPrisoner(scene, pendingSpawnSide === 'right');
    });
  });
}

function slashExecutioner(scene, angle, onComplete) {
  if (slashTween) slashTween.stop();
  slashTween = scene.tweens.add({
    targets: executioner,
    angle: { from: 0, to: -angle },
    duration: 150,
    yoyo: true,
    ease: 'Cubic.easeOut',
    onComplete: () => {
      slashTween = null;
      if (onComplete) onComplete();
    }
  });
}
function introExecutioner(scene, onComplete) {
  executionerIntro = false;
  // Ensure previous background tweens don't conflict
  // scene.tweens.killTweensOf(backOverlay);
  // Darken the scene as the executioner arrives for dramatic effect
  fadeBackgroundOverlay(scene, 0.6, 800);
  executioner.setPosition(850, 460);
  executioner.setAlpha(0);
  executioner.setVisible(true);
  // backOverlay.setAlpha(0);
  // backOverlay.setVisible(true);
  // scene.tweens.add({
  //   targets: backOverlay,
  //   alpha: 0.72,
  //   duration: 1000,
  //   ease: 'Linear'
  // });
  scene.tweens.add({
    targets: executioner,
    x: 400,
    alpha: 1,
    duration: 1500,
    ease: "Linear",
    onComplete: onComplete
  });
}

function resetHead(scene) {
  if (headResetEvent) {
    headResetEvent.remove(false);
    headResetEvent = null;
  }
  if (neckPumpEvent) {
    neckPumpEvent.remove(false);
    neckPumpEvent = null;
  }
  headEmitter.stop();
  headEmitter.stopFollow();
  bloodEmitter.stop();
  bloodEmitter.stopFollow();
  if (prisonerHead.body) {
    prisonerHead.body.stop();
    prisonerHead.body.setAllowGravity(false);
    scene.physics.world.disable(prisonerHead);
  }
  if (prisonerHead.parentContainer !== prisoner) {
    scene.children.remove(prisonerHead);
    prisoner.add(prisonerHead);
  }
  prisonerHead.setPosition(0, -20);
  prisonerHead.setRotation(0);
  prisonerBody.setAngle(0);
  prisonerBody.y = 50;
  prisoner.setAngle(0);
}



function spawnPrisoner(scene, fromRight, withTarget = true) {
  const city = cities.find(c => c.name === currentCity);
  roundCount++;
  if (FEATURES.weather && (roundCount === 1 || roundCount % 5 === 1)) {
    applyRandomWeather(scene);
  }
  // Temporarily disable background tinting when prisoners spawn
  // so we can determine if it is causing issues.
  // if (city) backgroundRect.setTint(city.bgColor);
  // Disable automatic dimming when a new prisoner spawns. Previously this
  // block would fade in the backOverlay to darken the scene whenever the
  // overlay's alpha was 0. This is temporarily removed as requested.
  // if (backOverlay.alpha === 0) {
  //   backOverlay.setAlpha(0);
  //   backOverlay.setVisible(true);
  //   scene.tweens.add({
  //     targets: backOverlay,
  //     alpha: 0.72,
  //     duration: 1000,
  //     ease: 'Linear'
  //   });
  // }
  prisoner.setVisible(true);
  // Birds now fly in once the jester has reached the stage
  resetHead(scene);
  prisonerClass = pickClass();
  if (prisonerClass.name === 'Clergy') {
    prisonerHeadKey = 'priestHead';
    prisonerBodyKey = 'priestBody';
  } else {
    const variant = Phaser.Math.Between(1, 3);
    prisonerHeadKey = `prisonerHead${variant}`;
    prisonerBodyKey = `prisonerBody${variant}`;
  }
  prisonerBody.setTexture(prisonerBodyKey);
  prisonerHeadSprite.setTexture(prisonerHeadKey);
  // Spawn up to 3 targets (jesters, barrels, etc.) each time a prisoner appears
  // The number of targets is chosen at random to keep gameplay varied
  if (withTarget) {
    const targetCount = Phaser.Math.Between(1, 3);
    for (let i = 0; i < targetCount; i++) {
      spawnTarget(scene);
    }
  }
  prisonerBody.setTint(prisonerClass.color);
  baseSwingSpeed = prisonerClass.speed;
  swingSpeed = baseSwingSpeed * speedMultiplier;
  // Keep body aligned under the head when resetting for a new prisoner
  prisonerBody.y = 50;
  
  const startX = fromRight ? 850 : -50;
  prisoner.setPosition(startX, 460);
  leftEscort.setPosition(startX - 50, 460);
  rightEscort.setPosition(startX + 50, 460);
  leftEscort.setVisible(true);
  rightEscort.setVisible(true);
  cursor.setVisible(false);
  swingBar.setVisible(false);
  redZone.setVisible(false);
  yellowZone.setVisible(false);
  greenZone.setVisible(false);
  scene.tweens.add({
    targets: prisoner,
    x: 400,
    duration: 1500,
    ease: 'Linear',
    onComplete: () => {
      // Once the prisoner reaches the center, have the escorts walk off
      // screen to the left instead of simply disappearing.
      scene.tweens.add({
        targets: leftEscort,
        x: -100,
        duration: 1500,
        ease: 'Linear',
        onComplete: () => leftEscort.setVisible(false)
      });
      scene.tweens.add({
        targets: rightEscort,
        x: 0,
        duration: 1500,
        ease: 'Linear',
        onComplete: () => rightEscort.setVisible(false)
      });
      // Keep the scene dimmed while the prisoner takes the stage
      startSwingMeter(scene);
    }
  });
  scene.tweens.add({ targets: leftEscort, x: 350, duration: 1500, ease: 'Linear' });
  scene.tweens.add({ targets: rightEscort, x: 450, duration: 1500, ease: 'Linear' });
}

// Wrapper for the hourly execution callback
function startExecutionRound() {
  if (game && game.scene && game.scene.scenes.length) {
    const scene = game.scene.scenes[0];
    // Randomize which side the prisoner enters from
    const fromRight = Phaser.Math.Between(0, 1) === 1;
    spawnPrisoner(scene, fromRight);
  }
}

function startSwingMeter(scene) {
  if (hideMeterEvent) {
    hideMeterEvent.remove(false);
    hideMeterEvent = null;
  }
  if (arrowTween) arrowTween.stop();
  if (arrowPowerTween) arrowPowerTween.stop();
  aimArrow.setVisible(false);
  awaitingAngle = false;
  awaitingPower = false;
  swingActive = true;
  inputEnabled = false;
  scene.time.delayedCall(200, () => { inputEnabled = true; });
  cursor.setVisible(true);
  swingBar.setVisible(true);
  redZone.setVisible(true);
  yellowZone.setVisible(true);
  greenZone.setVisible(true);
  // leave bloodPool visible between swings
  scene.popupText.setVisible(false);

  updateZones();

  // Reset positions
  cursor.x = 250;
  const zoneX = Phaser.Math.Between(300, 500);
  redZone.x = zoneX;
  yellowZone.x = zoneX;
  greenZone.x = zoneX;

  // Ensure head is attached and physics disabled
  resetHead(scene);



  // Meter only starts once prisoner is in position
}

function endSwing(scene) {
  swingActive = false;
  cursor.setVisible(false);
  const accuracy = Math.abs(cursor.x - redZone.x);
  let payout = 0;
  let message = '';
  let bloodAmount;
  let missed = false;
  let spawnSide = null;
  let spawnDelay = 500;
  if (accuracy <= greenZone.displayWidth / 2) {
    payout = 10;
    message = 'Perfect!';
    bloodAmount = 150; // big spurt
  } else if (accuracy <= yellowZone.displayWidth / 2) {
    payout = 5;
    message = 'Close!';
    bloodAmount = 60;
  } else if (accuracy <= redZone.displayWidth / 2) {
    payout = 2;
    message = 'Messy...';
    bloodAmount = 20;
  } else {
    payout = -2;
    bloodAmount = 5;
    missed = true;
  }

  // overall more blood
  bloodAmount *= 1.5;

  if (missed) {
    missStreak++;
    let strikeMsg = `Strike ${missStreak}`;
    if (missStreak >= 3) {
      payout -= 20;
      strikeMsg = 'Strike 3\nSaved!';
      missStreak = 0;
      savePrisoner(scene);
      spawnSide = 'left';
      pendingSpawnSide = 'left';
      spawnDelay = 2000; // wait for the freed prisoner to exit right
    }
    message = `Missed!\n${strikeMsg}`;
    killStreak = 0;
    speedMultiplier = 1;
    swingSpeed = baseSwingSpeed * speedMultiplier;
    streakMultiplierText.setText(`x${killStreak}`);
  } else {
    missStreak = 0;
    killCount++;
    killStreak++;
    if (killStreak > 1) {
      speedMultiplier *= 1.05;
    }
    swingSpeed = baseSwingSpeed * speedMultiplier;
    killText.setText(`Kills: ${killCount}`);
    streakMultiplierText.setText(`x${killStreak}`);
    addXP(scene, 1);
    showAimArrow(scene, bloodAmount, 'left');
    spawnSide = null;
    spawnDelay = 0;
  }
  missText.setText(`Misses: ${missStreak}`);

  const goldGain = missed ? payout : payout * killStreak;
  addGold(scene, goldGain);
  if (!missed && goldGain > 0) {
    lastGoldGain = goldGain;
  }

  // Increase and show blood bursts
  if (missed) {
    const neckX = prisoner.x;
    const neckY = prisoner.y - 10;
    bloodEmitter.explode(bloodAmount, neckX, neckY);
    const headX = prisoner.x + prisonerHead.x;
    const headY = prisoner.y + prisonerHead.y;
    headEmitter.explode(bloodAmount / 2, headX, headY);
  }

  // Show popup
  scene.popupText.setText(message);
  scene.popupText.setVisible(true);

  // Leave the meter visible briefly so players can see the result
  hideMeterEvent = scene.time.delayedCall(1000, () => {
    swingBar.setVisible(false);
    redZone.setVisible(false);
    yellowZone.setVisible(false);
    greenZone.setVisible(false);
    scene.time.delayedCall(spawnDelay, () => {
      if (awaitingAngle || awaitingPower) {
        return;
      }
      if (spawnSide) {
        spawnPrisoner(scene, spawnSide === 'right');
      } else {
        startSwingMeter(scene);
      }
    });
  });
}

function gainFame(scene, npc, amount = 1) {
  fame += amount * fameMultiplier;
  fameText.setText(`Fame: ${Math.floor(fame)}`);
  addXP(scene, 5 * amount);
  const popup = scene.add.text(npc.x, npc.y - 40, `+${amount} Fame`, {
    font: '20px monospace',
    fill: '#ffff00'
  }).setOrigin(0.5);
  scene.tweens.add({
    targets: popup,
    y: popup.y - 20,
    alpha: 0,
    duration: 800,
    onComplete: () => popup.destroy()
  });
  // Jester will run off when the target hits the ground
}

function showGoldGain(scene, amount) {
  const popup = scene.add.text(prisoner.x, prisoner.y - 40, `+${formatGold(amount)} Gold`, {
    font: '20px monospace',
    fill: '#ffff88'
  }).setOrigin(0.5);
  scene.tweens.add({
    targets: popup,
    y: popup.y - 20,
    alpha: 0,
    duration: 800,
    onComplete: () => popup.destroy()
  });
}

function handleTargetHit(scene, target, head) {
  if (target.collected) return;
  if (target.targetType === 'woodenShield' && head && head.power < 1.5) {
    head.body.setVelocityX(-head.body.velocity.x * 0.5);
    return;
  }
  target.collected = true;
  if (target.moveTween) { target.moveTween.stop(); target.moveTween = null; }
  const jester = target.jester;
  let fameGain = 1;
  if (target.isMoving) fameGain *= 2;
  if (target.targetType === 'royal') fameGain *= 5;
  if (target.targetType === 'holyMonk') fameGain = -2;
  if (target.targetType === 'bird') {
    bloodFireworkEmitter.explode(25, target.x, target.y);
    if (target.birdKind === 'dove') {
      fame = Math.max(0, fame - 1);
      fameText.setText(`Fame: ${Math.floor(fame)}`);
      fameGain = 0;
    } else {
      gainFame(scene, target, 1);
      addGold(scene, 1);
      fameGain = 0;
    }
    gainFame(scene, target, fameGain);
    targetGroup.remove(target);
    target.body.setVelocity(0, 0);
    target.body.setAllowGravity(false);
    target.body.setImmovable(true);
    target.body.setCollideWorldBounds(false);
    target.body.enable = false;
    scene.tweens.add({
      targets: target,
      y: 560,
      duration: 600,
      ease: 'Linear',
      onComplete: () => target.destroy()
    });
    return;
  }
  gainFame(scene, target, fameGain);
  if (target.targetType === 'explodingBarrel') {
    targetGroup.getChildren().forEach(t => {
      if (!t.collected && Phaser.Math.Distance.Between(t.x, t.y, target.x, target.y) < 300) {
        handleTargetHit(scene, t, head);
      }
    });
    targetGroup.remove(target);
    fireworkEmitter.explode(25, target.x, target.y);
    fireworkCloseEmitter.explode(40, target.x, target.y);
    if (jester && !jester.running) {
      jester.running = true;
      const offX = jester.startFromRight ? 900 : -100;
      scene.tweens.add({
        targets: jester,
        x: offX,
        duration: 1500,
        ease: 'Linear',
        onComplete: () => jester.destroy()
      });
    }
    target.destroy();
    return;
  }
  targetGroup.remove(target);
  // blood spray at impact
  splatEmitter.explode(15, target.x, target.y);
  target.body.setVelocity(0, 0);
  target.body.setAllowGravity(false);
  target.body.setImmovable(true);
  target.body.setCollideWorldBounds(false);
  target.body.enable = false;
  const dropY = jester ? jester.y + 30 : target.y + 30;
  scene.tweens.add({
    targets: target,
    // Drop the target down near the jester's feet
    y: dropY,
    duration: 300,
    ease: 'Linear',
    onComplete: () => {
      if (jester && !jester.running) {
        jester.running = true;
        const offX = jester.startFromRight ? 900 : -100;
        scene.tweens.add({
          targets: [jester, target],
          x: offX,
          duration: 1500,
          ease: 'Linear',
          onComplete: () => {
            jester.destroy();
            target.destroy();
          }
        });
      }
    }
  });
}

function spawnHolyMonk(scene) {
  const fromRight = Phaser.Math.Between(0, 1) === 1;
  const startX = fromRight ? 850 : -50;
  const monk = scene.add.container(startX, 460).setDepth(20);
  monk.targetType = 'holyMonk';
  createTargetAppearance(scene, monk, 'holyMonk');
  scene.physics.world.enable(monk);
  monk.body.setAllowGravity(false);
  monk.body.setImmovable(true);
  monk.body.setVelocityX(fromRight ? -30 : 30);
  monk.collected = false;
  monk.jester = null;
  targetGroup.add(monk);
  const changes = Phaser.Math.Between(1, 2);
  let done = 0;
  const changeEvent = scene.time.addEvent({
    delay: 1000,
    loop: true,
    callback: () => {
      if (Phaser.Math.Between(0, 1) === 1 && done < changes) {
        monk.body.setVelocityX(-monk.body.velocity.x);
        done++;
      }
    }
  });
  scene.time.delayedCall(Phaser.Math.Between(2000, 5000), () => {
    changeEvent.remove();
    scene.tweens.add({
      targets: monk,
      x: fromRight ? 850 : -50,
      duration: 1500,
      ease: 'Linear',
      onComplete: () => {
        monk.destroy();
      }
    });
  });
}

function spawnRoyal(scene) {
  const fromRight = Phaser.Math.Between(0, 1) === 1;
  const startX = fromRight ? 850 : -50;
  const stopX = fromRight ? 500 : 300;
  const royal = scene.add.container(startX, 460).setDepth(20);
  royal.targetType = 'royal';
  createTargetAppearance(scene, royal, 'royal');
  scene.physics.world.enable(royal);
  royal.body.setAllowGravity(false);
  royal.body.setImmovable(true);
  royal.body.setVelocityX(fromRight ? -40 : 40);
  royal.collected = false;
  royal.jester = null;
  targetGroup.add(royal);
  scene.tweens.add({
    targets: royal,
    x: stopX,
    duration: 1500,
    ease: 'Linear',
    onComplete: () => {
      royal.body.setVelocityX(0);
      scene.time.delayedCall(Phaser.Math.Between(2000, 5000), () => {
        scene.tweens.add({
          targets: royal,
          x: fromRight ? 850 : -50,
          duration: 1500,
          ease: 'Linear',
          onComplete: () => royal.destroy()
        });
      });
    }
  });
}

function spawnBird(scene) {
  const fromRight = Phaser.Math.Between(0, 1) === 1;
  const startX = fromRight ? 850 : -50;
  const endX = fromRight ? -50 : 850;
  const kind = Phaser.Math.Between(0, 1) ? 'dove' : 'crow';
  const bird = scene.add.container(startX, 160).setDepth(20);
  bird.targetType = 'bird';
  bird.birdKind = kind;
  bird.fromRight = fromRight;
  createTargetAppearance(scene, bird, 'bird');
  scene.physics.world.enable(bird);
  bird.body.setAllowGravity(false);
  bird.body.setImmovable(true);
  bird.body.setVelocityX(fromRight ? -40 : 40);
  bird.collected = false;
  bird.jester = null;
  targetGroup.add(bird);
  bird.moveTween = scene.tweens.add({
    targets: bird,
    x: endX,
    duration: 3000,
    ease: 'Linear',
    yoyo: true,
    repeat: 0,
    onYoyo: () => {
      bird.body.setVelocityX(-bird.body.velocity.x);
      const base = bird.birdKind === 'dove' ? 'birdWhite' : 'birdBlack';
      const movingRight = bird.body.velocity.x > 0;
      const dir = movingRight ? 'Right' : 'Left';
      if (bird.birdSprite) bird.birdSprite.setTexture(base + dir);
    },
    onComplete: () => bird.destroy()
  });
}

function spawnTarget(scene) {
  const type = chooseTargetType();
  if (type === 'holyMonk') {
    spawnHolyMonk(scene);
    return;
  }
  if (type === 'royal') {
    spawnRoyal(scene);
    return;
  }
  const fromRight = Phaser.Math.Between(0, 1) === 1;
  const startX = fromRight ? 850 : -50;
  const targetX = Phaser.Math.Between(100, 700);
  const poleHeight = Phaser.Math.Between(80, 180);

  const jester = scene.add.container(startX, 460).setDepth(1);
  jester.startFromRight = fromRight;
  const body = scene.add.image(0, 50, 'jesterBody1').setOrigin(0.5, 1);
  const pole = scene.add.rectangle(0, -20, 6, poleHeight, 0x8b4513)
    .setOrigin(0.5, 1);
  const head = scene.add.image(0, -20, 'jesterHead1').setOrigin(0.5);
  jester.add([body, pole, head]);

  const target = scene.add.container(startX, 460 - 20 - poleHeight).setDepth(20);
  target.targetType = type;
  createTargetAppearance(scene, target, type);

  if (type === 'woodenShield') {
    if (killStreak >= 3) {
      target.isMoving = true;
      const dur = killStreak >= 10 ? 400 : 800;
      target.moveTween = scene.tweens.add({
        targets: target,
        y: target.y - 20,
        duration: dur,
        yoyo: true,
        repeat: -1,
        ease: 'Sine.easeInOut'
      });
    }
  } else if (FEATURES.movingTargets && Phaser.Math.Between(0, 1) === 1) {
    target.isMoving = true;
    target.moveTween = scene.tweens.add({
      targets: target,
      y: target.y - 20,
      duration: 800,
      yoyo: true,
      repeat: -1,
      ease: 'Sine.easeInOut'
    });
  }

  let jBodyKey = 'jesterBody1';
  let jHeadKey = 'jesterHead1';
  if (type === 'woodenShield') {
    jBodyKey = 'jesterBody2';
    jHeadKey = 'jesterHead2';
  } else if (type === 'explodingBarrel') {
    jBodyKey = 'jesterBody3';
    jHeadKey = 'jesterHead3';
  }
  if (target.isMoving) {
    jBodyKey = 'jesterBody4';
    jHeadKey = 'jesterHead4';
  }
  body.setTexture(jBodyKey);
  head.setTexture(jHeadKey);

  target.collected = false;
  target.jester = jester;
  targetGroup.add(target);

  scene.tweens.add({
    targets: [jester, target],
    x: targetX,
    duration: 1500,
    ease: 'Linear',
    onComplete: () => {
      scene.physics.world.enable(target);
      if (type === 'explodingBarrel') {
        // Include the fuse above the barrel in the hitbox
        target.body.setSize(30, 46);
        target.body.setOffset(-15, -26);
      } else {
        target.body.setCircle(20);
        target.body.setOffset(-20, -20);
        target.body.x = target.x - target.body.halfWidth;
        target.body.y = target.y - target.body.halfHeight;
      }
      target.body.setAllowGravity(false);
      target.body.setImmovable(true);
      if (FEATURES.birds && Phaser.Math.Between(1, 10) === 1) {
        scene.time.delayedCall(2000, () => spawnBird(scene));
      }
    },
    onUpdate: () => {
      if (target.body) {
        target.body.x = target.x - target.body.halfWidth;
        target.body.y = target.y - target.body.halfHeight;
      }
    }
  });
}

function addXP(scene, amount) {
  xp += amount;
  if (xp >= xpThreshold) {
    xp -= xpThreshold;
    level++;
    xpThreshold = Math.floor(xpThreshold * 1.15);
    onLevelUp(scene);
  }
  updateXPUI();
}

function updateXPUI() {
  xpText.setText(`Level ${level} - ${xp}/${xpThreshold} XP`);
  const maxWidth = 300;
  xpBarFill.displayWidth = maxWidth * (xp / xpThreshold);
}

function onLevelUp(scene) {
  const msg = scene.add.text(400, 300, 'LEVEL UP!', { font: '48px monospace', fill: '#ffff00' })
    .setOrigin(0.5)
    .setDepth(25);
  scene.cameras.main.flash(250, 255, 255, 255);
  scene.tweens.add({
    targets: msg,
    y: 250,
    alpha: 0,
    duration: 1000,
    onComplete: () => msg.destroy()
  });
}

function update(time, delta) {

  if (!gameStarted) return;

  if (this.dayNight) {
    this.dayNight.update(delta / 1000);
  }

  if (FEATURES.clouds && cloudLayerFar && cloudLayerNear) {
    cloudLayerFar.getChildren().forEach(cloud => {
      cloud.x -= 0.2;
      if (cloud.x < -cloud.width / 2) {
        cloud.x = config.width + cloud.width / 2;
        cloud.y = Phaser.Math.Between(20, CLOUD_AREA_HEIGHT);
        cloud.setAlpha(Phaser.Math.FloatBetween(0.6, 0.9));
        cloud.setScale(Phaser.Math.FloatBetween(0.8, 1.2));
      }
    });
    cloudLayerNear.getChildren().forEach(cloud => {
      cloud.x -= 0.4;
      if (cloud.x < -cloud.width / 2) {
        cloud.x = config.width + cloud.width / 2;
        cloud.y = Phaser.Math.Between(40, CLOUD_AREA_HEIGHT);
        cloud.setAlpha(Phaser.Math.FloatBetween(0.6, 0.9));
        cloud.setScale(Phaser.Math.FloatBetween(0.8, 1.2));
      }
    });
  }

  // Move cursor
  if (swingActive) {
    cursor.x += swingDirection * swingSpeed;
    if (cursor.x > 550 || cursor.x < 250) {
      swingDirection *= -1;
    }
  }

  // Apply extra gravity once heads start falling in the rain
  if (FEATURES.weather && currentWeather === 'rain' && bodyGroup) {
    bodyGroup.getChildren().forEach(obj => {
      if (obj.isHead && !obj.rainGravityApplied && obj.body.velocity.y > 0) {
        obj.body.setGravityY(300);
        obj.rainGravityApplied = true;
      }
    });
  }


  // Splash when heads hit the blood pool
  if (bloodPool && bloodEmitter && bodyGroup) {
    const surfaceY = bloodPool.y - bloodPool.displayHeight;
    bodyGroup.getChildren().forEach(obj => {
      if (obj.isHead && !obj.hasSplashed && obj.y + obj.displayHeight / 2 >= surfaceY) {
        obj.hasSplashed = true;
        const depth = Math.min(bloodPool.displayHeight, 100);
        const ratio = depth / 100;
        const qty = Math.floor(10 + 40 * ratio);
        const minSpeed = 150 + 50 * ratio;
        const maxSpeed = 250 + 50 * ratio;
        bloodEmitter.setSpeed({ min: minSpeed, max: maxSpeed });
        bloodEmitter.explode(qty, obj.x, surfaceY);
        bloodEmitter.setSpeed({ min: 150, max: 250 });
      }
    });
  }
}

class TravelScene extends Phaser.Scene {
  constructor() {
    super({ key: 'TravelScene' });
  }
  init(data) {
    this.city = data.city;
    this.days = Math.max(1, data.days);
    this.mainScene = data.mainScene;
  }
  create() {
    const keys = travelBackgrounds.map((_, i) => `background-travel${i + 1}`);
    let bgKey = Phaser.Utils.Array.GetRandom(keys);
    if (!this.textures.exists(bgKey)) bgKey = 'background';
    this.add.image(400, 300, 'backgroundSky').setDisplaySize(800, 600).setDepth(-5);
    this.add.image(400, 300, bgKey).setDisplaySize(800, 600).setDepth(-2);
    this.add.text(400, 40, `Travelling to ${this.city.name}`, { font: '32px serif', fill: '#ffff00' }).setOrigin(0.5);
    let d = currentDay;
    let m = currentMonth;
    const date = this.add.text(400, 80, `${d} ${months[m]}`, { font: '28px monospace', fill: '#ffffff' }).setOrigin(0.5);
    const pickWeather = () =>
      Math.random() < 0.5
        ? 'Clear'
        : Phaser.Utils.Array.GetRandom(['Rain', 'Wind', 'Fog']);
    let weather = pickWeather();

    // Simple particle emitters to visualize travel weather
    const rainEmitter = this.add.particles('raindrop').createEmitter({
      x: { min: 0, max: 800 },
      y: 0,
      lifespan: 800,
      speedY: { min: 400, max: 600 },
      quantity: 15,
      frequency: 100,
      on: false
    });
    const fogEmitter = this.add.particles('fog').createEmitter({
      x: { min: -50, max: 850 },
      y: { min: 300, max: 580 },
      lifespan: 6000,
      speedX: { min: -20, max: 20 },
      speedY: { min: -5, max: 5 },
      quantity: 6,
      alpha: { start: 0.8, end: 0.1 },
      on: false
    });
    const windEmitter = this.add.particles('leaf').createEmitter({
      lifespan: 4000,
      quantity: 10,
      frequency: 20,
      scale: { start: 1, end: 0 },
      rotate: { min: -180, max: 180 },
      on: false
    });

    // Parallax clouds that drift during travel
    if (FEATURES.clouds) {
      if (!this.textures.exists('cloud-small')) {
        const gfx = this.make.graphics({ x: 0, y: 0, add: false });
        gfx.fillStyle(0xdddddd, 0.6);
        gfx.fillEllipse(50, 45, 60, 20);
        gfx.fillStyle(0xffffff, 0.9);
        gfx.fillCircle(30, 30, 20);
        gfx.fillCircle(50, 20, 25);
        gfx.fillCircle(70, 30, 20);
        gfx.fillCircle(40, 40, 18);
        gfx.fillCircle(60, 40, 18);
        gfx.generateTexture('cloud-small', 100, 60);
        gfx.clear();
        gfx.fillStyle(0xdddddd, 0.6);
        gfx.fillEllipse(70, 45, 80, 25);
        gfx.fillStyle(0xffffff, 0.9);
        gfx.fillCircle(40, 30, 25);
        gfx.fillCircle(70, 20, 35);
        gfx.fillCircle(100, 30, 25);
        gfx.fillCircle(55, 45, 20);
        gfx.fillCircle(85, 45, 20);
        gfx.generateTexture('cloud-big', 140, 60);
        gfx.destroy();
      }
      this.travelCloudLayerFar = this.add.group();
      this.travelCloudLayerNear = this.add.group();
      for (let i = 0; i < 5; i++) {
        const cloud = this.add.image(
          Phaser.Math.Between(0, config.width),
          Phaser.Math.Between(20, CLOUD_AREA_HEIGHT),
          'cloud-small'
        );
        cloud.setDepth(-3);
        cloud.setTint(0x888888);
        cloud.setAlpha(Phaser.Math.FloatBetween(0.3, 0.5));
        cloud.setScale(Phaser.Math.FloatBetween(0.8, 1.2));
        this.travelCloudLayerFar.add(cloud);
      }
      for (let i = 0; i < 3; i++) {
        const cloud = this.add.image(
          Phaser.Math.Between(0, config.width),
          Phaser.Math.Between(40, CLOUD_AREA_HEIGHT),
          'cloud-big'
        );
        cloud.setDepth(-1);
        cloud.setAlpha(Phaser.Math.FloatBetween(0.6, 0.9));
        cloud.setScale(Phaser.Math.FloatBetween(0.8, 1.2));
        this.travelCloudLayerNear.add(cloud);
      }
    }

    // Parallax grass tufts that blow past during travel
    const grassG = this.add.graphics();
    grassG.fillStyle(0x2e8b57, 1);
    grassG.beginPath();
    grassG.moveTo(2, 8);
    grassG.lineTo(4, 0);
    grassG.lineTo(6, 8);
    grassG.lineTo(2, 8);
    grassG.moveTo(0, 8);
    grassG.lineTo(1, 3);
    grassG.lineTo(2, 8);
    grassG.moveTo(6, 8);
    grassG.lineTo(7, 3);
    grassG.lineTo(8, 8);
    grassG.fillPath();
    grassG.generateTexture('grassTuft', 8, 8);
    grassG.destroy();

    const grassFarParts = this.add.particles('grassTuft').setDepth(0);
    grassFarParts.createEmitter({
      x: { min: 0, max: 800 },
      y: { min: 520, max: 560 },
      lifespan: 5000,
      speedX: { min: -80, max: -40 },
      speedY: { min: -20, max: 20 },
      quantity: 1,
      frequency: 300,
      alpha: { start: 1, end: 0 },
      scale: { start: 0.6, end: 0.2 }
    });
    const grassNearParts = this.add.particles('grassTuft').setDepth(2);
    grassNearParts.createEmitter({
      x: { min: 0, max: 800 },
      y: { min: 570, max: 600 },
      lifespan: 3000,
      speedX: { min: -200, max: -120 },
      speedY: { min: -30, max: 30 },
      quantity: 1,
      frequency: 150,
      alpha: { start: 1, end: 0 },
      scale: { start: 1.5, end: 0.7 }
    });
    const setWeather = (w) => {
      rainEmitter.stop();
      fogEmitter.stop();
      windEmitter.stop();
      if (w === 'Rain') {
        rainEmitter.start();
      } else if (w === 'Fog') {
        fogEmitter.start();
      } else if (w === 'Wind') {
        windEmitter.setSpeedX({ min: -50, max: 50 });
        windEmitter.setSpeedY({ min: 0, max: 0 });
        windEmitter.start();
      }
    };
    setWeather(weather);
    const exec = this.add.container(-100, 460).setDepth(1);
    const weapon = this.add.image(0, -20, `weapons${player.weaponLevel}`)
      .setOrigin(0.5)
      .setAngle(135);
    const body = this.add.image(0, 50, 'executionerBody').setOrigin(0.5, 1);
    const head = this.add.image(0, -30, 'executionerHead').setOrigin(0.5);
    exec.add([weapon, body, head]);
    this.add.existing(exec);

    // Storage upgrade image trails 50px lower behind the executioner
    const upgrade = this.add
      .image(-250, 510, `storage${player.storageLevel}`)
      .setOrigin(0.5, 1)
      .setDepth(0);

    const duration = this.days * 700;
    this.tweens.add({ targets: exec, x: 900, duration, ease: 'Linear' });
    this.tweens.add({ targets: upgrade, x: 750, duration, ease: 'Linear' });
    this.time.addEvent({
      delay: duration / this.days,
      repeat: this.days - 1,
      callback: () => {
        d++;
        if (d > 30) { d = 1; m = (m + 1) % months.length; }
        date.setText(`${d} ${months[m]}`);
        if (Math.random() < 0.5) {
          weather = pickWeather();
          setWeather(weather);
        }
      }
    });

    this.time.delayedCall(duration, () => this.finish());
  }
  update() {
    if (FEATURES.clouds && this.travelCloudLayerFar && this.travelCloudLayerNear) {
      this.travelCloudLayerFar.getChildren().forEach(cloud => {
        cloud.x -= 0.2;
        if (cloud.x < -cloud.width / 2) {
          cloud.x = config.width + cloud.width / 2;
          cloud.y = Phaser.Math.Between(20, CLOUD_AREA_HEIGHT);
          cloud.setAlpha(Phaser.Math.FloatBetween(0.6, 0.9));
          cloud.setScale(Phaser.Math.FloatBetween(0.8, 1.2));
        }
      });
      this.travelCloudLayerNear.getChildren().forEach(cloud => {
        cloud.x -= 0.4;
        if (cloud.x < -cloud.width / 2) {
          cloud.x = config.width + cloud.width / 2;
          cloud.y = Phaser.Math.Between(40, CLOUD_AREA_HEIGHT);
          cloud.setAlpha(Phaser.Math.FloatBetween(0.6, 0.9));
          cloud.setScale(Phaser.Math.FloatBetween(0.8, 1.2));
        }
      });
    }
  }
  finish() {
    advanceDays(this.days);
    selectCity(this.mainScene, this.city);
    this.scene.stop();
    this.mainScene.scene.resume();
  }
}

game.scene.add('TravelScene', TravelScene, false);

// Inject styled gameplay instructions beneath the Phaser canvas once the page loads
window.addEventListener('load', () => {
  const instructions = document.createElement('div');
  instructions.id = 'game-instructions';
  instructions.style.padding = '30px';
  instructions.style.fontFamily = 'Georgia, serif';
  instructions.style.maxWidth = '800px';
  instructions.style.margin = '0 auto';
  instructions.style.textAlign = 'center';

  instructions.innerHTML = `
    <h1>⚔️ Welcome to <em>Chop To It</em> ⚔️</h1>
    <p><strong>This game is a work-in-progress demo — completely made by AI.</strong></p>

    <h2>🕹️ Instructions</h2>
    <ul style="list-style: none; padding-left: 0;">
      <li>🔪 Click in the centre of the meter to determine if you <strong>hit</strong> or <strong>miss</strong>.</li>
      <li>🎯 The second click sets the <strong>direction</strong> your customer’s head flies.</li>
      <li>💥 The third click determines the <strong>power</strong> of your strike.</li>
      <li>🎯 Aim for jesters and flying targets to maximise your rewards.</li>
    </ul>

    <h2>📦 Features</h2>
    <ul style="list-style: none; padding-left: 0;">
      <li>🌦️ Weather alters gravity and shot physics.</li>
      <li>🔥 Hit streaks increase gold and spawn rarer characters.</li>
      <li>🚚 Buy storage upgrades and travel to new cities.</li>
      <li>📉 Buy low, sell high — master the medieval market.</li>
    </ul>

    <h2>🏆 Your Goal</h2>
    <p><em>Earn <strong>1,000,001 gold</strong> within one year.</em></p>
    <p>Only the most brutal and brilliant executioner shall rise to glory.</p>
  `;

  document.body.appendChild(instructions);
});
</script>

</body>
</html>
