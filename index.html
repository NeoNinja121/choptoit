<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Chop To It!</title>
  <link rel="icon" type="image/png" href="favicon256.png">
  <style>
    html, body {
      margin: 0;
      background: #000;
    }
    canvas {
      display: block;
      margin: auto;
      background: #000;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>
</head>
<body>

<script>
const config = {
  type: Phaser.AUTO,
  width: 800,
  height: 600,
  backgroundColor: '#000',
  physics: { default: 'arcade', arcade: { gravity: { y: 400 } } },
  scene: {
    preload,
    create,
    update
  }
};

const game = new Phaser.Game(config);

let gold = 0;
let goldText;
let fame = 0;
let fameText;
let swingActive = false;
let cursor;
let redZone;
let yellowZone;
let greenZone;
let swingBar;
let bloodPool;
let bloodEmitter;
let dripEmitter;
let headEmitter;
let missText;
let missStreak = 0;
const VERSION = 'v1.83';
let versionText;
let inputEnabled = true;
let killCount = 0;
let killText;
let killStreak = 0;
let killStreakText;
let streakMultiplierText;
let xp = 0;
let level = 1;
let xpThreshold = 10;
let xpText;
let xpBar;
let xpBarFill;
let baseSwingSpeed = 5;
let speedMultiplier = 1;
let shopButton;
let shopContainer;
let shopOverlay;
let travelButton;
let travelContainer;
let travelOverlay;
let locationText;
let currentCity = 'York';
let backgroundRect;
let stage;
let travelList;
let startContainer;
let logoContainer;
let hideMeterEvent;
let headResetEvent;
let neckPumpEvent;
let prisoner;
let prisonerBody;
let prisonerHead;
let prisonerFace;
let leftEscort;
let rightEscort;
let aimArrow;
let arrowTween;
let arrowPowerTween;
let slashTween;
let awaitingAngle = false;
let awaitingPower = false;
let selectedAngle = 0;
let pendingBlood = 0;
let pendingSpawnSide = null;
let prisonerClass;
let swingSpeed = 5;
let executioner;
let executionerIntro = true;

// Medieval calendar variables
const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
let currentDay = 1;
let currentMonth = 0;
let dateText;

// Daily trading modifiers
let dailyBuySpecial = null;
let dailySellSpecial = null;

// Market chatter
const marketQuotes = [
  "Oooh I'm desperate for turnips to help with me piles!",
  "A pox upon high prices, I say!",
  "Bring forth more mead, my throat be parched!",
  "Rumour says the plague's back, stock up on salt!",
  "I swapped me cow for beans once, ne'er again!"
];
let currentQuote = '';
let marketChatterText;

// Group to hold fallen bodies that pile up at the bottom
let bodyGroup;
let targetGroup;

// Inventory for trading market items
let inventory = {};
// Multiplier applied to fame gains
let fameMultiplier = 1;

const baseSizes = { red: 60, yellow: 40, green: 20 };
let zoneMods = { red: 0, yellow: 0, green: 0 };

const classes = [
  { name: 'Peasant', color: 0x777777, speed: 5, weight: 50 },
  { name: 'Merchant', color: 0x996633, speed: 6, weight: 25 },
  { name: 'Knight', color: 0x0033cc, speed: 7, weight: 15 },
  { name: 'Clergy', color: 0x800080, speed: 8, weight: 7 },
  { name: 'Lord', color: 0xffff00, speed: 9, weight: 3 }
];

const weapons = [
  {
    name: 'Excalibur',
    type: 'Sword',
    cost: 50,
    desc: 'Legendary blade of kings, widens red zone for precise justice.',
    effects: { red: 20 }
  },
  {
    name: 'Gungnir',
    type: 'Spear',
    cost: 100,
    desc: "Odin's unstoppable spear expands yellow zone for deadlier punishment strikes.",
    effects: { red: 10, yellow: 20 }
  },
  {
    name: 'Mjolnir',
    type: 'Hammer',
    cost: 200,
    desc: "Thunder god's hammer broadens green zone to shatter stubborn necks.",
    effects: { red: 10, yellow: 10, green: 10 }
  },
  {
    name: 'Masamune',
    type: 'Katana',
    cost: 400,
    desc: "Famed smith's katana enlarges all zones ensuring flawless beheadings everytime.",
    effects: { red: 10, yellow: 10, green: 10 }
  }
];

// Upgrades that boost fame gain or provide passive bonuses
const gameUpgrades = [
  { name: 'Grand Stage', cost: 150, fameReq: 0, desc: 'Bigger stage draws crowds. Fame x1.1', mult: 1.1 },
  { name: 'Traveling Caravan', cost: 300, fameReq: 3, desc: 'Musicians and banners. Fame x1.2', mult: 1.2 },
  { name: 'Royal Horse', cost: 600, fameReq: 6, desc: 'Arrive in style. Fame x1.3', mult: 1.3 }
];

// Items available in the trading market
const marketItems = [
  { name: 'Potatoes', buy: 2, sell: 1, fameReq: 0 },
  { name: 'Mead', buy: 5, sell: 3, fameReq: 0 },
  { name: 'Salt', buy: 8, sell: 4, fameReq: 3 },
  { name: 'Silver Cup', buy: 20, sell: 10, fameReq: 5 },
  { name: 'Gemstones', buy: 50, sell: 25, fameReq: 8 }
];

// Places the player can visit
const cities = [
  { name: 'York', desc: 'Historic northern city.', fameReq: 0, bgColor: 0x2d2d2d,
    modifiers: { Potatoes: { buy: 0.9, sell: 1.1 } } },
  { name: 'Canterbury', desc: 'Seat of the Archbishop.', fameReq: 1, bgColor: 0x2d2d34,
    modifiers: { Mead: { buy: 0.9, sell: 1.1 } } },
  { name: 'London', desc: 'Bustling capital of the realm.', fameReq: 2, bgColor: 0x34342d,
    modifiers: { Salt: { buy: 0.9, sell: 1.1 } } },
  { name: 'Bristol', desc: 'Busy trading port.', fameReq: 3, bgColor: 0x2d342d,
    modifiers: { 'Silver Cup': { buy: 0.85, sell: 1.15 } } },
  { name: 'Norwich', desc: 'Town of fine artisans.', fameReq: 4, bgColor: 0x342d2d,
    modifiers: { Gemstones: { buy: 0.8, sell: 1.2 } } },
  { name: 'Winchester', desc: 'Former royal seat.', fameReq: 5, bgColor: 0x2d3434,
    modifiers: { Mead: { buy: 0.9, sell: 1.1 } } }
];

// Format the current calendar date
function getDateString() {
  return `${currentDay} ${months[currentMonth]}`;
}

// Apply random price changes, city modifiers and daily specials
function refreshMarketPrices() {
  const city = cities.find(c => c.name === currentCity);
  marketItems.forEach(m => {
    let buyMult = Phaser.Math.FloatBetween(0.9, 1.1);
    let sellMult = Phaser.Math.FloatBetween(0.9, 1.1);
    if (city && city.modifiers && city.modifiers[m.name]) {
      const mod = city.modifiers[m.name];
      if (mod.buy) buyMult *= mod.buy;
      if (mod.sell) sellMult *= mod.sell;
    }
    if (m.name === dailyBuySpecial) buyMult *= 0.75;
    if (m.name === dailySellSpecial) sellMult *= 1.25;
    m.currentBuy = Math.max(1, Math.round(m.buy * buyMult));
    m.currentSell = Math.max(1, Math.round(m.sell * sellMult));
  });
}

// Display the day's market chatter
function updateMarketChatter() {
  if (marketChatterText) {
    marketChatterText.setText(`"${currentQuote}"`);
  }
}

// Refresh prices, specials and chatter at the start of a new day
function dailyMarketUpdate() {
  dailyBuySpecial = Phaser.Utils.Array.GetRandom(marketItems).name;
  do {
    dailySellSpecial = Phaser.Utils.Array.GetRandom(marketItems).name;
  } while (dailySellSpecial === dailyBuySpecial);
  currentQuote = Phaser.Utils.Array.GetRandom(marketQuotes);
  refreshMarketPrices();
  updateMarketUI();
  updateMarketChatter();
}

// Advance the calendar when travelling to a new city
function advanceDay() {
  currentDay++;
  if (currentDay > 30) {
    currentDay = 1;
    currentMonth = (currentMonth + 1) % months.length;
  }
  if (dateText) dateText.setText(getDateString());
  dailyMarketUpdate();
}

function pickClass() {
  const total = classes.reduce((s, c) => s + c.weight, 0);
  let r = Phaser.Math.Between(1, total);
  for (const c of classes) {
    r -= c.weight;
    if (r <= 0) return c;
  }
  return classes[0];
}

function preload() {
  this.load.image('logo', 'logo.png');
  this.load.image('shop', 'shop.png');
  this.load.image('platform', 'platform.png');
  this.load.image('executionerHead', 'executionerhead.png');
  this.load.image('executionerBody', 'executionerbody.png');
  this.load.image('escortHead', 'escorthead.png');
  this.load.image('escortBody', 'escortbody.png');
  this.load.image('signTravel', 'sign_travel.png');
  this.load.image('background', 'background.png');
  this.load.image('prisonerHeadImg', 'prisonerhead.png');
  this.load.image('prisonerBodyImg', 'prisonerbody.png');
}

function create() {
  const scene = this;

  // Background and stage art
  const startCity = cities.find(c => c.name === currentCity);
  backgroundRect = scene.add.image(400, 300, 'background');
  backgroundRect.setDisplaySize(800, 600);
  backgroundRect.setTint(startCity.bgColor);
  stage = scene.add.image(400, 520, 'platform');

  // Executioner, starts off-screen and walks in on first spawn
  // Place him behind the prisoner but in front of the background
  executioner = scene.add.container(400, 460).setDepth(0.5);
  const execBody = scene.add.image(0, 50, 'executionerBody')
    .setOrigin(0.5, 1);
  const execHead = scene.add.image(0, -30, 'executionerHead')
    .setOrigin(0.5, 0.5);
  executioner.add([execBody, execHead]);
  executioner.setVisible(false);

  // Condemned figure with separate head and body
  prisoner = scene.add.container(400, 460).setDepth(1);
  // Pivot the body around the feet so it can topple realistically
  // Position it so the top still aligns with the neck
  prisonerBody = scene.add.image(0, 50, 'prisonerBodyImg')
    .setOrigin(0.5, 1);
  prisonerHead = scene.add.container(0, -20);
  const headSprite = scene.add.image(0, 0, 'prisonerHeadImg').setOrigin(0.5);
  prisonerFace = scene.add.text(0, 0, ':(', { font: '16px monospace', fill: '#000' }).setOrigin(0.5);
  prisonerHead.add([headSprite, prisonerFace]);
  // Aim arrow points upward for angle selection
  // Larger arrow for angle and power selection
  aimArrow = scene.add.triangle(0, -25, 0, -40, -12, 0, 12, 0, 0xffff00)
    .setOrigin(0.5, 1)
    .setVisible(false);
  prisonerHead.add(aimArrow);
  prisoner.add([prisonerBody, prisonerHead]);
  prisoner.setVisible(false);

  // Escort guards
  leftEscort = scene.add.container(0, 0);
  const leftBody = scene.add.image(0, 50, 'escortBody')
    .setOrigin(0.5, 1);
  const leftHead = scene.add.image(0, -20, 'escortHead')
    .setOrigin(0.5, 0.5);
  leftEscort.add([leftBody, leftHead]);
  rightEscort = scene.add.container(0, 0);
  const rightBody = scene.add.image(0, 50, 'escortBody')
    .setOrigin(0.5, 1);
  const rightHead = scene.add.image(0, -20, 'escortHead')
    .setOrigin(0.5, 0.5);
  rightEscort.add([rightBody, rightHead]);
  leftEscort.setVisible(false);
  rightEscort.setVisible(false);

  // Gold text
  goldText = scene.add.text(16, 16, 'Gold: 0', { font: '20px monospace', fill: '#ffff88' });
  fameText = scene.add.text(16, 40, 'Fame: 0', { font: '20px monospace', fill: '#88ffff' });
  missText = scene.add.text(16, 64, 'Misses: 0', { font: '20px monospace', fill: '#ff8888' });
  killText = scene.add.text(16, 88, 'Kills: 0', { font: '20px monospace', fill: '#ffffff' });
  killStreakText = scene.add.text(16, 112, 'Streak: 0', { font: '20px monospace', fill: '#ffffff' });
  locationText = scene.add.text(400, 16, `Current Location: ${currentCity}`, { font: '20px monospace', fill: '#ffffff' })
    .setOrigin(0.5, 0);
  dateText = scene.add.text(400, 112, getDateString(), { font: '20px monospace', fill: '#ffffff' })
    .setOrigin(0.5, 0);
  xpText = scene.add.text(400, 136, 'Level 1 - 0/10 XP', { font: '20px monospace', fill: '#88ff88' })
    .setOrigin(0.5);
  xpBar = scene.add.rectangle(400, 160, 300, 12, 0x444444).setOrigin(0.5, 0);
  xpBarFill = scene.add.rectangle(250, 160, 0, 12, 0x00ff00).setOrigin(0, 0);
  updateXPUI();
  streakMultiplierText = scene.add.text(400, 40, 'x0', { font: '48px monospace', fill: '#ff0000' })
    .setOrigin(0.5)
    .setDepth(2);
  versionText = scene.add.text(790, 590, VERSION, { font: '14px monospace', fill: '#ffffff' })
    .setOrigin(1, 1)
    .setDepth(11);

  // Logo drop animation before showing the start screen
  // Ensure the logo appears above the start screen background
  logoContainer = scene.add.container(400, -200).setDepth(13);
  const rope = scene.add.rectangle(0, 0, 12, 125, 0xffffff)
    .setOrigin(0.5, 0);
  const logo = scene.add.image(0, 125, 'logo')
    .setOrigin(513 / 1024, 127 / 1024)
    .setScale(0.5);
  logoContainer.add([rope, logo]);
  scene.tweens.add({
    targets: logoContainer,
    y: 0,
    ease: 'Bounce',
    duration: 600,
    onComplete: () => {
      scene.tweens.timeline({
        targets: logoContainer,
        tweens: [
          { angle: { from: -15, to: 15 }, duration: 300, yoyo: true, ease: 'Sine.easeInOut' },
          { angle: { from: -10, to: 10 }, duration: 400, yoyo: true, ease: 'Sine.easeInOut' },
          { angle: { from: -5, to: 5 }, duration: 500, yoyo: true, ease: 'Sine.easeInOut' },
          { angle: 0, duration: 600, ease: 'Sine.easeInOut' }
        ]
      });
    }
  });

  // Start screen
  startContainer = scene.add.container(0, 0).setDepth(12);
  const startBg = scene.add.rectangle(400, 300, 800, 600, 0x000000, 1)
    .setDepth(10)
    .setInteractive();
  const startText = scene.add.text(400, 560, '[ CLICK TO PLAY ]', { font: '32px monospace', fill: '#ffffff' })
    .setOrigin(0.5)
    .setDepth(10)
    .setVisible(false)
    .setInteractive();

  function beginGame() {
    startContainer.setVisible(false);
    logoContainer.setVisible(false);
    if (executionerIntro) {
      introExecutioner(scene, () => spawnPrisoner(scene, false));
    } else {
      spawnPrisoner(scene, false);
    }
  }

  startBg.on('pointerdown', beginGame);
  startText.on('pointerdown', beginGame);
  startContainer.add([startBg, startText]);
  startContainer.setVisible(true);

  scene.time.delayedCall(3000, () => {
    startText.setVisible(true);
  });

  // Swing meter base
  const meterY = 550;
  swingBar = scene.add.rectangle(400, meterY, 300, 20, 0x333333).setVisible(false);
  redZone = scene.add.rectangle(400, meterY, baseSizes.red, 20, 0xff0000).setVisible(false);
  yellowZone = scene.add.rectangle(400, meterY, baseSizes.yellow, 20, 0xffff00).setVisible(false);
  greenZone = scene.add.rectangle(400, meterY, baseSizes.green, 20, 0x00ff00).setVisible(false);
  cursor = scene.add.rectangle(250, meterY, 10, 20, 0xffffff).setVisible(false);

  // Blood pool
  bloodPool = scene.add.rectangle(400, 500, 40, 10, 0x770000)
    .setOrigin(0.5, 0)
    .setVisible(false)
    .setDepth(0.6);

  // Blood particle emitter
  const g = scene.add.graphics();
  g.fillStyle(0xff0000, 1);
  g.fillCircle(2, 2, 2);
  g.generateTexture('blood', 4, 4);
  g.destroy();
  const particles = scene.add.particles('blood').setDepth(1);
  bloodEmitter = particles.createEmitter({
    speed: { min: 150, max: 250 },
    angle: { min: 260, max: 280 }, // shoot upward like a fountain
    gravityY: 400,
    lifespan: 800,
    scale: { start: 1, end: 0 },
    quantity: 0,
    on: false
  });
  headEmitter = particles.createEmitter({
    speed: { min: 180, max: 280 },
    angle: { min: 80, max: 100 }, // downward from flying head
    gravityY: 400,
    lifespan: 1000,
    frequency: 20,
    scale: { start: 1, end: 0 },
    quantity: 0,
    on: false
  });
  dripEmitter = particles.createEmitter({
    speed: { min: 20, max: 40 },
    angle: 90,
    gravityY: 300,
    lifespan: 1000,
    scale: { start: 0.5, end: 0 },
    quantity: 0,
    on: false
  });

  // Physics group to accumulate fallen bodies
  bodyGroup = scene.physics.add.group();
  // Targets should remain stationary until hit
  targetGroup = scene.physics.add.group({
    allowGravity: false,
    immovable: true
  });
  scene.physics.add.overlap(prisonerHead, targetGroup, (head, target) => {
    if (target.collected) return;
    target.collected = true;
    gainFame(scene, target);
    target.body.setAllowGravity(true);
    target.body.setImmovable(false);
  });
  // Enable collisions between bodies so they pile up
  scene.physics.add.collider(bodyGroup, bodyGroup);
  // Stop corpses completely after two bounces
  scene.physics.world.on('worldbounds', (body, up, down) => {
    const obj = body.gameObject;
    if (!obj || !obj.isCorpse) return;
    if (down) {
      obj.bounceCount = (obj.bounceCount || 0) + 1;
      if (obj.bounceCount >= 2) {
        // Lay the corpse on its side most of the time
        if (Math.random() < 0.9) {
          const sign = Math.random() < 0.5 ? -1 : 1;
          obj.setRotation(sign * Phaser.Math.DegToRad(90));
        }

        body.setBounce(0);
        body.setVelocity(0, 0);
        body.setAngularVelocity(0);
        body.setAllowGravity(false);
        body.setImmovable(true);
        body.moves = false;

        // Disable physics so the frozen body no longer collides
        obj.scene.physics.world.disable(obj);
      }
    }
  });

  scene.time.addEvent({
    delay: 400,
    loop: true,
    callback: () => {
      const half = bloodPool.displayWidth / 2;
      const x = Phaser.Math.Between(bloodPool.x - half, bloodPool.x + half);
      dripEmitter.emitParticleAt(x, bloodPool.y + bloodPool.displayHeight, 1);
    }
  });

  // Shop button
  // Move the shop button slightly right to make room for the travel sign
  shopButton = scene.add.image(800, 0, 'shop')
    .setOrigin(1, 0)
    .setDisplaySize(107, 71)
    .setInteractive()
    .on('pointerdown', () => {
      toggleShop(scene);
    });

  // Travel button
  travelButton = scene.add.image(680, 0, 'signTravel')
    .setOrigin(1, 0)
    .setDisplaySize(107, 71)
    .setInteractive()
    .on('pointerdown', () => { toggleTravel(scene); });

  // Travel container and overlay
  travelOverlay = scene.add.rectangle(400, 300, 800, 600, 0x000000, 0.6)
    .setVisible(false)
    .setDepth(30);
  travelContainer = scene.add.container(100, 100).setVisible(false).setDepth(31);
  const travelBg = scene.add.rectangle(0, 0, 600, 380, 0x222222, 1).setOrigin(0, 0);
  travelBg.setStrokeStyle(2, 0xffffff);
  travelContainer.add(travelBg);
  travelList = scene.add.container(0, 40);
  travelContainer.add(travelList);
  let cityY = 0;
  cities.forEach(city => {
    const title = scene.add.text(10, cityY, '', { font: '18px monospace', fill: '#ffffaa', wordWrap: { width: 420 } });
    const btn = scene.add.text(450, cityY, '[Go]', { font: '18px monospace', fill: '#00ff00' })
      .setInteractive()
      .on('pointerdown', () => { selectCity(scene, city); });
    travelList.add([title, btn]);
    city.ui = { title, btn };
    cityY += 60;
  });
  const travelClose = scene.add.text(560, 10, '[X]', { font: '18px monospace', fill: '#ffffff' })
    .setInteractive()
    .on('pointerdown', () => { toggleTravel(scene); });
  travelContainer.add(travelClose);
  updateTravelUI(scene);

  // Shop container and overlay
  shopOverlay = scene.add.rectangle(400, 300, 800, 600, 0x000000, 0.6)
    .setVisible(false)
    .setDepth(30);
  shopContainer = scene.add.container(100, 100).setVisible(false).setDepth(31);
  const shopBg = scene.add.rectangle(0, 0, 600, 380, 0x222222, 1).setOrigin(0, 0);
  shopBg.setStrokeStyle(2, 0xffffff);
  shopContainer.add(shopBg);

  // Tab buttons
  const weaponTab = scene.add.text(20, 10, 'Weapon Upgrades', { font: '18px monospace', fill: '#ffff00' })
    .setInteractive()
    .on('pointerdown', () => showShopTab(scene, 'weapons'));
  const upgradeTab = scene.add.text(240, 10, 'Game Upgrades', { font: '18px monospace', fill: '#ffffff' })
    .setInteractive()
    .on('pointerdown', () => showShopTab(scene, 'upgrades'));
  const marketTab = scene.add.text(420, 10, 'Trading Market', { font: '18px monospace', fill: '#ffffff' })
    .setInteractive()
    .on('pointerdown', () => showShopTab(scene, 'market'));
  shopContainer.add([weaponTab, upgradeTab, marketTab]);

  // Containers for each tab's contents
  const weaponList = scene.add.container(0, 40);
  const upgradeList = scene.add.container(0, 40).setVisible(false);
  const marketList = scene.add.container(0, 40).setVisible(false);
  shopContainer.add([weaponList, upgradeList, marketList]);

  // Weapon upgrade items
  let itemY = 0;
  weapons.forEach((w, idx) => {
    const title = scene.add.text(10, itemY, `${w.name} - ${w.type} - ${w.cost}g`, { font: '18px monospace', fill: '#ffffaa' });
    const desc = scene.add.text(20, itemY + 20, w.desc, { font: '14px monospace', fill: '#ffffff', wordWrap: { width: 420 } });
    const buy = scene.add.text(450, itemY, '[Buy]', { font: '18px monospace', fill: '#00ff00' })
      .setInteractive()
      .on('pointerdown', () => { buyWeapon(scene, idx); });
    weaponList.add([title, desc, buy]);
    w.ui = { buy };
    itemY += 70;
  });

  // Game upgrade items
  itemY = 0;
  gameUpgrades.forEach((g, idx) => {
    const title = scene.add.text(10, itemY, `${g.name} - ${g.cost}g`, { font: '18px monospace', fill: '#ffffaa' });
    const desc = scene.add.text(20, itemY + 20, g.desc, { font: '14px monospace', fill: '#ffffff', wordWrap: { width: 420 } });
    const buy = scene.add.text(450, itemY, '[Buy]', { font: '18px monospace', fill: '#00ff00' })
      .setInteractive()
      .on('pointerdown', () => { buyUpgrade(scene, idx); });
    upgradeList.add([title, desc, buy]);
    g.ui = { buy };
    itemY += 70;
  });

  // Market items
  itemY = 0;
  marketItems.forEach((m, idx) => {
    const line = scene.add.text(10, itemY, '', { font: '18px monospace', fill: '#ffffaa' });
    const buyBtn = scene.add.text(420, itemY, '[Buy]', { font: '18px monospace', fill: '#00ff00' })
      .setInteractive()
      .on('pointerdown', () => { buyMarketItem(scene, idx); });
    const sellBtn = scene.add.text(520, itemY, '[Sell]', { font: '18px monospace', fill: '#00ff00' })
      .setInteractive()
      .on('pointerdown', () => { sellMarketItem(scene, idx); });
    marketList.add([line, buyBtn, sellBtn]);
    m.ui = { line };
    itemY += 30;
  });
  marketChatterText = scene.add.text(10, itemY + 10, '', {
    font: '16px monospace',
    fill: '#ffaaaa',
    wordWrap: { width: 580 }
  });
  marketList.add(marketChatterText);

  const closeBtn = scene.add.text(560, 10, '[X]', { font: '18px monospace', fill: '#ffffff' })
    .setInteractive()
    .on('pointerdown', () => { toggleShop(scene); });
  shopContainer.add(closeBtn);

  // Store references for later use
  scene.weaponTab = weaponTab;
  scene.upgradeTab = upgradeTab;
  scene.marketTab = marketTab;
  scene.weaponList = weaponList;
  scene.upgradeList = upgradeList;
  scene.marketList = marketList;

  // Set up first day's prices and gossip
  dailyMarketUpdate();

  // Default to weapon tab
  showShopTab(scene, 'weapons');

  // Text popup
  scene.popupText = scene.add.text(400, 250, '', { font: '24px serif', fill: '#ffffff' })
    .setOrigin(0.5)
    .setVisible(false);

  // Input key for timing
  scene.input.keyboard.on('keydown-SPACE', () => {
    if (swingActive && inputEnabled) endSwing(scene);
  });
  scene.input.on('pointerdown', () => {
    if (awaitingAngle) {
      chooseAngle(scene);
    } else if (awaitingPower) {
      choosePower(scene);
    } else if (swingActive && inputEnabled) {
      endSwing(scene);
    }
  });

  // Targets spawn with each prisoner
}

let swingDirection = 1;

function toggleShop(scene) {
  const visible = !shopContainer.visible;
  shopOverlay.setVisible(visible);
  shopContainer.setVisible(visible);
  if (visible) {
    showShopTab(scene, scene.activeTab || 'weapons');
    if (hideMeterEvent) {
      hideMeterEvent.remove(false);
      hideMeterEvent = null;
    }
    swingActive = false;
    inputEnabled = false;
    cursor.setVisible(false);
    scene.physics.world.pause();
    scene.tweens.pauseAll();
    scene.time.paused = true;
  } else {
    scene.physics.world.resume();
    scene.tweens.resumeAll();
    scene.time.paused = false;
    startSwingMeter(scene);
  }
}

function buyWeapon(scene, index) {
  const w = weapons[index];
  if (w.purchased) return;
  if (gold >= w.cost) {
    gold -= w.cost;
    goldText.setText(`Gold: ${gold}`);
    zoneMods.red += w.effects.red || 0;
    zoneMods.yellow += w.effects.yellow || 0;
    zoneMods.green += w.effects.green || 0;
    updateZones();
    w.purchased = true;
    if (w.ui && w.ui.buy) {
      w.ui.buy.setText('Bought').disableInteractive();
    }
  }
}

function updateZones() {
  redZone.displayWidth = baseSizes.red + zoneMods.red;
  yellowZone.displayWidth = baseSizes.yellow + zoneMods.yellow;
  greenZone.displayWidth = baseSizes.green + zoneMods.green;
}

// Switch between shop tabs and update highlights
function showShopTab(scene, tab) {
  scene.activeTab = tab;
  scene.weaponList.setVisible(tab === 'weapons');
  scene.upgradeList.setVisible(tab === 'upgrades');
  scene.marketList.setVisible(tab === 'market');
  scene.weaponTab.setFill(tab === 'weapons' ? '#ffff00' : '#ffffff');
  scene.upgradeTab.setFill(tab === 'upgrades' ? '#ffff00' : '#ffffff');
  scene.marketTab.setFill(tab === 'market' ? '#ffff00' : '#ffffff');
  if (tab === 'market') {
    updateMarketUI();
    updateMarketChatter();
  }
}

// Purchase a fame boosting upgrade
function buyUpgrade(scene, index) {
  const u = gameUpgrades[index];
  if (u.purchased || fame < u.fameReq) return;
  if (gold >= u.cost) {
    gold -= u.cost;
    goldText.setText(`Gold: ${gold}`);
    fameMultiplier = u.mult;
    u.purchased = true;
    if (u.ui && u.ui.buy) {
      u.ui.buy.setText('Bought').disableInteractive();
    }
  }
}

// Buying from the trading market
function buyMarketItem(scene, index) {
  const item = marketItems[index];
  if (fame < item.fameReq) return;
  if (gold >= item.currentBuy) {
    gold -= item.currentBuy;
    goldText.setText(`Gold: ${gold}`);
    inventory[item.name] = (inventory[item.name] || 0) + 1;
    updateMarketUI();
  }
}

// Selling items the player owns
function sellMarketItem(scene, index) {
  const item = marketItems[index];
  if ((inventory[item.name] || 0) > 0) {
    inventory[item.name] -= 1;
    gold += item.currentSell;
    goldText.setText(`Gold: ${gold}`);
    updateMarketUI();
  }
}


// Update market text lines with prices and inventory
function updateMarketUI() {
  marketItems.forEach(m => {
    if (!m.ui) return;
    const qty = inventory[m.name] || 0;
    const locked = fame < m.fameReq;
    const text = locked
      ? `${m.name} - Locked (Fame ${m.fameReq})`
      : `${m.name} - Buy:${m.currentBuy}g Sell:${m.currentSell}g Qty:${qty}`;
    m.ui.line.setText(text);
  });
}

function updateTravelUI(scene) {
  cities.forEach(c => {
    if (!c.ui) return;
    const locked = c.fameReq && fame < c.fameReq;
    const desc = locked ? `Locked (Fame ${c.fameReq})` : c.desc;
    c.ui.title.setText(`${c.name} - ${desc}`);
    const label = c.name === currentCity ? '[Here]' : locked ? '[Locked]' : '[Go]';
    c.ui.btn.setText(label);
  });
}

function toggleTravel(scene) {
  const visible = !travelContainer.visible;
  travelOverlay.setVisible(visible);
  travelContainer.setVisible(visible);
  if (visible) {
    updateTravelUI(scene);
    if (hideMeterEvent) {
      hideMeterEvent.remove(false);
      hideMeterEvent = null;
    }
    swingActive = false;
    inputEnabled = false;
    cursor.setVisible(false);
    scene.physics.world.pause();
    scene.tweens.pauseAll();
    scene.time.paused = true;
  } else {
    scene.physics.world.resume();
    scene.tweens.resumeAll();
    scene.time.paused = false;
    startSwingMeter(scene);
  }
}

function selectCity(scene, city) {
  if (city.fameReq && fame < city.fameReq) return;
  if (city.name === currentCity) return;
  currentCity = city.name;
  backgroundRect.setTint(city.bgColor);
  locationText.setText(`Current Location: ${currentCity}`);
  advanceDay();
  scene.cameras.main.fadeOut(250, 0, 0, 0);
  scene.time.delayedCall(250, () => {
    scene.cameras.main.fadeIn(250, 0, 0, 0);
  });
  toggleTravel(scene);
}

function savePrisoner(scene) {
  prisonerFace.setText(':D');
  scene.tweens.add({
    targets: prisoner,
    x: 850,
    y: 460,
    duration: 2000,
    ease: 'Linear'
  });
}

function beheadPrisoner(scene, bloodAmount, angleDeg, power = 1) {
  if (headResetEvent) {
    headResetEvent.remove(false);
    headResetEvent = null;
  }
  const angle = angleDeg !== undefined ? angleDeg : Phaser.Math.Between(-110, -70);
  const rad = Phaser.Math.DegToRad(angle);
  const neckX = prisoner.x;
  const neckY = prisoner.y - 10;
  bloodEmitter.explode(bloodAmount, neckX, neckY);
  const headX0 = prisoner.x + prisonerHead.x;
  const headY0 = prisoner.y + prisonerHead.y;
  headEmitter.explode(bloodAmount / 2, headX0, headY0);

  // Create a physics body to represent the headless corpse
  const corpse = scene.add.rectangle(prisoner.x, prisoner.y + 50, 30, 60, prisonerClass.color)
    .setOrigin(0.5, 1)
    .setDepth(0.5);
  bodyGroup.add(corpse);
  corpse.isCorpse = true;
  corpse.bounceCount = 0;
  corpse.body.onWorldBounds = true;
  corpse.body.setBounce(0.05);
  corpse.body.setCollideWorldBounds(true);
  corpse.body.setDrag(50, 0);
  const corpseSpeed = 80 * power;
  // Throw the body based on the chosen slash angle and power
  corpse.body.setVelocity(Math.sin(rad) * corpseSpeed, Math.cos(rad) * corpseSpeed);
  // Spin faster so bodies topple onto their side
  corpse.body.setAngularVelocity(Phaser.Math.Between(-200, 200));

  // Pumping neck spurts while the body tumbles
  bloodEmitter.startFollow(corpse, 0, -50);
  bloodEmitter.setFrequency(60);
  bloodEmitter.setQuantity(Math.max(5, bloodAmount / 25));
  bloodEmitter.start();
  let pumpOn = true;
  if (neckPumpEvent) {
    neckPumpEvent.remove(false);
    neckPumpEvent = null;
  }
  neckPumpEvent = scene.time.addEvent({
    delay: 200,
    repeat: 6,
    callback: () => {
      pumpOn = !pumpOn;
      if (pumpOn) {
        bloodEmitter.start();
      } else {
        bloodEmitter.stop();
      }
    }
  });
  scene.time.delayedCall(1600, () => {
    bloodEmitter.stop();
    bloodEmitter.stopFollow();
    if (neckPumpEvent) {
      neckPumpEvent.remove(false);
      neckPumpEvent = null;
    }
  });

  // Reveal and grow the blood pool once the head is off
  bloodPool.setVisible(true);
  bloodPool.displayWidth = Math.min(bloodPool.displayWidth + 5, 300);

  // Detach head from prisoner container so it can fly freely
  if (prisonerHead.parentContainer === prisoner) {
    const worldX = prisoner.x + prisonerHead.x;
    const worldY = prisoner.y + prisonerHead.y;
    prisoner.remove(prisonerHead);
    prisonerHead.setPosition(worldX, worldY);
    scene.add.existing(prisonerHead);
    prisonerHead.setDepth(1);
  }
  // Hide the template prisoner while the physics body takes over
  prisoner.setVisible(false);

  // Always re-enable physics on the head so it can fly each time
  scene.physics.world.enable(prisonerHead);
  const body = prisonerHead.body;
  body.setAllowGravity(true);
  const speed = 250 * power;
  body.setVelocity(Math.sin(rad) * speed, -Math.cos(rad) * speed);
  body.setAngularVelocity(Phaser.Math.Between(-200, 200));
  headResetEvent = scene.time.delayedCall(2500, () => {
    body.setVelocity(0, 0);
    body.setAngularVelocity(0);
    body.setAllowGravity(false);
    prisonerHead.setRotation(0);
    prisonerHead.setPosition(prisoner.x, prisoner.y - 20);
    scene.physics.world.disable(prisonerHead);
    prisoner.add(prisonerHead);
    prisonerHead.setPosition(0, -20);
    headEmitter.stop();
    headEmitter.stopFollow();
    bloodEmitter.stop();
    bloodEmitter.stopFollow();
    if (neckPumpEvent) {
      neckPumpEvent.remove(false);
      neckPumpEvent = null;
    }
    headResetEvent = null;
  });

  // Continuous spurting from the flying head
  headEmitter.startFollow(prisonerHead, 0, 15);
  headEmitter.setFrequency(20);
  headEmitter.setQuantity(Math.max(5, bloodAmount / 30));
  headEmitter.start();
}

function showAimArrow(scene, bloodAmount, nextSide) {
  pendingBlood = bloodAmount;
  pendingSpawnSide = nextSide;
  awaitingPower = false;
  if (arrowPowerTween) arrowPowerTween.stop();
  // Start the arrow pointing left and sweep over the top to the right
  aimArrow.setAngle(-90);
  aimArrow.setScale(1);
  aimArrow.setVisible(true);
  arrowTween = scene.tweens.add({
    targets: aimArrow,
    angle: { from: -90, to: 90 },
    duration: 800,
    yoyo: true,
    repeat: -1
  });
  awaitingAngle = true;
}

function chooseAngle(scene) {
  if (!awaitingAngle) return;
  awaitingAngle = false;
  if (arrowTween) arrowTween.stop();
  selectedAngle = aimArrow.angle;
  // start power selection tween
  // grow the arrow length only, keeping width constant
  aimArrow.scaleX = 1;
  arrowPowerTween = scene.tweens.add({
    targets: aimArrow,
    scaleY: { from: 0.5, to: 2 },
    duration: 800,
    yoyo: true,
    repeat: -1
  });
  aimArrow.setVisible(true);
  awaitingPower = true;
}

function choosePower(scene) {
  if (!awaitingPower) return;
  awaitingPower = false;
  if (arrowPowerTween) arrowPowerTween.stop();
  const power = aimArrow.scaleY;
  aimArrow.setVisible(false);
  slashExecutioner(scene, selectedAngle, () => {
    beheadPrisoner(scene, pendingBlood, selectedAngle, power);
    // give the head time to fly off screen before the next prisoner arrives
    scene.time.delayedCall(2600, () => {
      spawnPrisoner(scene, pendingSpawnSide === 'right');
    });
  });
}

function slashExecutioner(scene, angle, onComplete) {
  if (slashTween) slashTween.stop();
  slashTween = scene.tweens.add({
    targets: executioner,
    angle: { from: 0, to: -angle },
    duration: 150,
    yoyo: true,
    ease: 'Cubic.easeOut',
    onComplete: () => {
      slashTween = null;
      if (onComplete) onComplete();
    }
  });
}
function introExecutioner(scene, onComplete) {
  executionerIntro = false;
  executioner.setPosition(850, 460);
  executioner.setAlpha(0);
  executioner.setVisible(true);
  scene.tweens.add({
    targets: executioner,
    x: 400,
    alpha: 1,
    duration: 1500,
    ease: "Linear",
    onComplete: onComplete
  });
}

function resetHead(scene) {
  if (headResetEvent) {
    headResetEvent.remove(false);
    headResetEvent = null;
  }
  if (neckPumpEvent) {
    neckPumpEvent.remove(false);
    neckPumpEvent = null;
  }
  headEmitter.stop();
  headEmitter.stopFollow();
  bloodEmitter.stop();
  bloodEmitter.stopFollow();
  if (prisonerHead.body) {
    prisonerHead.body.stop();
    prisonerHead.body.setAllowGravity(false);
    scene.physics.world.disable(prisonerHead);
  }
  if (prisonerHead.parentContainer !== prisoner) {
    scene.children.remove(prisonerHead);
    prisoner.add(prisonerHead);
  }
  prisonerHead.setPosition(0, -20);
  prisonerHead.setRotation(0);
  prisonerBody.setAngle(0);
  prisonerBody.y = 50;
  prisoner.setAngle(0);
}



function spawnPrisoner(scene, fromRight) {
  prisoner.setVisible(true);
  resetHead(scene);
  prisonerClass = pickClass();
  // Spawn a new target each time a prisoner appears
  spawnTarget(scene);
  prisonerBody.setTint(prisonerClass.color);
  baseSwingSpeed = prisonerClass.speed;
  swingSpeed = baseSwingSpeed * speedMultiplier;
  prisonerFace.setText(':(');
  // Keep body aligned under the head when resetting for a new prisoner
  prisonerBody.y = 50;
  
  const startX = fromRight ? 850 : -50;
  prisoner.setPosition(startX, 460);
  leftEscort.setPosition(startX - 50, 460);
  rightEscort.setPosition(startX + 50, 460);
  leftEscort.setVisible(true);
  rightEscort.setVisible(true);
  cursor.setVisible(false);
  swingBar.setVisible(false);
  redZone.setVisible(false);
  yellowZone.setVisible(false);
  greenZone.setVisible(false);
  scene.tweens.add({
    targets: prisoner,
    x: 400,
    duration: 1500,
    ease: 'Linear',
    onComplete: () => {
      // Once the prisoner reaches the center, have the escorts walk off
      // screen to the left instead of simply disappearing.
      scene.tweens.add({
        targets: leftEscort,
        x: -100,
        duration: 1500,
        ease: 'Linear',
        onComplete: () => leftEscort.setVisible(false)
      });
      scene.tweens.add({
        targets: rightEscort,
        x: 0,
        duration: 1500,
        ease: 'Linear',
        onComplete: () => rightEscort.setVisible(false)
      });
      startSwingMeter(scene);
    }
  });
  scene.tweens.add({ targets: leftEscort, x: 350, duration: 1500, ease: 'Linear' });
  scene.tweens.add({ targets: rightEscort, x: 450, duration: 1500, ease: 'Linear' });
}

function startSwingMeter(scene) {
  if (hideMeterEvent) {
    hideMeterEvent.remove(false);
    hideMeterEvent = null;
  }
  if (arrowTween) arrowTween.stop();
  if (arrowPowerTween) arrowPowerTween.stop();
  aimArrow.setVisible(false);
  awaitingAngle = false;
  awaitingPower = false;
  swingActive = true;
  inputEnabled = false;
  scene.time.delayedCall(200, () => { inputEnabled = true; });
  cursor.setVisible(true);
  swingBar.setVisible(true);
  redZone.setVisible(true);
  yellowZone.setVisible(true);
  greenZone.setVisible(true);
  // leave bloodPool visible between swings
  scene.popupText.setVisible(false);

  updateZones();

  // Reset positions
  cursor.x = 250;
  const zoneX = Phaser.Math.Between(300, 500);
  redZone.x = zoneX;
  yellowZone.x = zoneX;
  greenZone.x = zoneX;

  // Ensure head is attached and physics disabled
  resetHead(scene);

  // Meter only starts once prisoner is in position
}

function endSwing(scene) {
  swingActive = false;
  cursor.setVisible(false);
  const accuracy = Math.abs(cursor.x - redZone.x);
  let payout = 0;
  let message = '';
  let bloodAmount;
  let missed = false;
  let spawnSide = null;
  let spawnDelay = 500;
  if (accuracy <= greenZone.displayWidth / 2) {
    payout = 10;
    message = 'Perfect!';
    bloodAmount = 150; // big spurt
  } else if (accuracy <= yellowZone.displayWidth / 2) {
    payout = 5;
    message = 'Close!';
    bloodAmount = 60;
  } else if (accuracy <= redZone.displayWidth / 2) {
    payout = 2;
    message = 'Messy...';
    bloodAmount = 20;
  } else {
    payout = -2;
    bloodAmount = 5;
    missed = true;
  }

  // overall more blood
  bloodAmount *= 1.5;

  if (missed) {
    missStreak++;
    let strikeMsg = `Strike ${missStreak}`;
    if (missStreak >= 3) {
      payout -= 20;
      strikeMsg = 'Strike 3\nSaved!';
      missStreak = 0;
      savePrisoner(scene);
      spawnSide = 'left';
      pendingSpawnSide = 'left';
      spawnDelay = 2000; // wait for the freed prisoner to exit right
    }
    message = `Missed!\n${strikeMsg}`;
    killStreak = 0;
    speedMultiplier = 1;
    swingSpeed = baseSwingSpeed * speedMultiplier;
    killStreakText.setText(`Streak: ${killStreak}`);
    streakMultiplierText.setText(`x${killStreak}`);
  } else {
    missStreak = 0;
    killCount++;
    killStreak++;
    if (killStreak > 1) {
      speedMultiplier *= 1.05;
    }
    swingSpeed = baseSwingSpeed * speedMultiplier;
    killText.setText(`Kills: ${killCount}`);
    killStreakText.setText(`Streak: ${killStreak}`);
    streakMultiplierText.setText(`x${killStreak}`);
    addXP(scene, 1);
    showAimArrow(scene, bloodAmount, 'left');
    spawnSide = null;
    spawnDelay = 0;
  }
  missText.setText(`Misses: ${missStreak}`);

  const goldGain = missed ? payout : payout * killStreak;
  gold += goldGain;
  goldText.setText(`Gold: ${gold}`);

  // Increase and show blood bursts
  if (missed) {
    const neckX = prisoner.x;
    const neckY = prisoner.y - 10;
    bloodEmitter.explode(bloodAmount, neckX, neckY);
    const headX = prisoner.x + prisonerHead.x;
    const headY = prisoner.y + prisonerHead.y;
    headEmitter.explode(bloodAmount / 2, headX, headY);
  }

  // Show popup
  scene.popupText.setText(message);
  scene.popupText.setVisible(true);

  // Leave the meter visible briefly so players can see the result
  hideMeterEvent = scene.time.delayedCall(1000, () => {
    swingBar.setVisible(false);
    redZone.setVisible(false);
    yellowZone.setVisible(false);
    greenZone.setVisible(false);
    scene.time.delayedCall(spawnDelay, () => {
      if (awaitingAngle || awaitingPower) {
        return;
      }
      if (spawnSide) {
        spawnPrisoner(scene, spawnSide === 'right');
      } else {
        startSwingMeter(scene);
      }
    });
  });
}

function gainFame(scene, npc) {
  fame += 1 * fameMultiplier;
  fameText.setText(`Fame: ${Math.floor(fame)}`);
  addXP(scene, 5);
  const popup = scene.add.text(npc.x, npc.y - 40, '+1 Fame', {
    font: '20px monospace',
    fill: '#ffff00'
  }).setOrigin(0.5);
  scene.tweens.add({
    targets: popup,
    y: popup.y - 20,
    alpha: 0,
    duration: 800,
    onComplete: () => popup.destroy()
  });
  scene.time.delayedCall(2000, () => npc.destroy());
}

function spawnTarget(scene) {
  const x = Phaser.Math.Between(100, 700);
  const y = Phaser.Math.Between(200, 400);
  const target = scene.add.container(x, y).setDepth(20);
  const outer = scene.add.circle(0, 0, 20, 0xff0000);
  const inner = scene.add.circle(0, 0, 8, 0xffffff);
  target.add([outer, inner]);
  scene.physics.world.enable(target);
  target.body.setCircle(20);
  target.body.setAllowGravity(false);
  target.body.setImmovable(true);
  target.collected = false;
  targetGroup.add(target);
}

function addXP(scene, amount) {
  xp += amount;
  if (xp >= xpThreshold) {
    xp -= xpThreshold;
    level++;
    xpThreshold = Math.floor(xpThreshold * 1.15);
    onLevelUp(scene);
  }
  updateXPUI();
}

function updateXPUI() {
  xpText.setText(`Level ${level} - ${xp}/${xpThreshold} XP`);
  const maxWidth = 300;
  xpBarFill.displayWidth = maxWidth * (xp / xpThreshold);
}

function onLevelUp(scene) {
  const msg = scene.add.text(400, 300, 'LEVEL UP!', { font: '48px monospace', fill: '#ffff00' })
    .setOrigin(0.5)
    .setDepth(25);
  scene.cameras.main.flash(250, 255, 255, 255);
  scene.tweens.add({
    targets: msg,
    y: 250,
    alpha: 0,
    duration: 1000,
    onComplete: () => msg.destroy()
  });
}

function update(time, delta) {

  // Move cursor
  if (swingActive) {
    cursor.x += swingDirection * swingSpeed;
    if (cursor.x > 550 || cursor.x < 250) {
      swingDirection *= -1;
    }
  }
}
</script>

</body>
</html>
