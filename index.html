<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Chop To It!</title>
  <style>
    body {
      margin: 0;
      background: #111;
    }
    canvas {
      display: block;
      margin: auto;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>
</head>
<body>

<script>
const config = {
  type: Phaser.AUTO,
  width: 800,
  height: 600,
  backgroundColor: '#222',
  physics: { default: 'arcade', arcade: { gravity: { y: 400 } } },
  scene: {
    preload,
    create,
    update
  }
};

const game = new Phaser.Game(config);

let gold = 0;
let goldText;
let swingActive = false;
let cursor;
let redZone;
let yellowZone;
let greenZone;
let swingBar;
let bloodPool;
let bloodEmitter;
let dripEmitter;
let headEmitter;
let missText;
let missStreak = 0;
const VERSION = 'v47';
let versionText;
let inputEnabled = true;
let killCount = 0;
let killText;
let killStreak = 0;
let killStreakText;
let shopButton;
let shopContainer;
let shopOverlay;
let startContainer;
let hideMeterEvent;
let headResetEvent;
let prisoner;
let prisonerBody;
let prisonerHead;
let prisonerFace;
let aimArrow;
let arrowTween;
let awaitingAngle = false;
let pendingBlood = 0;
let pendingSpawnSide = null;
let prisonerClass;
let swingSpeed = 5;

const baseSizes = { red: 60, yellow: 40, green: 20 };
let zoneMods = { red: 0, yellow: 0, green: 0 };

const classes = [
  { name: 'Peasant', color: 0x777777, speed: 5, weight: 50 },
  { name: 'Merchant', color: 0x996633, speed: 6, weight: 25 },
  { name: 'Knight', color: 0x0033cc, speed: 7, weight: 15 },
  { name: 'Clergy', color: 0x800080, speed: 8, weight: 7 },
  { name: 'Lord', color: 0xffff00, speed: 9, weight: 3 }
];

const weapons = [
  {
    name: 'Excalibur',
    type: 'Sword',
    cost: 50,
    desc: 'Legendary blade of kings, widens red zone for precise justice.',
    effects: { red: 20 }
  },
  {
    name: 'Gungnir',
    type: 'Spear',
    cost: 100,
    desc: "Odin's unstoppable spear expands yellow zone for deadlier punishment strikes.",
    effects: { red: 10, yellow: 20 }
  },
  {
    name: 'Mjolnir',
    type: 'Hammer',
    cost: 200,
    desc: "Thunder god's hammer broadens green zone to shatter stubborn necks.",
    effects: { red: 10, yellow: 10, green: 10 }
  },
  {
    name: 'Masamune',
    type: 'Katana',
    cost: 400,
    desc: "Famed smith's katana enlarges all zones ensuring flawless beheadings everytime.",
    effects: { red: 10, yellow: 10, green: 10 }
  }
];

function pickClass() {
  const total = classes.reduce((s, c) => s + c.weight, 0);
  let r = Phaser.Math.Between(1, total);
  for (const c of classes) {
    r -= c.weight;
    if (r <= 0) return c;
  }
  return classes[0];
}

function preload() {
  // Placeholder assets using graphics
}

function create() {
  const scene = this;

  // Background
  scene.add.rectangle(400, 300, 800, 600, 0x2d2d2d);

  // Execution platform (placeholder)
  scene.add.rectangle(400, 500, 300, 20, 0x553311);
  scene.add.text(320, 470, 'Execution Block', { font: '16px serif', fill: '#aaa' });

  // Condemned figure with separate head and body
  prisoner = scene.add.container(400, 460);
  prisonerBody = scene.add.rectangle(0, 20, 30, 60, 0xaaaaaa);
  prisonerHead = scene.add.container(0, -20);
  const headSquare = scene.add.rectangle(0, 0, 30, 30, 0xdddddd);
  prisonerFace = scene.add.text(0, 0, ':(', { font: '16px monospace', fill: '#000' }).setOrigin(0.5);
  prisonerHead.add([headSquare, prisonerFace]);
  // Aim arrow now points horizontally so players choose left/right angles
  aimArrow = scene.add.triangle(0, 0, 0, -6, 0, 6, 20, 0, 0xffff00)
    .setOrigin(0, 0.5)
    .setVisible(false);
  prisonerHead.add(aimArrow);
  prisoner.add([prisonerBody, prisonerHead]);

  // Gold text
  goldText = scene.add.text(16, 16, 'Gold: 0', { font: '20px monospace', fill: '#ffff88' });
  missText = scene.add.text(16, 40, 'Misses: 0', { font: '20px monospace', fill: '#ff8888' });
  killText = scene.add.text(16, 64, 'Kills: 0', { font: '20px monospace', fill: '#ffffff' });
  killStreakText = scene.add.text(16, 88, 'Streak: 0', { font: '20px monospace', fill: '#ffffff' });
  versionText = scene.add.text(790, 590, VERSION, { font: '14px monospace', fill: '#888' })
    .setOrigin(1, 1);

  // Start screen
  startContainer = scene.add.container(0, 0).setDepth(10);
  const startBg = scene.add.rectangle(400, 300, 800, 600, 0x000000, 0.7).setDepth(10);
  const startText = scene.add.text(400, 300, '[ Tap or Click To Start ]', { font: '32px monospace', fill: '#ffffff' })
    .setOrigin(0.5)
    .setInteractive()
    .setDepth(10)
    .on('pointerdown', () => {
      startContainer.setVisible(false);
      spawnPrisoner(scene, false);
    });
  startContainer.add([startBg, startText]);

  // Swing meter base
  const meterY = 550;
  swingBar = scene.add.rectangle(400, meterY, 300, 20, 0x333333).setVisible(false);
  redZone = scene.add.rectangle(400, meterY, baseSizes.red, 20, 0xff0000).setVisible(false);
  yellowZone = scene.add.rectangle(400, meterY, baseSizes.yellow, 20, 0xffff00).setVisible(false);
  greenZone = scene.add.rectangle(400, meterY, baseSizes.green, 20, 0x00ff00).setVisible(false);
  cursor = scene.add.rectangle(250, meterY, 10, 20, 0xffffff).setVisible(false);

  // Blood pool
  bloodPool = scene.add.rectangle(400, 500, 60, 10, 0x770000)
    .setOrigin(0.5, 0)
    .setVisible(true);

  // Blood particle emitter
  const g = scene.add.graphics();
  g.fillStyle(0xff0000, 1);
  g.fillCircle(2, 2, 2);
  g.generateTexture('blood', 4, 4);
  g.destroy();
  const particles = scene.add.particles('blood').setDepth(1);
  bloodEmitter = particles.createEmitter({
    speed: { min: 150, max: 250 },
    angle: { min: 260, max: 280 }, // shoot upward like a fountain
    gravityY: 400,
    lifespan: 800,
    scale: { start: 1, end: 0 },
    quantity: 0,
    on: false
  });
  headEmitter = particles.createEmitter({
    speed: { min: 120, max: 200 },
    angle: { min: 80, max: 100 }, // downward from flying head
    gravityY: 400,
    lifespan: 800,
    scale: { start: 1, end: 0 },
    quantity: 0,
    on: false
  });
  dripEmitter = particles.createEmitter({
    speed: { min: 20, max: 40 },
    angle: 90,
    gravityY: 300,
    lifespan: 1000,
    scale: { start: 0.5, end: 0 },
    quantity: 0,
    on: false
  });

  scene.time.addEvent({
    delay: 400,
    loop: true,
    callback: () => {
      const half = bloodPool.displayWidth / 2;
      const x = Phaser.Math.Between(bloodPool.x - half, bloodPool.x + half);
      dripEmitter.emitParticleAt(x, bloodPool.y + bloodPool.displayHeight, 1);
    }
  });

  // Shop button
  // Move the shop button to the top right corner
  shopButton = scene.add.text(780, 20, '[ Shop ]', { font: '20px monospace', fill: '#ffffff' })
    .setOrigin(1, 0)
    .setInteractive()
    .on('pointerdown', () => {
      toggleShop(scene);
    });

  // Shop container and overlay
  shopOverlay = scene.add.rectangle(400, 300, 800, 600, 0x000000, 0.6)
    .setVisible(false)
    .setDepth(5);
  shopContainer = scene.add.container(100, 100).setVisible(false).setDepth(6);
  const shopBg = scene.add.rectangle(0, 0, 600, 380, 0x222222, 1).setOrigin(0, 0);
  shopBg.setStrokeStyle(2, 0xffffff);
  shopContainer.add(shopBg);
  let itemY = 20;
  weapons.forEach((w, idx) => {
    const title = scene.add.text(10, itemY, `${w.name} - ${w.type} - ${w.cost}g`, { font: '18px monospace', fill: '#ffffaa' });
    const desc = scene.add.text(20, itemY + 20, w.desc, { font: '14px monospace', fill: '#ffffff', wordWrap: { width: 420 } });
    const buy = scene.add.text(450, itemY, '[Buy]', { font: '18px monospace', fill: '#00ff00' })
      .setInteractive()
      .on('pointerdown', () => { buyWeapon(scene, idx); });
    shopContainer.add([title, desc, buy]);
    w.ui = { buy };
    itemY += 70;
  });
  const closeBtn = scene.add.text(560, 10, '[X]', { font: '18px monospace', fill: '#ffffff' })
    .setInteractive()
    .on('pointerdown', () => { toggleShop(scene); });
  shopContainer.add(closeBtn);

  // Text popup
  scene.popupText = scene.add.text(400, 250, '', { font: '24px serif', fill: '#ffffff' })
    .setOrigin(0.5)
    .setVisible(false);

  // Input key for timing
  scene.input.keyboard.on('keydown-SPACE', () => {
    if (swingActive && inputEnabled) endSwing(scene);
  });
  scene.input.on('pointerdown', () => {
    if (awaitingAngle) {
      chooseAngle(scene);
    } else if (swingActive && inputEnabled) {
      endSwing(scene);
    }
  });
}

let swingDirection = 1;

function toggleShop(scene) {
  const visible = !shopContainer.visible;
  shopOverlay.setVisible(visible);
  shopContainer.setVisible(visible);
  if (visible) {
    if (hideMeterEvent) {
      hideMeterEvent.remove(false);
      hideMeterEvent = null;
    }
    swingActive = false;
    inputEnabled = false;
    cursor.setVisible(false);
  } else {
    startSwingMeter(scene);
  }
}

function buyWeapon(scene, index) {
  const w = weapons[index];
  if (w.purchased) return;
  if (gold >= w.cost) {
    gold -= w.cost;
    goldText.setText(`Gold: ${gold}`);
    zoneMods.red += w.effects.red || 0;
    zoneMods.yellow += w.effects.yellow || 0;
    zoneMods.green += w.effects.green || 0;
    updateZones();
    w.purchased = true;
    if (w.ui && w.ui.buy) {
      w.ui.buy.setText('Bought').disableInteractive();
    }
  }
}

function updateZones() {
  redZone.displayWidth = baseSizes.red + zoneMods.red;
  yellowZone.displayWidth = baseSizes.yellow + zoneMods.yellow;
  greenZone.displayWidth = baseSizes.green + zoneMods.green;
}

function savePrisoner(scene) {
  prisonerFace.setText(':D');
  scene.tweens.add({
    targets: prisoner,
    x: 850,
    y: 460,
    duration: 2000,
    ease: 'Linear',
    onComplete: () => {
      prisoner.setPosition(400, 460);
      prisonerFace.setText(':(');
    }
  });
}

function beheadPrisoner(scene, bloodAmount, angleDeg) {
  if (headResetEvent) {
    headResetEvent.remove(false);
    headResetEvent = null;
  }
  const angle = angleDeg !== undefined ? angleDeg : Phaser.Math.Between(-110, -70);
  const rad = Phaser.Math.DegToRad(angle);
  const neckX = prisoner.x;
  const neckY = prisoner.y - 10;
  bloodEmitter.explode(bloodAmount, neckX, neckY);
  const headX0 = prisoner.x + prisonerHead.x;
  const headY0 = prisoner.y + prisonerHead.y;
  headEmitter.explode(bloodAmount / 2, headX0, headY0);

  // Detach head from prisoner container so it can fly freely
  if (prisonerHead.parentContainer === prisoner) {
    const worldX = prisoner.x + prisonerHead.x;
    const worldY = prisoner.y + prisonerHead.y;
    prisoner.remove(prisonerHead);
    prisonerHead.setPosition(worldX, worldY);
    scene.add.existing(prisonerHead);
  }

  // Always re-enable physics on the head so it can fly each time
  scene.physics.world.enable(prisonerHead);
  const body = prisonerHead.body;
  body.setAllowGravity(true);
  body.setVelocity(Math.cos(rad) * 250, Math.sin(rad) * 250);
  body.setAngularVelocity(Phaser.Math.Between(-200, 200));
  headResetEvent = scene.time.delayedCall(2500, () => {
    body.setVelocity(0, 0);
    body.setAngularVelocity(0);
    body.setAllowGravity(false);
    prisonerHead.setRotation(0);
    prisonerHead.setPosition(prisoner.x, prisoner.y - 20);
    scene.physics.world.disable(prisonerHead);
    prisoner.add(prisonerHead);
    prisonerHead.setPosition(0, -20);
    headResetEvent = null;
  });

  // Continuous spurting from the flying head
  headEmitter.startFollow(prisonerHead, 0, 15);
  headEmitter.on = true;
  headEmitter.setQuantity(Math.max(5, bloodAmount / 30));
  scene.time.delayedCall(600, () => {
    headEmitter.on = false;
    headEmitter.stopFollow();
  });
}

function showAimArrow(scene, bloodAmount, nextSide) {
  pendingBlood = bloodAmount;
  pendingSpawnSide = nextSide;
  // Start the arrow pointing left and sweep to the right
  aimArrow.setAngle(180);
  aimArrow.setVisible(true);
  arrowTween = scene.tweens.add({
    targets: aimArrow,
    angle: { from: 180, to: 0 },
    duration: 800,
    yoyo: true,
    repeat: -1
  });
  awaitingAngle = true;
}

function chooseAngle(scene) {
  if (!awaitingAngle) return;
  awaitingAngle = false;
  if (arrowTween) arrowTween.stop();
  aimArrow.setVisible(false);
  const deg = aimArrow.angle;
  beheadPrisoner(scene, pendingBlood, deg);
  scene.time.delayedCall(500, () => {
    spawnPrisoner(scene, pendingSpawnSide === 'right');
  });
}

function spawnPrisoner(scene, fromRight) {
  if (headResetEvent) {
    headResetEvent.remove(false);
    headResetEvent = null;
  }
  prisonerClass = pickClass();
  prisonerBody.fillColor = prisonerClass.color;
  swingSpeed = prisonerClass.speed;

  // Ensure the head is reattached to the prisoner container
  if (prisonerHead.parentContainer !== prisoner) {
    scene.children.remove(prisonerHead);
    prisoner.add(prisonerHead);
  }

  if (prisonerHead.body) {
    prisonerHead.body.stop();
    prisonerHead.body.setAllowGravity(false);
    scene.physics.world.disable(prisonerHead);
  }
  prisonerHead.setPosition(0, -20);
  prisonerHead.setRotation(0);

  const startX = fromRight ? 850 : -50;
  prisoner.setPosition(startX, 460);
  cursor.setVisible(false);
  swingBar.setVisible(false);
  redZone.setVisible(false);
  yellowZone.setVisible(false);
  greenZone.setVisible(false);
  scene.tweens.add({
    targets: prisoner,
    x: 400,
    duration: 1500,
    ease: 'Linear',
    onComplete: () => {
      startSwingMeter(scene);
    }
  });
}

function startSwingMeter(scene) {
  if (hideMeterEvent) {
    hideMeterEvent.remove(false);
    hideMeterEvent = null;
  }
  swingActive = true;
  inputEnabled = false;
  scene.time.delayedCall(200, () => { inputEnabled = true; });
  cursor.setVisible(true);
  swingBar.setVisible(true);
  redZone.setVisible(true);
  yellowZone.setVisible(true);
  greenZone.setVisible(true);
  // leave bloodPool visible between swings
  scene.popupText.setVisible(false);

  updateZones();

  // Reset positions
  cursor.x = 250;
  const zoneX = Phaser.Math.Between(300, 500);
  redZone.x = zoneX;
  yellowZone.x = zoneX;
  greenZone.x = zoneX;

  // Ensure head is attached and physics disabled
  if (prisonerHead.body) {
    prisonerHead.body.stop();
    prisonerHead.body.setAllowGravity(false);
    scene.physics.world.disable(prisonerHead);
  }
  prisonerHead.setPosition(0, -20);
  prisonerHead.setRotation(0);

  // Meter only starts once prisoner is in position
}

function endSwing(scene) {
  swingActive = false;
  cursor.setVisible(false);
  const accuracy = Math.abs(cursor.x - redZone.x);
  let payout = 0;
  let message = '';
  let bloodAmount;
  let missed = false;
  let spawnSide = null;
  let spawnDelay = 500;
  if (accuracy <= greenZone.displayWidth / 2) {
    payout = 10;
    message = 'Perfect!';
    bloodAmount = 150; // big spurt
  } else if (accuracy <= yellowZone.displayWidth / 2) {
    payout = 5;
    message = 'Close!';
    bloodAmount = 60;
  } else if (accuracy <= redZone.displayWidth / 2) {
    payout = 2;
    message = 'Messy...';
    bloodAmount = 20;
  } else {
    payout = -2;
    bloodAmount = 5;
    missed = true;
  }

  // overall more blood
  bloodAmount *= 1.5;

  if (missed) {
    missStreak++;
    let strikeMsg = `Strike ${missStreak}`;
    if (missStreak >= 3) {
    payout -= 20;
    strikeMsg = 'Strike 3\nSaved!';
    missStreak = 0;
    savePrisoner(scene);
    spawnSide = 'left';
    spawnDelay = 1000;
  }
  message = `Missed!\n${strikeMsg}`;
  killStreak = 0;
  killStreakText.setText(`Streak: ${killStreak}`);
} else {
  missStreak = 0;
  killCount++;
  killStreak++;
  killText.setText(`Kills: ${killCount}`);
  killStreakText.setText(`Streak: ${killStreak}`);
  showAimArrow(scene, bloodAmount, 'left');
  spawnSide = null;
  spawnDelay = 0;
}
  missText.setText(`Misses: ${missStreak}`);

  gold += payout;
  goldText.setText(`Gold: ${gold}`);

  // Increase and show blood bursts
  bloodPool.setVisible(true);
  if (!missed) {
    bloodPool.displayWidth = Math.min(bloodPool.displayWidth + 10, 300);
  }
  if (missed) {
    const neckX = prisoner.x;
    const neckY = prisoner.y - 10;
    bloodEmitter.explode(bloodAmount, neckX, neckY);
    const headX = prisoner.x + prisonerHead.x;
    const headY = prisoner.y + prisonerHead.y;
    headEmitter.explode(bloodAmount / 2, headX, headY);
  }

  // Show popup
  scene.popupText.setText(message);
  scene.popupText.setVisible(true);

  // Leave the meter visible briefly so players can see the result
  hideMeterEvent = scene.time.delayedCall(1000, () => {
    swingBar.setVisible(false);
    redZone.setVisible(false);
    yellowZone.setVisible(false);
    greenZone.setVisible(false);
    scene.time.delayedCall(spawnDelay, () => {
      if (awaitingAngle) {
        return;
      }
      if (spawnSide) {
        spawnPrisoner(scene, spawnSide === 'right');
      } else {
        startSwingMeter(scene);
      }
    });
  });
}

function update(time, delta) {

  // Move cursor
  if (swingActive) {
    cursor.x += swingDirection * swingSpeed;
    if (cursor.x > 550 || cursor.x < 250) {
      swingDirection *= -1;
    }
  }
}
</script>

</body>
</html>
