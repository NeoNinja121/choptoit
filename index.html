<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Chop To It!</title>
  <link rel="icon" type="image/png" href="favicon256.png">
  <style>
    html, body {
      margin: 0;
      background: #000;
      color: #fff;
    }
    canvas {
      display: block;
      margin: auto;
      background: #000;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>
  <script src="dayNightCycle.js"></script>
</head>
<body>

<script>
const config = {
  type: Phaser.AUTO,
  width: 800,
  height: 600,
  backgroundColor: '#000',
  physics: { default: 'arcade', arcade: { gravity: { y: 400 } } },
  scene: {
    preload,
    create,
    update
  }
};

const game = new Phaser.Game(config);

// Feature toggles for easy testing
const FEATURES = {
  birds: true,
  movingTargets: true,
  specialTargets: true,
  weather: true,
  clouds: true,
};

const CLOUD_AREA_HEIGHT = 200;
const MAX_COIN_ANIMS = 150;

// Core player state: gold, storage level, and carrying capacity
const player = {
  gold: 0,
  storageLevel: 1,
  maxStorage: 10, // 10 items per level
  weaponLevel: 1,
};

const WEAPON_UPGRADE_RATIO = Math.pow(2000000 / 10, 1 / 28);

function formatGold(amount) {
  if (amount < 1000) return amount.toString();
  const units = ['k', 'M', 'B', 'T'];
  let unitIndex = -1;
  let value = amount;
  while (value >= 1000 && unitIndex < units.length - 1) {
    value /= 1000;
    unitIndex++;
  }
  const rounded = Math.round(value * 10) / 10;
  const display = rounded % 1 === 0 ? rounded.toFixed(0) : rounded;
  return `${display}${units[unitIndex]}`;
}

let goldText;
let fame = 0;
let fameText;
let nextCityKeyCost = 10;
let lastGoldGain = 0;
let pendingCoins = 0;
let swingActive = false;
let cursor;
let redZone;
let yellowZone;
let greenZone;
let swingBar;
let bloodPool;
let stageBlood;
let bloodEmitter;
let dripEmitter;
let headEmitter;
let splatEmitter;
let fireworkEmitter;
let fireworkCloseEmitter;
let bloodFireworkEmitter;
let rainEmitter;
let rainParts;
let fogEmitter;
let fogParts;
let windEmitter;
let windParts;
let cloudLayerFar;
let cloudLayerNear;
let missText;
let missStreak = 0;
let betweenSwings = false;
const VERSION = 'Pre Alpha —v2.98';
let versionText;
let inputEnabled = true;
let killCount = 0;
let killText;
let killStreak = 0;
let streakMultiplierText;
let xp = 0;
let level = 1;
let xpThreshold = 10;
let xpText;
let xpBarFill;
let baseSwingSpeed = 5;
let speedMultiplier = 1;
let shopButton;
let shopContainer;
let shopOverlay;
// Global overlays for fading: screenFadeOverlay dims the whole screen
// while backgroundFadeOverlay only darkens the backdrop.
let screenFadeOverlay;
let backgroundFadeOverlay;
let tradeOverlay;
let tradeContainer;
let tradeTitle;
let tradeItemIndex = null;
let tradeMode = 'buy';
let tradeBuyBtns = [];
let tradeSellBtns = [];
let travelButton;
let storageButton;
let weaponsButton;
let travelContainer;
let travelOverlay;
let storageOverlay;
let storageContainer;
let storageCostText;
let storageImage;
let upgradeButton;
let weaponsOverlay;
let weaponsContainer;
let weaponsCostText;
let weaponsImage;
let weaponUpgradeButton;
let weaponQuoteText;
let weaponQuoteBubble;
let weaponPeasant;
let travelRegion = null;
// The dimming overlay previously used during menu transitions caused a
// distracting flash when switching cities. To remove it while keeping the
// rest of the code functional, we replace it with a no-op stub.
// const backOverlay = {
//   visible: false,
//   setVisible() {},
//   setAlpha() {},
// };
// let backOverlayWasVisible = false;
let locationText;
let currentCity = 'Durham';
let skyRect;
let backgroundRect;
let stage;
let travelList;
let startContainer;
let logoContainer;
let hideMeterEvent;
let headResetEvent;
let neckPumpEvent;
let prisoner;
let prisonerBody;
let prisonerHead;
let prisonerHeadSprite;
let prisonerHeadKey = 'prisonerHead1';
let prisonerBodyKey = 'prisonerBody1';
let leftEscort;
let rightEscort;
let aimArrow;
let arrowTween;
let arrowPowerTween;
let slashTween;
let awaitingAngle = false;
let awaitingPower = false;
let selectedAngle = 0;
let pendingBlood = 0;
let pendingSpawnSide = null;
let prisonerClass;
let swingSpeed = 5;
let executioner;
let executionerIntro = true;
let executionerWeapon;
let gameStarted = false;

// Medieval calendar variables
const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
let currentDay = 1;
let currentMonth = 0;
let dateText;
let dateBg;

// Daily trading modifiers
let dailyBuySpecial = null;
let dailySellSpecial = null;

// Market chatter quotes
const sellingQuotes = [
  "Fresh from the gallows!",
  "No questions asked… or answered.",
  "You didn’t get this from me.",
  "Blood’s barely dry.",
  "Straight from the king’s own stores.",
  "Hope you’ve got a strong stomach.",
  "They’ll never know it was you.",
  "A bargain for a friend of the axe.",
  "Found it after the last beheading.",
  "Careful… it’s still cursed.",
  "Straight from the battlefield.",
  "Don’t look inside the sack.",
  "One careful owner… well, mostly careful.",
  "Don’t tell the guards.",
  "Ah, a fellow collector of the macabre.",
  "This one’s got a story… but you don’t want to hear it.",
  "Cheaper than life, more expensive than death.",
  "Pulled it right out of the dungeon.",
  "Worth its weight in gold… or heads.",
  "I’m risking my neck here.",
  "Straight from the Inquisition’s vault.",
  "The last owner didn’t need it anymore.",
  "You’ve got the look of someone who appreciates quality doom.",
  "Perfect for when subtlety’s overrated.",
  "Handle with gloves… or regret.",
  "Found in a chest… next to a chest.",
  "A relic of a darker age.",
  "Some say it whispers at night.",
  "A true hero’s choice… if you believe the tales.",
  "Looted legally. Sort of.",
  "Half price if you don’t ask where it came from.",
  "May or may not be haunted.",
  "Just like grandma used to sell.",
  "A staple of any villain’s pantry.",
  "Better than bread. Lasts longer too.",
  "This one survived the plague.",
  "Straight from the king’s table.",
  "Careful, it bites back.",
  "A merchant’s gotta eat, you know.",
  "Part of a limited beheading edition.",
  "It’s more fun if you don’t check the expiration date.",
  "Once owned by a knight… or a jester.",
  "Guaranteed to impress… or distress.",
  "A fine piece for your collection of questionable goods.",
  "Whisper its name under a full moon.",
  "Found between the ribs of a dragon.",
  "Imported… in the dead of night.",
  "It’s been cleaned. Mostly.",
  "Straight from the dark lands.",
  "You won’t find better. Or worse.",
  "The last buyer never came back.",
  "May bring fortune… or plague.",
  "Blessed by a priest. Cursed by a witch.",
  "An executioner’s favourite.",
  "Good for trading, terrible for eating.",
  "They say it’s worth a kingdom.",
  "Hurry before the guards see.",
  "Straight from the realm of nightmares.",
  "Don’t ask. Just buy.",
  "Rare as mercy in this land.",
  "Part of a prophecy, probably.",
  "Better than gold… to the right buyer.",
  "Found in a cave… under a pile of bones.",
  "Sharp enough to cut a soul.",
  "The last owner was… indisposed.",
  "Perfect for the discerning tyrant.",
  "An heirloom from a forgotten war.",
  "It’s got history. Lots of it’s blood.",
  "The bards sing of it… badly.",
  "Straight from the loot chest.",
  "Careful, it’s still warm.",
  "This deal won’t survive the night.",
  "An adventurer dropped it… along with their head.",
  "Treasured in three kingdoms, banned in four.",
  "May attract unwanted spirits.",
  "It’s practically screaming to be sold.",
  "Straight from the final boss.",
  "One use only. Make it count.",
  "Handle with care… or don’t.",
  "I’ve seen wars started over less.",
  "A relic of a doomed hero.",
  "Could tip the scales of destiny.",
  "Recovered from a lich’s hoard.",
  "Looks innocent enough, doesn’t it?",
  "Careful, it’s got a mind of its own.",
  "You’ll sleep lighter knowing you own this.",
  "The guild won’t like me selling it to you.",
  "May cause visions. Or madness.",
  "Straight from the loot goblin’s sack.",
  "You didn’t hear about this from me.",
  "It’s rarer than a bard’s honest song.",
  "Once touched by the Dark Lord himself.",
  "Careful, it hungers.",
  "One of a kind… until I find another.",
  "Perfect for settling grudges.",
  "It’s been waiting for you.",
  "Found in a locked chest in the catacombs.",
  "May change the course of your fate.",
  "They’ll write ballads about this purchase.",
  "Worth more than your life… and probably will cost it."
];

const buyingQuotes = [
  "Finally, I’ve been looking for one of these.",
  "I’ll take it… before someone else does.",
  "Been saving for this day.",
  "Worth every coin.",
  "I shouldn’t… but I will.",
  "This will fetch a good price in the next town.",
  "Looks… cleaner than most.",
  "I don’t care if it’s cursed.",
  "Perfect for what I’ve got planned.",
  "A fine addition to my hoard.",
  "Been hunting one of these for years.",
  "It’s heavier than I expected.",
  "Not a bad deal for something so illegal.",
  "This will go nicely with the others.",
  "They’ll never know it was me.",
  "Finally, I can complete the set.",
  "Hope it’s as sharp as it looks.",
  "I’ll hide this before the guards see.",
  "Exactly what I needed for… reasons.",
  "It’s perfect. And probably stolen.",
  "Worth more than the last three villages I passed through.",
  "At last, my collection grows.",
  "They’ll pay triple for this in the capital.",
  "My enemies won’t know what hit them.",
  "This feels… dangerous.",
  "I can smell the history on it.",
  "My associates will be pleased.",
  "Ah, I’ve been expecting you to offer this.",
  "It’s not for me… it’s for a friend.",
  "Finally, something worth my gold.",
  "It’ll look good on my mantle… or my victim.",
  "I’ll take it before someone changes their mind.",
  "Yes… this will do nicely.",
  "You have no idea how useful this will be.",
  "I’ll sleep easier knowing this is mine.",
  "Can you wrap it? No? Thought not.",
  "It’s exactly as I imagined… unsettling.",
  "I’ll hide it with the others.",
  "No one else is brave enough to buy this.",
  "I’ll take two. No reason.",
  "My rivals will envy me.",
  "I’ve waited a lifetime for this.",
  "Finally, my luck has turned.",
  "The guild will hear of this.",
  "It’s more beautiful than the legends say.",
  "I’ll treasure it… for a while.",
  "Can’t wait to see their faces.",
  "I’ll take it before the inquisition sees.",
  "It’ll be worth ten times as much tomorrow.",
  "My collection is almost complete.",
  "Finally, I can finish what I started.",
  "I’ll keep this one close.",
  "A bargain for such a dangerous thing.",
  "I’ll pay whatever it takes.",
  "Been after this since the war.",
  "It’ll serve me well in the trials ahead.",
  "I’ll take it before fate changes her mind.",
  "Perfect… absolutely perfect.",
  "No one will suspect a thing.",
  "It belongs with me now.",
  "I’ll hide it in the old chest.",
  "My master will be most pleased.",
  "The others will be jealous.",
  "This is exactly what I needed.",
  "It’s more dangerous than I expected.",
  "I’ll keep it safe… maybe.",
  "It’s almost too perfect to use.",
  "The prophecy spoke of this day.",
  "I can’t believe you’re selling this.",
  "I’ll take it off your hands… before trouble starts.",
  "This will make them remember my name.",
  "The bards will sing of this.",
  "No one else could handle this.",
  "I’ll use it wisely… or not.",
  "I’ve seen one of these before. Ended badly.",
  "They’ll never see it coming.",
  "This will change everything.",
  "I’ll keep it hidden until the time is right.",
  "A rare find indeed.",
  "The last time I saw one, it was on a corpse.",
  "Finally, I can even the score.",
  "This will seal my victory.",
  "They’ll regret crossing me.",
  "It’s mine now. Forever.",
  "This will fetch a fortune abroad.",
  "I’ll guard it with my life.",
  "No one else is worthy of it.",
  "I’ve been dreaming of this moment.",
  "I’ll pay extra for the bloodstains.",
  "It’s more powerful than I hoped.",
  "It belongs in my vault.",
  "No one will dare challenge me now.",
  "It’s perfect… in a terrible way.",
  "I’ll take it and the curse that comes with it.",
  "The council will never approve… good.",
  "It’s more dangerous than you know.",
  "Finally, I have the upper hand.",
  "I’ll keep it until the end.",
  "They’ll tell stories about this.",
  "With this, the world changes."
];

// Weapon upgrade quotes
const weaponBeforeQuotes = [
  "You again? What do you want now?",
  "Can’t you see I’m busy ruining perfectly good metal?",
  "Hope you’re not here to waste my time.",
  "Great, another wannabe hero.",
  "You couldn’t afford my scrap bin.",
  "Try not to drool on the merchandise.",
  "Why would I give you a sharp weapon?",
  "You’d hurt yourself with a spoon.",
  "These are for fighters, not… whatever you are.",
  "You’ve got coin? Shocking.",
  "I’d rather sell to a drunk rat.",
  "Don’t touch anything, you’ll break it.",
  "Hope your purse is fatter than your brain.",
  "That blade’s worth more than you.",
  "You’re not worthy of holding this.",
  "Bet you’ll pawn it within a week.",
  "Didn’t think you’d survive long enough to come back.",
  "Your grip’s all wrong. Pathetic.",
  "Fine. But I won’t be responsible for the mess you make.",
  "You’re too soft for this steel.",
  "Try not to cut yourself. Or do, I don’t care.",
  "This weapon’s for killing, not showing off.",
  "Go polish your wooden sword somewhere else.",
  "You’ll ruin it in a day.",
  "Why am I even talking to you?",
  "Your coin smells funny.",
  "I should charge extra for having to look at you.",
  "This work deserves a better wielder.",
  "Sure, if you promise not to cry when it’s heavy.",
  "I’ve seen sharper rocks.",
  "You couldn’t even lift my hammer.",
  "Put that face away before it dents the steel.",
  "You’re about as threatening as a wet rag.",
  "I’d rather arm the enemy.",
  "Do you even know which end to hold?",
  "I should melt this down before you touch it.",
  "You’ll only embarrass yourself with it.",
  "What, you think this is a toy shop?",
  "If it were up to me, you’d get a stick.",
  "Your posture makes me want to weep.",
  "Steel’s too good for you.",
  "What are you compensating for with that?",
  "Ever considered staying unarmed?",
  "The forge groans when you walk in.",
  "You’ve got the hands of a milkmaid.",
  "This isn’t for parade work, you know.",
  "You won’t last long enough to dull it.",
  "Maybe stick to kitchen knives.",
  "I should be paid to not sell you this.",
  "Don’t bleed on the floor.",
  "That coin better be real.",
  "Weapons are wasted on the weak.",
  "Hold still, you’re breathing on it.",
  "If it bends, it’s your fault.",
  "You’ve got the look of a man who’ll drop it in a puddle.",
  "Can you even spell ‘sword’?",
  "I could make something better blindfolded.",
  "You reek of bad decisions.",
  "This won’t make you a hero.",
  "Ever thought of retiring before you start?",
  "You’ve got that ‘dead in a week’ look.",
  "What a waste of fine craftsmanship.",
  "Don’t chip it on your first swing.",
  "Bet you’ll lose it to a thief by sundown.",
  "I should be forging for someone who matters.",
  "Your coin purse looks like it’s about to cry.",
  "Hope you’ve got armour to match. Or a coffin.",
  "That’s too much weapon for you.",
  "Even the tongs are laughing.",
  "You’re lucky I’m bored.",
  "Keep your grubby mitts off the blade.",
  "You couldn’t dent a melon with that swing.",
  "Might as well hand it straight to your enemy.",
  "Don’t point it at me, fool.",
  "I’ll have to scrub it after you touch it.",
  "You’ve got no business owning steel like this.",
  "Fine, take it before I change my mind.",
  "Your face screams ‘first casualty.’",
  "I forged this for someone better.",
  "You’re not that someone.",
  "Try not to disgrace it.",
  "This won’t save you.",
  "I’d rather sell nails to a coffin maker.",
  "Don’t drag it, you’ll dull it.",
  "Do you even know what you’re buying?",
  "You’ll trip over it.",
  "You’re going to break it, aren’t you?",
  "Just don’t come crying when it goes wrong.",
  "This is charity, really.",
  "A sword’s only as good as its wielder. Poor thing.",
  "At least it’ll look nice when they bury you.",
  "I should make you sign a waiver.",
  "Hope you’re better at fighting than talking.",
  "Careful, it’s sharper than your wit.",
  "You’ve got no idea how to use it, do you?",
  "You’ll make me regret this.",
  "This is a mistake.",
  "Don’t prove me right.",
  "This is the last time.",
  "I said I wouldn’t sell to you again… and here we are."
];

const weaponAfterQuotes = [
  "Try not to hurt yourself walking out.",
  "Let’s see how long before you break it.",
  "Watch out, it’s dangerous… unlike you.",
  "I’ll start the pool on when you lose it.",
  "Hope you know which end to point at the enemy.",
  "Don’t come back for a refund.",
  "Guess I’ll be seeing this in the pawn shop soon.",
  "Look at you, all dangerous now.",
  "Don’t scratch it before you get home.",
  "Keep it shiny for the grave robbers.",
  "Now you just need the skill to use it.",
  "Bet it spends more time on your wall than in battle.",
  "Don’t let the chickens laugh at you.",
  "Remember: pointy end goes in the bad guy.",
  "It’ll outlast you, easily.",
  "Looks good… shame about the wielder.",
  "The blade’s sharp. Your brain, less so.",
  "Now go on, scare the neighbours.",
  "A fine weapon wasted on a fool.",
  "Try not to chip it on a loaf of bread.",
  "You’ll be polishing it more than swinging it.",
  "That’ll make a fine heirloom for someone else.",
  "Maybe you’ll survive a whole day now.",
  "I’ve seen milkmaids with better form.",
  "It’s not magic, it won’t make you good.",
  "Go ahead, pose in front of the mirror.",
  "Don’t drop it… again.",
  "You look ridiculous.",
  "Now you’ve got the gear, still missing the guts.",
  "Hope you’ve got armour to match. Or a will.",
  "That’s the most dangerous thing you’ve ever owned.",
  "Bet you’ll name it something stupid.",
  "Don’t test it on the furniture.",
  "The forge is weeping for its lost work.",
  "You’ll make it look bad.",
  "At least it’ll be easy to recover from your corpse.",
  "A fine choice… for someone else.",
  "Now you’re armed, still not dangerous.",
  "The steel’s worth more than you are.",
  "Make sure to tell everyone where you got it.",
  "The metal’s better tempered than you.",
  "That’s a fine piece of work. Shame about the buyer.",
  "Go swing it at a tree, not people.",
  "That’ll do… for decorative purposes.",
  "It won’t fix your footwork.",
  "You’ll dull it before the week’s out.",
  "Maybe the enemy will die laughing.",
  "You’re the worst thing that’ll happen to that blade.",
  "Hope you enjoy polishing.",
  "Try not to trip over it.",
  "The scabbard’s smarter than you.",
  "Even a rat could put it to better use.",
  "You’ll lose it in a tavern bet.",
  "Better watch out, you might look competent.",
  "It’s heavier than your common sense.",
  "Make sure you swing with the sharp side.",
  "Try to keep it out of the mud.",
  "Don’t get too attached.",
  "You’ll have it bent in no time.",
  "A masterpiece meets a disaster.",
  "You’re holding it wrong already.",
  "Maybe the shine will distract your enemies.",
  "The blade’s perfect. You’re not.",
  "It deserves a better owner.",
  "Don’t nick it on the doorway.",
  "You’ll break before it does.",
  "Now all you need is courage.",
  "It’s sharp enough to cut through your excuses.",
  "You’ll ruin it.",
  "It’s wasted on you.",
  "The edge is fine. Yours isn’t.",
  "Don’t wave it indoors.",
  "The blacksmithing gods are laughing.",
  "The handle has more spine than you.",
  "Bet you’ll forget to oil it.",
  "The sword’s ready. You’re not.",
  "You’ve upgraded the weapon, not the wielder.",
  "Try not to stab yourself.",
  "You’re shaking already.",
  "I’ll see it again when someone brings it back.",
  "You’ll lose to a farmer.",
  "It’s as ready as it’ll ever be. You’re not.",
  "At least it’ll look nice at your funeral.",
  "The steel’s pure. Your soul, not so much.",
  "You’re the weakest part of that weapon.",
  "Try to keep the blood on the enemy.",
  "The forge didn’t work this hard for you.",
  "Careful, you’ll poke your eye out.",
  "The edge is wasted.",
  "It’s a weapon, not a walking stick.",
  "It’s worth more than your horse.",
  "The blade’s clean. You’re filthy.",
  "Try not to name it something stupid.",
  "Hope you’ve got insurance.",
  "You’re breathing too close to it.",
  "The weapon’s perfect. The wielder’s hopeless.",
  "It’ll never forgive you.",
  "You’ve made a terrible mistake.",
  "You’ll regret this purchase before I do.",
  "Don’t prove me right."
];

let marketChatterText;
let marketChatterBubble;
let marketPrisoner;

// Group to hold fallen bodies that pile up at the bottom
let bodyGroup;
let targetGroup;
let chest;

function setGoldChestVisible(visible) {
  if (chest) chest.setVisible(visible);
  if (goldText) goldText.setVisible(visible);
  if (fameText) fameText.setVisible(visible);
}

let currentWeather = 'clear';
let windForce = { x: 0, y: 0 };
let roundCount = 0;
let weatherText;
let weatherIndicator;
let weatherIndicatorBg;

// Inventory for trading market items
let inventory = {};
// Multiplier applied to fame gains
let fameMultiplier = 1;

const baseSizes = { red: 60, yellow: 40, green: 20 };
let zoneMods = { red: 0, yellow: 0, green: 0 };

const classes = [
  { name: 'Peasant', color: 0x777777, speed: 5, weight: 50 },
  { name: 'Merchant', color: 0x996633, speed: 6, weight: 25 },
  { name: 'Knight', color: 0x0033cc, speed: 7, weight: 15 },
  { name: 'Clergy', color: 0x800080, speed: 8, weight: 7 },
  { name: 'Lord', color: 0xffff00, speed: 9, weight: 3 }
];

const weapons = [
  {
    name: 'Excalibur',
    type: 'Sword',
    cost: 50,
    desc: 'Legendary blade of kings, widens red zone for precise justice.',
    effects: { red: 20 }
  },
  {
    name: 'Gungnir',
    type: 'Spear',
    cost: 100,
    desc: "Odin's unstoppable spear expands yellow zone for deadlier punishment strikes.",
    effects: { red: 10, yellow: 20 }
  },
  {
    name: 'Mjolnir',
    type: 'Hammer',
    cost: 200,
    desc: "Thunder god's hammer broadens green zone to shatter stubborn necks.",
    effects: { red: 10, yellow: 10, green: 10 }
  },
  {
    name: 'Masamune',
    type: 'Katana',
    cost: 400,
    desc: "Famed smith's katana enlarges all zones ensuring flawless beheadings everytime.",
    effects: { red: 10, yellow: 10, green: 10 }
  }
];

// Upgrades that boost fame gain or provide passive bonuses
const gameUpgrades = [
  { name: 'Grand Stage', cost: 150, fameReq: 0, desc: 'Bigger stage draws crowds. Fame x1.1', mult: 1.1 },
  { name: 'Traveling Caravan', cost: 300, fameReq: 3, desc: 'Musicians and banners. Fame x1.2', mult: 1.2 },
  { name: 'Royal Horse', cost: 600, fameReq: 6, desc: 'Arrive in style. Fame x1.3', mult: 1.3 }
];

// Items available in the trading market
const marketItems = [
  { name: 'Turnips', buy: 1, sell: 1, fameReq: 0, regions: ['north', 'south'] },
  { name: 'Potatoes', buy: 2, sell: 1, fameReq: 0, regions: ['north', 'south'] },
  { name: 'Salt', buy: 8, sell: 4, fameReq: 1, regions: ['north', 'south'] },
  { name: 'Mead', buy: 5, sell: 3, fameReq: 0, regions: ['north', 'south'] },
  { name: 'Wool', buy: 9, sell: 4, fameReq: 2, regions: ['north', 'south'] },
  { name: 'Iron Ore', buy: 12, sell: 6, fameReq: 3, regions: ['north', 'south'] },
  { name: 'Ale Barrels', buy: 15, sell: 7, fameReq: 4, regions: ['north', 'south'] },
  { name: 'Tanned Leather', buy: 16, sell: 8, fameReq: 5, regions: ['north', 'south'] },
  { name: 'Spices', buy: 18, sell: 9, fameReq: 6, regions: ['south'] },
  { name: 'Silver Cups', buy: 20, sell: 10, fameReq: 7, regions: ['south'] },
  { name: 'Gemstones', buy: 50, sell: 25, fameReq: 8, regions: ['south'] },
  { name: 'Obsidian Shards', buy: 80, sell: 40, fameReq: 9, regions: ['south'] },
  { name: 'Blood Runes', buy: 120, sell: 60, fameReq: 10, regions: ['south'] },
  { name: 'Cursed Guillotine Blades', buy: 200, sell: 100, fameReq: 11, regions: ['south'] },
  { name: 'Dragon Eggs', buy: 400, sell: 200, fameReq: 12, regions: ['south'] }
];

// Places the player can visit
const cities = [
  { name: 'York', desc: 'Historic northern city.', fameReq: 0, region: 'north', /* bgColor: 0x2d2d2d, */
    modifiers: { Potatoes: { buy: 0.9, sell: 1.1 } } },
  { name: 'Durham', desc: 'Northern cathedral city.', fameReq: 1, region: 'north', /* bgColor: 0x34342d, */
    modifiers: { Potatoes: { buy: 0.9, sell: 1.1 } } },
  { name: 'Chester', desc: 'Fortified Roman town.', fameReq: 2, region: 'north', /* bgColor: 0x342d34, */
    modifiers: { Mead: { buy: 0.9, sell: 1.1 } } },
  { name: 'Hull', desc: 'North Sea trading port.', fameReq: 3, region: 'north', /* bgColor: 0x2d342d, */
    modifiers: { 'Iron Ore': { buy: 0.85, sell: 1.15 } } },
  { name: 'Newcastle', desc: 'City on the Tyne.', fameReq: 4, region: 'north', /* bgColor: 0x2d2d34, */
    modifiers: { Potatoes: { buy: 0.9, sell: 1.1 } } },
  { name: 'Lincoln', desc: 'Cathedral and castle city.', fameReq: 5, region: 'north', /* bgColor: 0x342d2d, */
    modifiers: { Salt: { buy: 0.9, sell: 1.1 } } },
  { name: 'Canterbury', desc: 'Seat of the Archbishop.', fameReq: 6, region: 'south', /* bgColor: 0x2d2d34, */
    modifiers: { Mead: { buy: 0.9, sell: 1.1 } } },
  { name: 'London', desc: 'Bustling capital of the realm.', fameReq: 7, region: 'south', /* bgColor: 0x34342d, */
    modifiers: { Salt: { buy: 0.9, sell: 1.1 } } },
  { name: 'Dover', desc: 'Channel crossing hub.', fameReq: 8, region: 'south', /* bgColor: 0x2d342d, */
    modifiers: { Salt: { buy: 0.9, sell: 1.1 } } },
  { name: 'Norwich', desc: 'Town of fine artisans.', fameReq: 9, region: 'south', /* bgColor: 0x342d2d, */
    modifiers: { Gemstones: { buy: 0.8, sell: 1.2 } } },
  { name: 'Winchester', desc: 'Former royal seat.', fameReq: 10, region: 'south', /* bgColor: 0x2d3434, */
    modifiers: { Mead: { buy: 0.9, sell: 1.1 } } },
  { name: 'Colchester', desc: 'Ancient Roman city.', fameReq: 11, region: 'south', /* bgColor: 0x34342d, */
    modifiers: { Mead: { buy: 0.9, sell: 1.1 } } },
  { name: 'Oxford', desc: 'Home of great learning.', fameReq: 12, region: 'south', /* bgColor: 0x2d3434, */
    modifiers: { 'Silver Cups': { buy: 0.85, sell: 1.15 } } },
  { name: 'Southampton', desc: 'Southern port city.', fameReq: 13, region: 'south', /* bgColor: 0x2d2d34, */
    modifiers: { Gemstones: { buy: 0.8, sell: 1.2 } } },
  { name: 'Gloucester', desc: 'Historic Roman city.', fameReq: 14, region: 'south', /* bgColor: 0x34342d, */
    modifiers: { Potatoes: { buy: 0.9, sell: 1.1 } } }
];

// Track which cities have been unlocked; start with the current city
cities.forEach(c => {
  c.unlocked = c.name === currentCity;
});

// Mapping of cities to their background image files. Keys are the city names
// and values are the corresponding PNG filenames.
const cityBackgrounds = {
  York: 'background_york.png',
  Canterbury: 'background_canterbury.png',
  London: 'background_london.png',
  Dover: 'background_dover.png',
  Durham: 'background_durham.png',
  Norwich: 'background_norwich.png',
  Winchester: 'background_winchester.png',
  Chester: 'background_chester.png',
  Hull: 'background_hull.png',
  Newcastle: 'background_newcastle.png',
  Colchester: 'background-colchester.png',
  Lincoln: 'background-lincoln.png',
  Oxford: 'background-oxford.png',
  Southampton: 'background-southhampton.png',
  Gloucester: 'background-gloucester.png',
};

// List of travel background images used during travel scenes.
const travelBackgrounds = Array.from({ length: 14 }, (_, i) => `background_travel${i + 1}.png`);

// Rough geographic coordinates for each city used to estimate travel time
const cityCoords = {
  Winchester: [51.06, -1.31],
  York: [53.96, -1.08],
  Dover: [51.13, 1.31],
  Durham: [54.78, -1.58],
  Canterbury: [51.28, 1.08],
  London: [51.5, -0.1],
  Chester: [53.19, -2.89],
  Norwich: [52.63, 1.3],
  Hull: [53.74, -0.34],
  Newcastle: [54.97, -1.61],
  Colchester: [51.89, 0.9],
  Lincoln: [53.23, -0.54],
  Oxford: [51.75, -1.26],
  Southampton: [50.9, -1.4],
  Gloucester: [51.87, -2.24],
};

// Calculate great-circle distance between two coordinate pairs in miles
function distanceMiles(a, b) {
  const [lat1, lon1] = cityCoords[a];
  const [lat2, lon2] = cityCoords[b];
  const R = 6371e3; // metres
  const phi1 = lat1 * Math.PI / 180;
  const phi2 = lat2 * Math.PI / 180;
  const dPhi = (lat2 - lat1) * Math.PI / 180;
  const dLambda = (lon2 - lon1) * Math.PI / 180;
  const aa = Math.sin(dPhi / 2) ** 2 + Math.cos(phi1) * Math.cos(phi2) * Math.sin(dLambda / 2) ** 2;
  const c = 2 * Math.atan2(Math.sqrt(aa), Math.sqrt(1 - aa));
  return (R * c) / 1609.34;
}

// Average pace roughly 24 miles per day
function getTravelDays(from, to) {
  if (from === to) return 0;
  const miles = distanceMiles(from, to);
  return Math.max(1, Math.round(miles / 24));
}

// Format the current calendar date
function getDateString() {
  return `${currentDay} ${months[currentMonth]}`;
}

// Apply random price changes, city modifiers and daily specials
function refreshMarketPrices() {
  const city = cities.find(c => c.name === currentCity);
  marketItems.forEach(m => {
    if (city && m.regions && !m.regions.includes(city.region)) {
      m.currentBuy = m.buy;
      m.currentSell = m.sell;
      m.stock = 0;
      return;
    }
    let buyMult = Phaser.Math.FloatBetween(0.9, 1.1);
    let sellMult = Phaser.Math.FloatBetween(0.9, 1.1);
    if (city && city.modifiers && city.modifiers[m.name]) {
      const mod = city.modifiers[m.name];
      if (mod.buy) buyMult *= mod.buy;
      if (mod.sell) sellMult *= mod.sell;
    }
    if (m.name === dailyBuySpecial) buyMult *= 0.75;
    if (m.name === dailySellSpecial) sellMult *= 1.25;
    m.currentBuy = Math.max(1, Math.round(m.buy * buyMult));
    m.currentSell = Math.max(1, Math.round(m.sell * sellMult));
    const cityLevel = city ? city.fameReq || 0 : 0;
    const variation = Phaser.Math.Between(-2, 2);
    if (m.buy >= 20) {
      m.stock = Math.max(0, Math.floor(cityLevel / 2) + 2 + variation);
    } else if (m.buy <= 5) {
      m.stock = Math.max(0, 10 - Math.floor(cityLevel / 2) + variation);
    } else {
      m.stock = Math.max(0, 6 + Math.floor(cityLevel / 3) + variation);
    }
  });
}

function chooseTargetType() {
  if (!FEATURES.specialTargets) return 'standard';
  const r = Phaser.Math.Between(1, 100);
  if (r <= 5) return killStreak >= 10 ? 'royal' : 'standard';
  if (r <= 15) return 'holyMonk';
  if (r <= 35) return killStreak >= 8 ? 'explodingBarrel' : 'standard';
  if (r <= 65) return 'woodenShield';
  return 'standard';
}

function createTargetAppearance(scene, target, type) {
  target.removeAll(true);
  switch (type) {
    case 'woodenShield': {
      const c = scene.add.circle(0, 0, 20, 0x8b4513);
      const m = scene.add.circle(0, 0, 6, 0xcccccc);
      target.add([c, m]);
      break;
    }
    case 'explodingBarrel': {
      const b = scene.add.rectangle(0, 0, 30, 40, 0x663300);
      const f = scene.add.rectangle(0, -22, 4, 8, 0xff0000);
      target.add([b, f]);
      break;
    }
    case 'holyMonk': {
      const m = scene.add.rectangle(0, 0, 30, 40, 0xffffcc);
      target.add(m);
      break;
    }
      case 'royal': {
        const o = scene.add.circle(0, 0, 20, 0xffff00);
        const txt = scene.add.text(0, 0, 'R', { font: '16px monospace', fill: '#000' })
          .setOrigin(0.5);
        target.add([o, txt]);
        break;
      }
      case 'bird': {
        const base = target.birdKind === 'dove' ? 'birdWhite' : 'birdBlack';
        const direction = target.fromRight ? 'Right' : 'Left';
        const key = base + direction;
        const img = scene.add.image(0, 0, key).setOrigin(0.5);
        target.add(img);
        target.birdSprite = img;
        break;
      }
      default: {
        const outer = scene.add.circle(0, 0, 20, 0xff0000);
        const inner = scene.add.circle(0, 0, 8, 0xffffff);
        target.add([outer, inner]);
      }
  }
}



function applyRandomWeather(scene) {
  const clearChance = 0.5;
  if (!FEATURES.weather || Math.random() < clearChance) {
    currentWeather = 'clear';
  } else {
    currentWeather = Phaser.Utils.Array.GetRandom(['rain', 'wind', 'fog']);
  }
  windForce = { x: 0, y: 0 };
  weatherText.setText(currentWeather.toUpperCase());
  if (rainEmitter) rainEmitter.stop();
  if (fogEmitter) fogEmitter.stop();
  if (windEmitter) windEmitter.stop();
  let letter = '';
  let arrow = '';
  targetGroup.getChildren().forEach(t => {
    if (t.fogTween) { t.fogTween.stop(); t.fogTween = null; }
    t.setAlpha(1);
    if (t.jester && t.jester.fogTween) { t.jester.fogTween.stop(); t.jester.fogTween = null; }
    if (t.jester) t.jester.setAlpha(1);
  });
  if (currentWeather === 'wind') {
    windForce.x = Phaser.Math.Between(-100, 100);
    windForce.y = Phaser.Math.Between(-100, 100);
    letter = 'W';
    arrow = arrowForWind(windForce.x, windForce.y);
    if (windEmitter) {
      windEmitter.setSpeedX({ min: windForce.x - 20, max: windForce.x + 20 });
      windEmitter.setSpeedY({ min: windForce.y - 20, max: windForce.y + 20 });
      const zone = new Phaser.Geom.Rectangle(-20, 0, 840, 600);
      windEmitter.setEmitZone({ type: 'random', source: zone });
      windEmitter.start();
    }
  } else if (currentWeather === 'fog') {
    letter = 'F';
    targetGroup.getChildren().forEach(t => {
      t.fogTween = scene.tweens.add({ targets: t, alpha: 0.4, yoyo: true, repeat: -1, duration: 800 });
      if (t.jester) {
        t.jester.fogTween = scene.tweens.add({ targets: t.jester, alpha: 0.4, yoyo: true, repeat: -1, duration: 800 });
      }
    });
    if (fogEmitter) fogEmitter.start();
  } else if (currentWeather === 'rain') {
    letter = 'R';
    if (rainEmitter) rainEmitter.start();
  } else if (currentWeather === 'clear') {
    letter = 'C';
  }
  weatherIndicator.setText(letter + arrow);
}

function arrowForWind(x, y) {
  const angle = Math.atan2(y, x);
  const arrows = ['→', '↘', '↓', '↙', '←', '↖', '↑', '↗'];
  let idx = Math.round(angle / (Math.PI / 4));
  if (idx < 0) idx += 8;
  return arrows[idx % 8];
}

// Display a market quote with typing effect
let marketTypeEvent;
function updateSpeechBubble() {
  if (!marketChatterText || !marketChatterBubble) return;
  const padding = 10;
  const bounds = marketChatterText.getBounds();
  const width = bounds.width + padding * 2;
  const height = bounds.height + padding * 2;
  marketChatterBubble.setSize(width, height);
  marketChatterBubble.setPosition(marketChatterText.x, marketChatterText.y);
  if (marketPrisoner) {
    const peasantWidth = marketPrisoner.width || 0;
    marketPrisoner.x = marketChatterBubble.x + width / 2 + peasantWidth / 2 + 10;
    marketPrisoner.y = marketChatterBubble.y + height / 2;
  }
}

function typeMarketQuote(quote) {
  if (!marketChatterText) return;
  if (marketTypeEvent) marketTypeEvent.remove(false);
  const scene = marketChatterText.scene;

  // Size the speech bubble and position the peasant based on the full quote
  // before the typing effect starts so they remain stationary.
  marketChatterText.setText(quote);
  updateSpeechBubble();
  marketChatterText.setText('');

  let i = 0;
  marketTypeEvent = scene.time.addEvent({
    delay: 40,
    repeat: quote.length - 1,
    callback: () => {
      marketChatterText.setText(marketChatterText.text + quote[i]);
      i++;
    }
  });
}

function showMarketQuote(quotes) {
  if (!marketChatterText) return;
  if (marketPrisoner) {
    const color = Phaser.Utils.Array.GetRandom(classes).color;
    marketPrisoner.list[0].setTint(color);
  }
  const quote = Phaser.Utils.Array.GetRandom(quotes);
  typeMarketQuote(quote);
}

function updateWeaponQuoteBubble() {
  if (!weaponQuoteText || !weaponQuoteBubble) return;
  const padding = 10;
  const width = weaponQuoteText.width + padding * 2;
  const height = weaponQuoteText.height + padding * 2;
  weaponQuoteBubble.setSize(width, height);
  weaponQuoteBubble.setPosition(weaponQuoteText.x, weaponQuoteText.y);
  if (weaponPeasant) {
    weaponPeasant.x = weaponQuoteText.x + width / 2 + 10;
    weaponPeasant.y = weaponQuoteText.y + height / 2;
  }
}

function showWeaponQuote(quotes) {
  if (!weaponQuoteText) return;
  const quote = Phaser.Utils.Array.GetRandom(quotes);
  weaponQuoteText.setText(quote);
  updateWeaponQuoteBubble();
}

// Refresh prices, specials and chatter at the start of a new day
function dailyMarketUpdate() {
  const city = cities.find(c => c.name === currentCity);
  const availableItems = marketItems.filter(m => !m.regions || (city && m.regions.includes(city.region)));
  dailyBuySpecial = Phaser.Utils.Array.GetRandom(availableItems).name;
  do {
    dailySellSpecial = Phaser.Utils.Array.GetRandom(availableItems).name;
  } while (dailySellSpecial === dailyBuySpecial);
  refreshMarketPrices();
  updateMarketUI();
  showMarketQuote(sellingQuotes);
}

// Advance the calendar by a number of days
function advanceDays(days = 1) {
  for (let i = 0; i < days; i++) {
    currentDay++;
    if (currentDay > 30) {
      currentDay = 1;
      currentMonth = (currentMonth + 1) % months.length;
    }
  }
  if (dateText) dateText.setText(getDateString());
}

// Alias used by the day/night cycle to advance time
function advanceCalendarDays(days = 1) {
  advanceDays(days);
}

function isMenuOpen() {
  return (shopContainer && shopContainer.visible) ||
         (travelContainer && travelContainer.visible) ||
         (storageContainer && storageContainer.visible) ||
         (weaponsContainer && weaponsContainer.visible) ||
         (tradeContainer && tradeContainer.visible);
}

function releaseQueuedCoins(scene) {
  if (pendingCoins > 0 && !isMenuOpen()) {
    const count = Math.min(pendingCoins, MAX_COIN_ANIMS);
    for (let i = 0; i < count; i++) {
      scene.time.delayedCall(i * 100, () => spawnCoin(scene));
    }
    pendingCoins = 0;
  }
}

function addGold(scene, amount) {
  if (amount <= 0) return;
  player.gold += amount;
  goldText.setText(formatGold(player.gold));
  if (isMenuOpen()) {
    pendingCoins = Math.min(pendingCoins + amount, MAX_COIN_ANIMS);
  } else {
    const count = Math.min(amount, MAX_COIN_ANIMS);
    for (let i = 0; i < count; i++) {
      scene.time.delayedCall(i * 100, () => spawnCoin(scene));
    }
  }
}

function spawnCoin(scene) {
  if (isMenuOpen()) {
    pendingCoins = Math.min(pendingCoins + 1, MAX_COIN_ANIMS);
    return;
  }
  const coin = scene.add.circle(chest.x, -20, 8, 0xffd700).setDepth(101);
  scene.tweens.add({
    targets: coin,
    y: chest.y - chest.height / 2,
    duration: 800,
    ease: 'Cubic.easeIn',
    onComplete: () => {
      coin.destroy();
      openChest(scene);
    },
  });
}

function spawnFameCoin(scene) {
  const coin = scene.add.circle(chest.x, -20, 8, 0x88ffff).setDepth(101);
  scene.tweens.add({
    targets: coin,
    y: chest.y - chest.height / 2,
    duration: 800,
    ease: 'Cubic.easeIn',
    onComplete: () => {
      coin.destroy();
      openChest(scene);
    },
  });
}

function openChest(scene) {
  chest.setFillStyle(0xdaa520);
  scene.time.delayedCall(300, () => chest.setFillStyle(0x8b4513));
}

function pickClass() {
  const total = classes.reduce((s, c) => s + c.weight, 0);
  let r = Phaser.Math.Between(1, total);
  for (const c of classes) {
    r -= c.weight;
    if (r <= 0) return c;
  }
  return classes[0];
}

function preload() {
  this.load.image('logo', 'logo.png');
  this.load.image('shop', 'shop.png');
  this.load.image('platform', 'platform.png');
  this.load.image('executionerHead', 'executionerhead.png');
  this.load.image('executionerBody', 'executionerbody.png');
  this.load.image('escortHead', 'escorthead.png');
  this.load.image('escortBody', 'escortbody.png');
  this.load.image('signTravel', 'sign_travel.png');
  this.load.image('signStorage', 'sign_storage.png');
  this.load.image('signWeapons', 'sign_weapons.png');
  this.load.image('signClose', 'sign_close.png');
  this.load.image('mapNorth', 'map_north.png');
  this.load.image('mapSouth', 'map_south.png');
  this.load.image('backgroundTravel', 'background_travel1.png');
  // Storage upgrade assets
  this.load.image('backgroundStorage', 'background_storage.png');
  this.load.image('upgradeButton', 'upgrade_button.png');
  for (let i = 1; i <= 16; i++) {
    this.load.image(`storage${i}`, `storage_${i}.png`);
  }
  // Weapons upgrade assets
  this.load.image('backgroundWeapons', 'background_weapons.png');
  for (let i = 1; i <= 30; i++) {
    this.load.image(`weapons${i}`, `weapons${i}.png`);
  }
  this.load.image('background', 'background.png');
  this.load.image('backgroundSky', 'background_bluesky.png');
  this.load.image('prisonerHead1', 'prisonerhead.png');
  this.load.image('prisonerBody1', 'prisonerbody.png');
  this.load.image('prisonerHead2', 'prisonerhead2.png');
  this.load.image('prisonerBody2', 'prisonerbody2.png');
  this.load.image('prisonerHead3', 'prisonerhead3.png');
  this.load.image('prisonerBody3', 'prisonerbody3.png');
  this.load.image('priestHead', 'prisonerhead_priest.png');
  this.load.image('priestBody', 'prisonerbody_priest.png');
  this.load.image('jesterHead1', 'jesterhead.png');
  this.load.image('jesterBody1', 'jesterbody.png');
  this.load.image('jesterHead2', 'jesterhead2.png');
  this.load.image('jesterBody2', 'jesterbody2.png');
  this.load.image('jesterHead3', 'jesterhead3.png');
  this.load.image('jesterBody3', 'jesterbody3.png');
  this.load.image('jesterHead4', 'jesterhead4.png');
  this.load.image('jesterBody4', 'jesterbody4.png');
  this.load.image('birdBlackLeft', 'bird_black_left.png');
  this.load.image('birdBlackRight', 'bird_black_right.png');
  this.load.image('birdWhiteLeft', 'bird_white_left.png');
  this.load.image('birdWhiteRight', 'bird_white_right.png');
  // Load city backgrounds using explicit file mappings to handle inconsistent
  // naming.
  Object.entries(cityBackgrounds).forEach(([name, file]) => {
    const key = `background-${name.toLowerCase()}`;
    this.load.image(key, file);
  });
  // Load dedicated travel backgrounds.
  travelBackgrounds.forEach((file, i) => {
    const key = `background-travel${i + 1}`;
    this.load.image(key, file);
  });
}

function create() {
  const scene = this;

  // Background and stage art
  skyRect = scene.add.image(400, 300, 'backgroundSky');
  skyRect.setDisplaySize(800, 600);
  // Render sky behind celestial bodies
  skyRect.setDepth(-5);

  backgroundRect = scene.add.image(400, 300, 'background');
  backgroundRect.setDisplaySize(800, 600);
  backgroundRect.setDepth(-2);
  // Apply the initial background for the starting city
  updateBackground(scene);

  // Parallax cloud layers
  if (FEATURES.clouds) {
    const gfx = scene.make.graphics({ x: 0, y: 0, add: false });
    // draw a more detailed small cloud with subtle shading
    gfx.fillStyle(0xdddddd, 0.6);
    gfx.fillEllipse(50, 45, 60, 20);
    gfx.fillStyle(0xffffff, 0.9);
    gfx.fillCircle(30, 30, 20);
    gfx.fillCircle(50, 20, 25);
    gfx.fillCircle(70, 30, 20);
    gfx.fillCircle(40, 40, 18);
    gfx.fillCircle(60, 40, 18);
    gfx.generateTexture('cloud-small', 100, 60);
    gfx.clear();
    // draw a more detailed large cloud
    gfx.fillStyle(0xdddddd, 0.6);
    gfx.fillEllipse(70, 45, 80, 25);
    gfx.fillStyle(0xffffff, 0.9);
    gfx.fillCircle(40, 30, 25);
    gfx.fillCircle(70, 20, 35);
    gfx.fillCircle(100, 30, 25);
    gfx.fillCircle(55, 45, 20);
    gfx.fillCircle(85, 45, 20);
    gfx.generateTexture('cloud-big', 140, 60);
    gfx.destroy();

    cloudLayerFar = scene.add.group();
    cloudLayerNear = scene.add.group();

    for (let i = 0; i < 5; i++) {
      const cloud = scene.add.image(
        Phaser.Math.Between(0, config.width),
        Phaser.Math.Between(20, CLOUD_AREA_HEIGHT),
        'cloud-small'
      );
      cloud.setDepth(-3);
      cloud.setTint(0x888888);
      cloud.setAlpha(Phaser.Math.FloatBetween(0.3, 0.5));
      cloud.setScale(Phaser.Math.FloatBetween(0.8, 1.2));
      cloudLayerFar.add(cloud);
    }

    for (let i = 0; i < 3; i++) {
      const cloud = scene.add.image(
        Phaser.Math.Between(0, config.width),
        Phaser.Math.Between(40, CLOUD_AREA_HEIGHT),
        'cloud-big'
      );
      cloud.setDepth(-1);
      cloud.setAlpha(Phaser.Math.FloatBetween(0.6, 0.9));
      cloud.setScale(Phaser.Math.FloatBetween(0.8, 1.2));
      cloudLayerNear.add(cloud);
    }
  }

  // Initialize day/night cycle
  this.dayNight = new DayNightCycle({ dayLengthSeconds: 180 });
  // Place the lighting overlay just above the background so gameplay and
  // UI elements remain on top and unaffected by the darkening effect.
  this.dayNight.init(scene, { backCloudsDepth: -3, overlayDepth: -1.5 });
  this.dayNight.onFullDay(() => { advanceCalendarDays(1); });
  // Only begin a new execution round if the player isn't already interacting
  // with the swing meter. This prevents the meter from resetting unexpectedly
  // while awaiting input.
  this.dayNight.onHourlyExecution(() => {
    if (gameStarted && !swingActive && !awaitingAngle && !awaitingPower && !betweenSwings) {
      startExecutionRound();
    }
  });

  stage = scene.add.image(400, 520, 'platform').setDepth(0);
  stageBlood = scene.add.rectangle(400, 520, 1, 10, 0x770000)
    .setOrigin(0.5, 1)
    .setVisible(false)
    .setDepth(0.4);
  // Overlay that only dims the background behind characters
  backgroundFadeOverlay = scene.add.rectangle(400, 300, 800, 600, 0x000000, 1)
    .setDepth(-1)
    .setAlpha(0)
    .setVisible(false);

  // Overlay used for fading the entire screen during menus and transitions.
  screenFadeOverlay = scene.add.rectangle(400, 300, 800, 600, 0x000000, 1)
    .setDepth(29)
    .setAlpha(0)
    .setVisible(false);



  // Executioner, starts off-screen and walks in on first spawn
  // Place him behind the prisoner but in front of the background
  executioner = scene.add.container(400, 460).setDepth(0.5);
  executionerWeapon = scene.add.image(0, -20, `weapons${player.weaponLevel}`)
    .setOrigin(0.5)
    .setAngle(135);
  const execBody = scene.add.image(0, 50, 'executionerBody')
    .setOrigin(0.5, 1);
  const execHead = scene.add.image(0, -30, 'executionerHead')
    .setOrigin(0.5, 0.5);
  executioner.add([executionerWeapon, execBody, execHead]);
  executioner.setVisible(false);

  // Condemned figure with separate head and body
  prisoner = scene.add.container(400, 460).setDepth(1);
  // Pivot the body around the feet so it can topple realistically
  // Position it so the top still aligns with the neck
  prisonerBody = scene.add.image(0, 50, prisonerBodyKey)
    .setOrigin(0.5, 1);
  prisonerHead = scene.add.container(0, -20);
  prisonerHeadSprite = scene.add.image(0, 0, prisonerHeadKey).setOrigin(0.5);
  prisonerHead.add(prisonerHeadSprite);
  // Aim arrow points upward for angle selection
  // Larger arrow for angle and power selection
  aimArrow = scene.add.triangle(0, -25, 0, -40, -12, 0, 12, 0, 0xffff00)
    .setOrigin(0.5, 1)
    .setVisible(false);
  prisonerHead.add(aimArrow);
  prisoner.add([prisonerBody, prisonerHead]);
  prisoner.setVisible(false);

  // Escort guards
  leftEscort = scene.add.container(0, 0);
  const leftBody = scene.add.image(0, 50, 'escortBody')
    .setOrigin(0.5, 1);
  const leftHead = scene.add.image(0, -20, 'escortHead')
    .setOrigin(0.5, 0.5);
  leftEscort.add([leftBody, leftHead]);
  rightEscort = scene.add.container(0, 0);
  const rightBody = scene.add.image(0, 50, 'escortBody')
    .setOrigin(0.5, 1);
  const rightHead = scene.add.image(0, -20, 'escortHead')
    .setOrigin(0.5, 0.5);
  rightEscort.add([rightBody, rightHead]);
  leftEscort.setVisible(false);
  rightEscort.setVisible(false);

  // Gold chest and counters
  chest = scene.add.rectangle(config.width - 60, config.height - 40, 80, 50, 0x8b4513)
    .setOrigin(0.5, 1)
    .setDepth(100)
    .setVisible(false);
  goldText = scene.add.text(chest.x, chest.y - 2, formatGold(player.gold), { font: '20px monospace', fill: '#ffff88' })
    .setOrigin(0.5, 1)
    .setDepth(101)
    .setScrollFactor(0)
    .setVisible(false);
  goldText.setStroke('#000000', 4);
  fameText = scene.add.text(chest.x, chest.y - 26, '0', { font: '20px monospace', fill: '#88ffff' })
    .setOrigin(0.5, 1)
    .setDepth(101)
    .setScrollFactor(0)
    .setVisible(false);
  fameText.setStroke('#000000', 4);
  missText = scene.add.text(16, 64, 'Misses: 0', { font: '20px monospace', fill: '#ff8888' })
    .setDepth(100)
    .setScrollFactor(0)
    .setVisible(false);
  missText.setY(missText.y + 50);
  killText = scene.add.text(16, 88, 'Kills: 0', { font: '20px monospace', fill: '#ffffff' })
    .setDepth(100)
    .setScrollFactor(0)
    .setVisible(false);
  killText.setY(killText.y + 50);
  // Hide the old weather label at the top
  weatherText = scene.add.text(400, 96, '', { font: '20px monospace', fill: '#ffffff' })
    .setOrigin(0.5, 0)
    .setDepth(50)
    .setVisible(false);
  weatherText.setY(weatherText.y + 50);
  weatherIndicatorBg = scene.add.circle(25, 571, 24, 0x000000)
    .setOrigin(0.5)
    .setDepth(49)
    .setVisible(false);
  weatherIndicator = scene.add.text(25, 571, '', { font: '20px monospace', fill: '#ffffff' })
    .setOrigin(0.5)
    .setDepth(50)
    .setVisible(false);

  // Debug cheat: hold the weather icon for 10 seconds to gain resources
  let weatherHoldEvent = null;
  function cancelWeatherHold() {
    if (weatherHoldEvent) {
      weatherHoldEvent.remove(false);
      weatherHoldEvent = null;
    }
  }
  [weatherIndicatorBg, weatherIndicator].forEach(icon => {
    icon.setInteractive();
    icon.on('pointerdown', () => {
      cancelWeatherHold();
      weatherHoldEvent = scene.time.delayedCall(10000, () => {
        addGold(scene, 3000000);
        fame += 10000;
        fameText.setText(formatGold(Math.floor(fame)));
        level = 100;
        xp = 0;
        xpThreshold = 10;
        for (let i = 1; i < level; i++) {
          xpThreshold = Math.floor(xpThreshold * 1.15);
        }
        updateXPUI();
        updateTravelUI(scene);
        weatherHoldEvent = null;
      });
    });
    icon.on('pointerup', cancelWeatherHold);
    icon.on('pointerout', cancelWeatherHold);
  });
  locationText = scene.add.text(400, 16, currentCity, { font: '20px monospace', fill: '#ffffff' })
    .setOrigin(0.5, 0)
    .setVisible(false);
  locationText.setY(locationText.y + 50);
  dateBg = scene.add.rectangle(400, 52, 80, 28, 0xffffff)
    .setOrigin(0.5)
    .setDepth(49)
    .setVisible(false);
  dateBg.setY(dateBg.y + 50);
  dateText = scene.add.text(400, 52, getDateString(), { font: '16px monospace', fill: '#000000' })
    .setOrigin(0.5)
    .setDepth(50)
    .setVisible(false);
  dateText.setY(dateText.y + 50);
  xpText = scene.add.text(400, 580, 'Level 1 - 0/10 XP', { font: '20px monospace', fill: '#88ff88' })
    .setOrigin(0.5, 1)
    .setDepth(100)
    .setScrollFactor(0)
    .setVisible(false);
  xpBarFill = scene.add.rectangle(250, 584, 0, 12, 0x00ff00)
    .setOrigin(0, 1)
    .setDepth(100)
    .setScrollFactor(0)
    .setVisible(false);
  updateXPUI();
  streakMultiplierText = scene.add.text(460, 520, 'x0', { font: '48px monospace', fill: '#ff0000' })
    .setOrigin(0.5, 1)
    .setDepth(2)
    .setStroke('#000000', 4);
  versionText = scene.add.text(790, 590, VERSION, { font: '14px monospace', fill: '#ffffff' })
    .setOrigin(1, 1)
    .setDepth(11);


  // Logo drop animation before showing the start screen
  // Ensure the logo appears above the start screen background
  logoContainer = scene.add.container(400, -200).setDepth(200);
  const rope = scene.add.rectangle(0, 0, 12, 125, 0xffffff)
    .setOrigin(0.5, 0);
  const logo = scene.add.image(0, 125, 'logo')
    .setOrigin(513 / 1024, 127 / 1024)
    .setScale(0.5);
  logoContainer.add([rope, logo]);
  scene.tweens.add({
    targets: logoContainer,
    y: 0,
    ease: 'Bounce',
    duration: 600,
    onComplete: () => {
      scene.tweens.timeline({
        targets: logoContainer,
        tweens: [
          { angle: { from: -15, to: 15 }, duration: 300, yoyo: true, ease: 'Sine.easeInOut' },
          { angle: { from: -10, to: 10 }, duration: 400, yoyo: true, ease: 'Sine.easeInOut' },
          { angle: { from: -5, to: 5 }, duration: 500, yoyo: true, ease: 'Sine.easeInOut' },
          { angle: 0, duration: 600, ease: 'Sine.easeInOut' }
        ]
      });
    }
  });

  // Start screen
  startContainer = scene.add.container(0, 0).setDepth(12);
  const startBg = scene.add.rectangle(400, 300, 800, 600, 0x000000, 1)
    .setDepth(10)
    .setInteractive();
  const startText = scene.add.text(400, 560, '[ CLICK TO PLAY ]', { font: '32px monospace', fill: '#ffffff' })
    .setOrigin(0.5)
    .setDepth(10)
    .setVisible(false)
    .setInteractive();

  function beginGame() {
    scene.tweens.add({
      targets: startContainer,
      alpha: 0,
      duration: 500,
      onComplete: () => {
        startContainer.setVisible(false);
        startContainer.setAlpha(1);
        logoContainer.setVisible(false);
        weatherIndicatorBg.setVisible(true);
        weatherIndicator.setVisible(true);
        dateBg.setVisible(true);
        dateText.setVisible(true);
        locationText.setVisible(true);
        fameText.setVisible(true);
        missText.setVisible(true);
        killText.setVisible(true);
        xpText.setVisible(true);
        xpBarFill.setVisible(true);
        setGoldChestVisible(true);
        gameStarted = true;
        if (executionerIntro) {
          introExecutioner(scene, () => spawnPrisoner(scene, false));
        } else {
          spawnPrisoner(scene, false);
        }
      }
    });
  }

  startBg.on('pointerdown', beginGame);
  startText.on('pointerdown', beginGame);
  startContainer.add([startBg, startText]);
  startContainer.setVisible(true);

  scene.time.delayedCall(3000, () => {
    startText.setVisible(true);
  });

  // Swing meter base
  const meterY = 550;
  swingBar = scene.add.rectangle(400, meterY, 300, 20, 0x333333).setVisible(false);
  redZone = scene.add.rectangle(400, meterY, baseSizes.red, 20, 0xff0000).setVisible(false);
  yellowZone = scene.add.rectangle(400, meterY, baseSizes.yellow, 20, 0xffff00).setVisible(false);
  greenZone = scene.add.rectangle(400, meterY, baseSizes.green, 20, 0x00ff00).setVisible(false);
  cursor = scene.add.rectangle(250, meterY, 10, 20, 0xffffff).setVisible(false);

  // Blood pool
  bloodPool = scene.add.rectangle(400, 600, 800, 1, 0x770000)
    .setOrigin(0.5, 1)
    .setVisible(false)
    // Render in front of heads so they appear to sink into the pool
    .setDepth(0.9);

  // Blood particle emitter
  const g = scene.add.graphics();
  g.fillStyle(0xff0000, 1);
  g.fillCircle(2, 2, 2);
  g.generateTexture('blood', 4, 4);
  g.destroy();
  const particles = scene.add.particles('blood').setDepth(1);
  bloodEmitter = particles.createEmitter({
    speed: { min: 150, max: 250 },
    angle: { min: 260, max: 280 }, // shoot upward like a fountain
    gravityY: 400,
    lifespan: 800,
    scale: { start: 1, end: 0 },
    quantity: 0,
    on: false
  });
  headEmitter = particles.createEmitter({
    speed: { min: 180, max: 280 },
    angle: { min: 80, max: 100 }, // downward from flying head
    gravityY: 400,
    lifespan: 1000,
    frequency: 20,
    scale: { start: 1, end: 0 },
    quantity: 0,
    on: false
  });
  dripEmitter = particles.createEmitter({
    speed: { min: 20, max: 40 },
    angle: 90,
    gravityY: 300,
    lifespan: 1000,
    scale: { start: 0.5, end: 0 },
    quantity: 0,
    on: false
  });
  splatEmitter = particles.createEmitter({
    speed: { min: 100, max: 200 },
    angle: { min: 240, max: 300 },
    gravityY: 400,
    lifespan: 800,
    scale: { start: 1, end: 0 },
    quantity: 0,
    on: false
  });
  bloodFireworkEmitter = particles.createEmitter({
    speed: { min: 150, max: 250 },
    angle: { min: 0, max: 360 },
    gravityY: 400,
    lifespan: 800,
    scale: { start: 1, end: 0 },
    quantity: 0,
    on: false
  });
  const gSpark = scene.add.graphics();
  gSpark.fillStyle(0xffcc00, 1);
  gSpark.fillCircle(2, 2, 2);
  gSpark.generateTexture('spark', 4, 4);
  gSpark.destroy();
  const fwParts = scene.add.particles('spark').setDepth(5);
  fireworkEmitter = fwParts.createEmitter({
    speed: { min: 150, max: 250 },
    angle: { min: 250, max: 290 },
    gravityY: 200,
    lifespan: 1000,
    scale: { start: 1, end: 0 },
    blendMode: 'ADD',
    quantity: 0,
    on: false
  });
  const gPix = scene.add.graphics();
  gPix.fillStyle(0xffffff, 1);
  gPix.fillRect(0, 0, 2, 2);
  gPix.generateTexture('pixel', 2, 2);
  gPix.destroy();
  const fwCloseParts = scene.add.particles('pixel').setDepth(6);
  fireworkCloseEmitter = fwCloseParts.createEmitter({
    speed: { min: 20, max: 60 },
    lifespan: 600,
    scale: { start: 1, end: 0 },
    blendMode: 'ADD',
    quantity: 0,
    on: false
  });

  // Weather particle textures
  const gWeather = scene.add.graphics();
  gWeather.fillStyle(0x99ccff, 1);
  gWeather.fillRect(0, 0, 2, 10);
  gWeather.generateTexture('raindrop', 2, 10);
  gWeather.clear();
  gWeather.fillStyle(0xffffff, 0.6);
  gWeather.fillRect(0, 0, 20, 8);
  gWeather.generateTexture('fog', 20, 8);
  gWeather.destroy();
  // Place weather effects behind UI overlays so menus appear on top
  rainParts = scene.add.particles('raindrop').setDepth(28);
  rainEmitter = rainParts.createEmitter({
    x: { min: 0, max: 800 },
    y: 0,
    lifespan: 800,
    speedY: { min: 400, max: 600 },
    quantity: 15,
    frequency: 100,
    on: false
  });
  fogParts = scene.add.particles('fog').setDepth(28);
  fogEmitter = fogParts.createEmitter({
    x: { min: -50, max: 850 },
    y: { min: 300, max: 580 },
    lifespan: 6000,
    speedX: { min: -20, max: 20 },
    speedY: { min: -5, max: 5 },
    quantity: 6,
    alpha: { start: 0.8, end: 0.1 },
    on: false
  });

  const windG = scene.add.graphics();
  windG.fillStyle(0x996633, 1);
  windG.fillCircle(2, 2, 2);
  windG.generateTexture('leaf', 4, 4);
  windG.destroy();
  windParts = scene.add.particles('leaf').setDepth(28);
  windEmitter = windParts.createEmitter({
    lifespan: 4000,
    // Increase particle output dramatically so the wind effect is visible
    quantity: 10,
    frequency: 20,
    scale: { start: 1, end: 0 },
    rotate: { min: -180, max: 180 },
    on: false
  });



  // Physics group to accumulate fallen bodies
  bodyGroup = scene.physics.add.group();
  // Targets should remain stationary until hit
  targetGroup = scene.physics.add.group({
    allowGravity: false,
    immovable: true
  });
  scene.physics.add.overlap(prisonerHead, targetGroup, (_, target) => {
    handleTargetHit(scene, target, prisonerHead);
  });
  // Enable collisions between bodies so they pile up
  scene.physics.add.collider(bodyGroup, bodyGroup);
  // Stop corpses completely after two bounces
  scene.physics.world.on('worldbounds', (body, up, down) => {
    const obj = body.gameObject;
    if (!obj || !obj.isCorpse) return;
    if (down) {
      if (obj.jester && !obj.jester.running) {
        obj.jester.running = true;
        const offX = obj.jester.startFromRight ? 900 : -100;
        obj.scene.tweens.add({
          targets: obj.jester,
          x: offX,
          duration: 1500,
          ease: 'Linear',
          onComplete: () => obj.jester.destroy()
        });
      }
      obj.bounceCount = (obj.bounceCount || 0) + 1;
      if (obj.bounceCount >= 2) {
        // Lay the corpse on its side most of the time
        if (Math.random() < 0.9) {
          const sign = Math.random() < 0.5 ? -1 : 1;
          obj.setRotation(sign * Phaser.Math.DegToRad(90));
        }

        body.setBounce(0);
        body.setVelocity(0, 0);
        body.setAngularVelocity(0);
        body.setAllowGravity(false);
        body.setImmovable(true);
        body.moves = false;

        // Disable physics so the frozen body no longer collides
        obj.scene.physics.world.disable(obj);
      }
    }
  });

  scene.time.addEvent({
    delay: 400,
    loop: true,
    callback: () => {
      if (stageBlood.visible && stageBlood.displayWidth > 0) {
        const half = stageBlood.displayWidth / 2;
        const x = Phaser.Math.Between(stageBlood.x - half, stageBlood.x + half);
        dripEmitter.emitParticleAt(x, stageBlood.y, 1);
      }
    }
  });

  scene.time.addEvent({
    delay: 2000,
    loop: true,
    callback: () => {
      bodyGroup.getChildren().forEach(obj => {
        if (obj.isCorpse && (!obj.body || !obj.body.enable)) {
          if (Phaser.Math.Between(0, 100) < 5) {
            splatEmitter.explode(5, obj.x, obj.y);
          }
        }
      });
    }
  });

  
  // Storage and weapons signs
  storageButton = scene.add.image(0, 0, 'signStorage')
    .setOrigin(0, 0)
    .setDisplaySize(107, 71)
    .setInteractive()
    .on('pointerdown', () => { toggleStorage(scene); });
  weaponsButton = scene.add.image(120, 0, 'signWeapons')
    .setOrigin(0, 0)
    .setDisplaySize(107, 71)
    .setInteractive()
    .on('pointerdown', () => { toggleWeapons(scene); });

  // Shop button
  // Move the shop button slightly right to make room for the travel sign
  shopButton = scene.add.image(800, 0, 'shop')
    .setOrigin(1, 0)
    .setDisplaySize(107, 71)
    .setInteractive()
    .on('pointerdown', () => {
      toggleShop(scene);
    });

  // Travel button
  travelButton = scene.add.image(680, 0, 'signTravel')
    .setOrigin(1, 0)
    .setDisplaySize(107, 71)
    .setInteractive()
    .on('pointerdown', () => { toggleTravel(scene); });

  // Storage upgrade container and overlay
  storageOverlay = scene.add.rectangle(400, 300, 800, 600, 0x000000, 0)
    .setVisible(false)
    .setDepth(30);
  storageContainer = scene.add.container(0, 0).setVisible(false).setDepth(31);
  const storageSky = scene.add.image(400, 300, 'backgroundSky')
    .setDisplaySize(800, 600);
  const storageBg = scene.add.image(400, 300, 'backgroundStorage')
    .setDisplaySize(800, 600);
  storageImage = scene.add.image(400, 560, `storage${player.storageLevel}`)
    .setOrigin(0.5, 1);
  storageCostText = scene.add.text(400, 250, '', { font: '24px monospace', fill: '#ffd700' })
    .setOrigin(0.5)
    .setStroke('#000000', 3);
  upgradeButton = scene.add.image(400, 290, 'upgradeButton')
    .setOrigin(0.5, 0)
    .setScale(0.5)
    .setInteractive()
    .on('pointerdown', () => { upgradeStorage(scene); });
  const storageClose = scene.add.image(700, 0, 'signClose')
    .setOrigin(0, 0)
    .setDisplaySize(100, 100)
    .setInteractive()
    .on('pointerdown', () => { toggleStorage(scene); });
  storageContainer.add([storageSky, storageBg, storageImage, upgradeButton, storageCostText, storageClose]);
  updateStorageUI();

  // Weapons upgrade container and overlay
  weaponsOverlay = scene.add.rectangle(400, 300, 800, 600, 0x000000, 0)
    .setVisible(false)
    .setDepth(30);
  weaponsContainer = scene.add.container(0, 0).setVisible(false).setDepth(31);
  const weaponsSky = scene.add.image(400, 300, 'backgroundSky')
    .setDisplaySize(800, 600);
  const weaponsBg = scene.add.image(400, 300, 'backgroundWeapons')
    .setDisplaySize(800, 600);
  weaponsImage = scene.add.image(400, 300, `weapons${player.weaponLevel}`)
    .setOrigin(0.5);
  weaponsCostText = scene.add.text(400, 360, '', { font: '24px monospace', fill: '#ffd700' })
    .setOrigin(0.5)
    .setStroke('#000000', 3);
  weaponUpgradeButton = scene.add.image(400, 420, 'upgradeButton')
    .setOrigin(0.5, 0)
    .setScale(0.5)
    .setInteractive()
    .on('pointerdown', () => { upgradeWeapon(scene); });
  weaponQuoteText = scene.add.text(400, 300, '', {
    font: '20px monospace',
    fill: '#ffaaaa',
    wordWrap: { width: 300 }
  }).setOrigin(0.5)
    .setStroke('#000000', 3);
  weaponQuoteBubble = scene.add.rectangle(400, 300, 10, 10, 0xffffff, 1)
    .setOrigin(0.5)
    .setStrokeStyle(2, 0x000000);
  const wqBody = scene.add.image(0, 0, 'prisonerBody1').setOrigin(0.5, 1).setScale(1);
  const wqHead = scene.add.image(0, -80, 'prisonerHead1').setOrigin(0.5).setScale(1);
  weaponPeasant = scene.add.container(0, 0, [wqBody, wqHead]);
  const weaponsClose = scene.add.image(700, 0, 'signClose')
    .setOrigin(0, 0)
    .setDisplaySize(100, 100)
    .setInteractive()
    .on('pointerdown', () => { toggleWeapons(scene); });
  weaponsContainer.add([weaponsSky, weaponsBg, weaponsImage, weaponUpgradeButton, weaponsCostText, weaponQuoteBubble, weaponQuoteText, weaponPeasant, weaponsClose]);
  updateWeaponsUI();

  // Travel container and overlay
  travelOverlay = scene.add.rectangle(400, 300, 800, 600, 0x000000, 0)
    .setVisible(false)
    .setDepth(200);
  travelContainer = scene.add.container(0, 0).setVisible(false).setDepth(201);
  const travelSky = scene.add.image(400, 300, 'backgroundSky')
    .setDisplaySize(800, 600);
  const travelBg = scene.add.image(400, 300, 'backgroundTravel')
    .setDisplaySize(800, 600);
  travelList = scene.add.container(0, 0);
  travelContainer.add([travelSky, travelBg, travelList]);
  travelRegion = null;
  showTravelMenu(scene);
  const travelClose = scene.add.image(700, 0, 'signClose')
    .setOrigin(0, 0)
    .setDisplaySize(100, 100)
    .setInteractive()
    .on('pointerdown', () => { toggleTravel(scene); });
  travelContainer.add(travelClose);
  updateTravelUI(scene);

  // Shop container and overlay
  shopOverlay = scene.add.rectangle(400, 300, 800, 600, 0x000000, 0)
    .setVisible(false)
    .setDepth(200);
  shopContainer = scene.add.container(0, 0).setVisible(false).setDepth(201);
  const shopSky = scene.add.image(400, 300, 'backgroundSky')
    .setDisplaySize(800, 600);
  const shopBg = scene.add.image(400, 300, 'backgroundTravel')
    .setDisplaySize(800, 600);
  // Position the market items list a bit higher so all entries are visible
  const marketList = scene.add.container(60, 130);
  shopContainer.add([shopSky, shopBg, marketList]);

  // Market items displayed as a table
  let itemY = 0;
  const cols = {
    name: 10,
    buy: 220,
    sell: 300,
    stock: 370,
    qty: 440,
    buyBtn: 510,
    sellBtn: 580
  };
  // Header row
  const headItem = scene.add.text(cols.name, itemY, 'Item', { font: '18px monospace', fill: '#ffffaa' })
    .setStroke('#000000', 3);
  const headBuy = scene.add.text(cols.buy, itemY, 'Buy', { font: '18px monospace', fill: '#ffffaa' })
    .setStroke('#000000', 3);
  const headSell = scene.add.text(cols.sell, itemY, 'Sell', { font: '18px monospace', fill: '#ffffaa' })
    .setStroke('#000000', 3);
  const headStock = scene.add.text(cols.stock, itemY, 'Stock', { font: '18px monospace', fill: '#ffffaa' })
    .setStroke('#000000', 3);
  const headQty = scene.add.text(cols.qty, itemY, 'Qty', { font: '18px monospace', fill: '#ffffaa' })
    .setStroke('#000000', 3);
  marketList.add([headItem, headBuy, headSell, headStock, headQty]);
  itemY += 25;
  const city = cities.find(c => c.name === currentCity);
  marketItems.forEach((m, idx) => {
    if (city && m.regions && !m.regions.includes(city.region)) return;
    const name = scene.add.text(cols.name, itemY, m.name, { font: '18px monospace', fill: '#ffffaa' })
      .setStroke('#000000', 3);
    const buyPrice = scene.add.text(cols.buy, itemY, '', { font: '18px monospace', fill: '#ffffaa' })
      .setStroke('#000000', 3);
    const sellPrice = scene.add.text(cols.sell, itemY, '', { font: '18px monospace', fill: '#ffffaa' })
      .setStroke('#000000', 3);
    const stockText = scene.add.text(cols.stock, itemY, '', { font: '18px monospace', fill: '#ffffaa' })
      .setStroke('#000000', 3);
    const qtyText = scene.add.text(cols.qty, itemY, '', { font: '18px monospace', fill: '#ffffaa' })
      .setStroke('#000000', 3);
    const buyBtn = scene.add.text(cols.buyBtn, itemY, '[Buy]', { font: '18px monospace', fill: '#00ff00' })
      .setStroke('#000000', 3)
      .setInteractive()
      .on('pointerdown', () => { showTradeMenu(scene, idx, 'buy'); });
    const sellBtn = scene.add.text(cols.sellBtn, itemY, '[Sell]', { font: '18px monospace', fill: '#00ff00' })
      .setStroke('#000000', 3)
      .setInteractive()
      .on('pointerdown', () => { showTradeMenu(scene, idx, 'sell'); });
    marketList.add([name, buyPrice, sellPrice, stockText, qtyText, buyBtn, sellBtn]);
    m.ui = { name, buyPrice, sellPrice, stockText, qtyText, buyBtn, sellBtn };
    itemY += 25;
  });
  marketChatterText = scene.add.text(400, 300, '', {
    font: '20px monospace',
    fill: '#ffaaaa',
    wordWrap: { width: 640 }
  }).setOrigin(0.5)
    .setStroke('#000000', 3);
  marketChatterBubble = scene.add.rectangle(400, 300, 10, 10, 0xffffff, 1)
    .setOrigin(0.5)
    .setStrokeStyle(2, 0x000000);
  const body = scene.add.image(0, 0, 'prisonerBody1').setOrigin(0.5, 1).setScale(1);
  const head = scene.add.image(0, -80, 'prisonerHead1').setOrigin(0.5).setScale(1);
  marketPrisoner = scene.add.container(0, 0, [body, head]);
  marketList.add([marketChatterBubble, marketChatterText, marketPrisoner]);

  const closeBtn = scene.add.image(700, 0, 'signClose')
    .setOrigin(0, 0)
    .setDisplaySize(100, 100)
    .setInteractive()
    .on('pointerdown', () => { toggleShop(scene); });
  shopContainer.add(closeBtn);

  // Trade menu overlay for buying and selling quantities
  tradeOverlay = scene.add.rectangle(400, 300, 800, 600, 0x000000, 0)
    .setVisible(false)
    // Use a depth above the shop container so this overlay appears on top
    .setDepth(202);
  tradeContainer = scene.add.container(120, 300).setVisible(false).setDepth(203);
  const tradeBg = scene.add.rectangle(0, 0, 560, 200, 0x222222, 1).setOrigin(0, 0);
  tradeBg.setStrokeStyle(2, 0xffffff);
  tradeTitle = scene.add.text(280, 10, '', { font: '18px monospace', fill: '#ffffaa' })
    .setOrigin(0.5, 0)
    .setStroke('#000000', 3);
  const b1 = scene.add.text(20, 50, '[Buy 1]', { font: '18px monospace', fill: '#00ff00' })
    .setStroke('#000000', 3)
    .setInteractive()
    .on('pointerdown', () => {
      const item = marketItems[tradeItemIndex];
      if (item.stock > 0) buyMarketItem(scene, tradeItemIndex, 1);
      hideTradeMenu(scene);
    });
  const b10 = scene.add.text(180, 50, '[Buy 10]', { font: '18px monospace', fill: '#00ff00' })
    .setStroke('#000000', 3)
    .setInteractive()
    .on('pointerdown', () => {
      const item = marketItems[tradeItemIndex];
      const qty = Math.min(10, item.stock);
      if (qty > 0) buyMarketItem(scene, tradeItemIndex, qty);
      hideTradeMenu(scene);
    });
  const bMax = scene.add.text(340, 50, '[Buy Max]', { font: '18px monospace', fill: '#00ff00' })
    .setStroke('#000000', 3)
    .setInteractive()
    .on('pointerdown', () => {
      const item = marketItems[tradeItemIndex];
      const goldMax = Math.floor(player.gold / item.currentBuy);
      const space = player.maxStorage - getInventoryCount();
      const max = Math.min(goldMax, space, item.stock);
      if (max > 0) buyMarketItem(scene, tradeItemIndex, max);
      hideTradeMenu(scene);
    });
  const s1 = scene.add.text(20, 90, '[Sell 1]', { font: '18px monospace', fill: '#00ff00' })
    .setStroke('#000000', 3)
    .setInteractive()
    .on('pointerdown', () => { sellMarketItem(scene, tradeItemIndex, 1); hideTradeMenu(scene); });
  const s10 = scene.add.text(180, 90, '[Sell 10]', { font: '18px monospace', fill: '#00ff00' })
    .setStroke('#000000', 3)
    .setInteractive()
    .on('pointerdown', () => { sellMarketItem(scene, tradeItemIndex, 10); hideTradeMenu(scene); });
  const sMax = scene.add.text(340, 90, '[Sell Max]', { font: '18px monospace', fill: '#00ff00' })
    .setStroke('#000000', 3)
    .setInteractive()
    .on('pointerdown', () => {
      const item = marketItems[tradeItemIndex];
      const max = inventory[item.name] || 0;
      if (max > 0) sellMarketItem(scene, tradeItemIndex, max);
      hideTradeMenu(scene);
    });
  const tradeClose = scene.add.image(440, 0, 'signClose')
    .setOrigin(0, 0)
    .setDisplaySize(100, 100)
    .setInteractive()
    .on('pointerdown', () => { hideTradeMenu(scene); });
  tradeContainer.add([tradeBg, tradeTitle, b1, b10, bMax, s1, s10, sMax, tradeClose]);
  tradeBuyBtns = [b1, b10, bMax];
  tradeSellBtns = [s1, s10, sMax];

  // Set up first day's prices and gossip
  dailyMarketUpdate();

  // Text popup
  scene.popupText = scene.add.text(400, 250, '', { font: '24px serif', fill: '#ffffff' })
    .setOrigin(0.5)
    .setVisible(false);

  // Input key for timing
  scene.input.keyboard.on('keydown-SPACE', () => {
    if (swingActive && inputEnabled) endSwing(scene);
  });
  scene.input.on('pointerdown', () => {
    if (awaitingAngle) {
      chooseAngle(scene);
    } else if (awaitingPower) {
      choosePower(scene);
    } else if (swingActive && inputEnabled) {
      endSwing(scene);
    }
  });

  // Targets spawn with each prisoner
}

let swingDirection = 1;

// Helper to fade the overlay that darkens the entire screen.
// Used for menu and travel fades.
let screenFadeTween = null;
function fadeScreenOverlay(scene, alpha, duration = 300, onComplete) {
  if (screenFadeTween) {
    screenFadeTween.stop();
  }
  screenFadeOverlay.setVisible(true);
  screenFadeTween = scene.tweens.add({
    targets: screenFadeOverlay,
    alpha,
    duration,
    onComplete: () => {
      screenFadeTween = null;
      if (alpha === 0) {
        screenFadeOverlay.setVisible(false);
      }
      if (onComplete) onComplete();
    }
  });
}

// Fade only the background layer for dramatic effects, e.g. executioner intro.
let backgroundFadeTween = null;
function fadeBackgroundOverlay(scene, alpha, duration = 300, onComplete) {
  if (backgroundFadeTween) {
    backgroundFadeTween.stop();
  }
  backgroundFadeOverlay.setVisible(true);
  backgroundFadeTween = scene.tweens.add({
    targets: backgroundFadeOverlay,
    alpha,
    duration,
    onComplete: () => {
      backgroundFadeTween = null;
      if (alpha === 0) {
        backgroundFadeOverlay.setVisible(false);
      }
      if (onComplete) onComplete();
    }
  });
}

function toggleShop(scene) {
  const visible = !shopContainer.visible;
  shopOverlay.setVisible(visible);
  shopContainer.setVisible(visible);
  setGoldChestVisible(!visible);
  if (dateBg) dateBg.setVisible(!visible);
  if (dateText) dateText.setVisible(!visible);
  if (xpText) xpText.setVisible(!visible);
  if (xpBarFill) xpBarFill.setVisible(!visible);
  if (visible) {
    // Fade the game behind the shop so it appears paused and dimmed
    fadeScreenOverlay(scene, 0.5);
    updateMarketUI();
    showMarketQuote(sellingQuotes);
    if (hideMeterEvent) {
      hideMeterEvent.remove(false);
      hideMeterEvent = null;
    }
    swingActive = false;
    inputEnabled = false;
    cursor.setVisible(false);
    // backOverlayWasVisible = backOverlay.visible;
    // backOverlay.setVisible(false);
    scene.physics.world.pause();
    scene.tweens.pauseAll();
    // Pausing the entire scene's time also halts input processing, which
    // prevented shop buttons from receiving pointer events.  We only pause
    // physics and tweens so the game action freezes while keeping the UI
    // responsive.
  } else {
    // backOverlay.setVisible(backOverlayWasVisible);
    // Remove the dim when closing the shop
    fadeScreenOverlay(scene, 0);
    scene.physics.world.resume();
    scene.tweens.resumeAll();
    // No need to unpause the Time plugin since we never fully pause it for the
    // shop overlay.
    releaseQueuedCoins(scene);
    startSwingMeter(scene);
  }
}

function buyWeapon(scene, index) {
  const w = weapons[index];
  if (w.purchased) return;
  if (player.gold >= w.cost) {
    player.gold -= w.cost;
    goldText.setText(formatGold(player.gold));
    zoneMods.red += w.effects.red || 0;
    zoneMods.yellow += w.effects.yellow || 0;
    zoneMods.green += w.effects.green || 0;
    updateZones();
    w.purchased = true;
    if (w.ui && w.ui.buy) {
      w.ui.buy.setText('Bought').disableInteractive();
    }
  }
}

function updateZones() {
  // Increase total meter width by 4 pixels per level (2 per end)
  const baseYellow = baseSizes.yellow + (player.weaponLevel - 1) * (4 / 3);
  const scale = baseYellow / baseSizes.yellow;
  const baseRed = baseSizes.red * scale;
  const baseGreen = baseSizes.green * scale;

  redZone.displayWidth = baseRed + zoneMods.red;
  yellowZone.displayWidth = baseYellow + zoneMods.yellow;
  greenZone.displayWidth = baseGreen + zoneMods.green;
}

// Switch between shop tabs and update highlights
// Purchase a fame boosting upgrade
function buyUpgrade(scene, index) {
  const u = gameUpgrades[index];
  if (u.purchased || fame < u.fameReq) return;
  if (player.gold >= u.cost) {
    player.gold -= u.cost;
    goldText.setText(formatGold(player.gold));
    fameMultiplier = u.mult;
    u.purchased = true;
    if (u.ui && u.ui.buy) {
      u.ui.buy.setText('Bought').disableInteractive();
    }
  }
}

// Buying from the trading market
function buyMarketItem(scene, index, qty = 1) {
  const item = marketItems[index];
  if (fame < item.fameReq) return;
  qty = Math.min(qty, item.stock || 0);
  const cost = item.currentBuy * qty;
  if (qty > 0 && player.gold >= cost && getInventoryCount() + qty <= player.maxStorage) {
    player.gold -= cost;
    goldText.setText(formatGold(player.gold));
    inventory[item.name] = (inventory[item.name] || 0) + qty;
    item.stock -= qty;
    updateMarketUI();
    showMarketQuote(sellingQuotes);
  }
}

// Selling items the player owns
function sellMarketItem(scene, index, qty = 1) {
  const item = marketItems[index];
  if ((inventory[item.name] || 0) >= qty) {
    inventory[item.name] -= qty;
    item.stock = (item.stock || 0) + qty;
    addGold(scene, item.currentSell * qty);
    updateMarketUI();
    showMarketQuote(buyingQuotes);
  }
}


// Update market text lines with prices and inventory
function updateMarketUI() {
  marketItems.forEach(m => {
    if (!m.ui) return;
    const qty = inventory[m.name] || 0;
    const locked = fame < m.fameReq;
    m.ui.name.setText(locked ? `${m.name} (F${m.fameReq})` : m.name);
    m.ui.buyPrice.setText(locked ? '-' : `${m.currentBuy}g`);
    m.ui.sellPrice.setText(locked ? '-' : `${m.currentSell}g`);
    m.ui.stockText.setText(locked ? '-' : m.stock);
    m.ui.qtyText.setText(qty);
    const canBuy = !locked && player.gold >= m.currentBuy && getInventoryCount() < player.maxStorage && m.stock > 0;
    const canSell = qty >= 1;
    m.ui.buyBtn.setFill(canBuy ? '#00ff00' : '#777777');
    m.ui.sellBtn.setFill(canSell ? '#00ff00' : '#777777');
  });
}

function updateTravelUI(scene) {
  cities.forEach(c => {
    if (!c.ui) return;
    const locked = !c.unlocked;
    const days = getTravelDays(currentCity, c.name);
    const title = c.name === currentCity ? c.name : `${c.name} — ${days} days`;
    c.ui.title.setText(title);
    if (c.name === currentCity) {
      c.ui.btn.setText('[Here]');
      c.ui.btn.setFill('#777777');
    } else if (locked) {
      const affordable = fame >= nextCityKeyCost;
      c.ui.btn.setText(`[Buy Key: ${nextCityKeyCost} Fame]`);
      c.ui.btn.setFill(affordable ? '#ffff00' : '#777777');
    } else {
      c.ui.btn.setText('[Go]');
      c.ui.btn.setFill('#00ff00');
    }
  });
}

function showTravelMenu(scene, region = travelRegion) {
  travelRegion = region;
  travelList.removeAll(true);
  cities.forEach(c => { if (c.ui) delete c.ui; });

  // If no region selected, present North/South options with placeholders
  if (!travelRegion) {
    const northPlaceholder = scene.add
      .image(200, 300, 'mapNorth')
      .setOrigin(0.5)
      .setDisplaySize(250, 400)
      .setInteractive()
      .on('pointerdown', () => showTravelMenu(scene, 'north'));
    const southPlaceholder = scene.add
      .image(600, 300, 'mapSouth')
      .setOrigin(0.5)
      .setDisplaySize(250, 400)
      .setInteractive()
      .on('pointerdown', () => showTravelMenu(scene, 'south'));
    const prompt = scene.add.text(400, 560, 'Where would you like to go?', { font: '24px monospace', fill: '#ffd700' })
      .setOrigin(0.5)
      .setStroke('#000000', 3);
    travelList.add([northPlaceholder, southPlaceholder, prompt]);
    return;
  }
  const regionCities = cities.filter(c => c.region === travelRegion);
  const totalCities = regionCities.length;
  regionCities.forEach((city, idx) => {
    const y = 120 + idx * 40;
    const title = scene.add.text(40, y, '', {
      font: '18px monospace',
      fill: '#ffffaa',
      wordWrap: { width: 320 }
    }).setStroke('#000000', 3);
    const btn = scene.add.text(240, y, '[Go]', {
      font: '18px monospace',
      fill: '#00ff00'
    })
      .setStroke('#000000', 3)
      .setInteractive()
      .on('pointerdown', () => {
        if (!city.unlocked) {
          if (fame >= nextCityKeyCost) {
            fame -= nextCityKeyCost;
            fameText.setText(formatGold(Math.floor(fame)));
            city.unlocked = true;
            nextCityKeyCost += 10;
            updateTravelUI(scene);
          }
          return;
        }
        travelToCity(scene, city);
      });
    travelList.add([title, btn]);
    city.ui = { title, btn };
  });

  const backBtn = scene.add.text(40, 120 + totalCities * 40 + 10, '[Back]', {
    font: '18px monospace',
    fill: '#ffff00'
  })
    .setStroke('#000000', 3)
    .setInteractive()
    .on('pointerdown', () => showTravelMenu(scene, null));
  travelList.add(backBtn);

  updateTravelUI(scene);
}

function toggleTravel(scene, resume = true, withFade = true) {
  const visible = !travelContainer.visible;
  travelOverlay.setVisible(visible);
  travelContainer.setVisible(visible);
  setGoldChestVisible(!visible);
  if (dateBg) dateBg.setVisible(!visible);
  if (dateText) dateText.setVisible(!visible);
  if (xpText) xpText.setVisible(!visible);
  if (xpBarFill) xpBarFill.setVisible(!visible);
  if (visible) {
    // Dim the background while the travel menu is open
    if (withFade) fadeScreenOverlay(scene, 0.5);
    travelRegion = null;
    showTravelMenu(scene);
    updateTravelUI(scene);
    if (hideMeterEvent) {
      hideMeterEvent.remove(false);
      hideMeterEvent = null;
    }
    swingActive = false;
    inputEnabled = false;
    cursor.setVisible(false);
    scene.physics.world.pause();
    scene.tweens.pauseAll();
    storageButton.disableInteractive();
    shopButton.disableInteractive();
    weaponsButton.disableInteractive();
    travelButton.disableInteractive();
    // Do not pause the global time system; doing so disables input events and
    // breaks the travel and shop interfaces.  Physics and tweens are paused to
    // freeze gameplay while menus are open.
  } else {
    if (withFade) fadeScreenOverlay(scene, 0);
    scene.physics.world.resume();
    scene.tweens.resumeAll();
    storageButton.setInteractive();
    shopButton.setInteractive();
    weaponsButton.setInteractive();
    travelButton.setInteractive();
    // Time was never paused for the travel overlay, so there is nothing to
    // resume beyond physics and tweens.
    releaseQueuedCoins(scene);
    if (resume) startSwingMeter(scene);
  }
}

// Toggle the storage upgrade screen
function toggleStorage(scene) {
  const visible = !storageContainer.visible;
  storageOverlay.setVisible(visible);
  storageContainer.setVisible(visible);
  setGoldChestVisible(!visible);
  if (dateBg) dateBg.setVisible(!visible);
  if (dateText) dateText.setVisible(!visible);
  if (xpText) xpText.setVisible(!visible);
  if (xpBarFill) xpBarFill.setVisible(!visible);
  if (visible) {
    fadeScreenOverlay(scene, 0.5);
    updateStorageUI();
    if (hideMeterEvent) {
      hideMeterEvent.remove(false);
      hideMeterEvent = null;
    }
    swingActive = false;
    inputEnabled = false;
    cursor.setVisible(false);
    scene.physics.world.pause();
    scene.tweens.pauseAll();
    storageButton.disableInteractive();
    shopButton.disableInteractive();
    weaponsButton.disableInteractive();
    travelButton.disableInteractive();
  } else {
    fadeScreenOverlay(scene, 0);
    scene.physics.world.resume();
    scene.tweens.resumeAll();
    storageButton.setInteractive();
    shopButton.setInteractive();
    weaponsButton.setInteractive();
    travelButton.setInteractive();
    releaseQueuedCoins(scene);
    startSwingMeter(scene);
  }
}

// Cost to upgrade to the next storage level
function getStorageUpgradeCost() {
  return 10 * Math.pow(2, player.storageLevel - 1);
}

// Refresh storage image, upgrade cost text, and interactivity
function updateStorageUI() {
  if (!storageImage) return;
  storageImage.setTexture(`storage${player.storageLevel}`);
  if (player.storageLevel >= 16) {
    storageCostText.setText('Max Level Reached');
    upgradeButton.disableInteractive();
    upgradeButton.setAlpha(0.5);
  } else {
    const cost = getStorageUpgradeCost();
    storageCostText.setText(`Upgrade Cost: ${formatGold(cost)} gold`);
    upgradeButton.setAlpha(1);
    upgradeButton.setInteractive();
  }
}

// Attempt to upgrade storage if the player can afford it
function upgradeStorage(scene) {
  if (player.storageLevel >= 16) return;
  const cost = getStorageUpgradeCost();
  if (player.gold >= cost) {
    player.gold -= cost;
    goldText.setText(formatGold(player.gold));
    upgradeButton.disableInteractive();
    scene.tweens.add({
      targets: storageImage,
      scale: 1.2,
      duration: 200,
      yoyo: true,
      onComplete: () => {
        player.storageLevel++;
        player.maxStorage = player.storageLevel * 10;
        updateStorageUI();
      },
    });
  }
}

// Toggle the weapons upgrade screen
function toggleWeapons(scene) {
  const visible = !weaponsContainer.visible;
  weaponsOverlay.setVisible(visible);
  weaponsContainer.setVisible(visible);
  setGoldChestVisible(!visible);
  if (dateBg) dateBg.setVisible(!visible);
  if (dateText) dateText.setVisible(!visible);
  if (xpText) xpText.setVisible(!visible);
  if (xpBarFill) xpBarFill.setVisible(!visible);
  if (visible) {
    fadeScreenOverlay(scene, 0.5);
    updateWeaponsUI();
    showWeaponQuote(weaponBeforeQuotes);
    if (hideMeterEvent) {
      hideMeterEvent.remove(false);
      hideMeterEvent = null;
    }
    swingActive = false;
    inputEnabled = false;
    cursor.setVisible(false);
    scene.physics.world.pause();
    scene.tweens.pauseAll();
    storageButton.disableInteractive();
    shopButton.disableInteractive();
    weaponsButton.disableInteractive();
    travelButton.disableInteractive();
  } else {
    fadeScreenOverlay(scene, 0);
    scene.physics.world.resume();
    scene.tweens.resumeAll();
    storageButton.setInteractive();
    shopButton.setInteractive();
    weaponsButton.setInteractive();
    travelButton.setInteractive();
    releaseQueuedCoins(scene);
    startSwingMeter(scene);
  }
}

// Cost to upgrade to the next weapon level
function getWeaponUpgradeCost() {
  const cost = 10 * Math.pow(WEAPON_UPGRADE_RATIO, player.weaponLevel - 1);
  return Math.ceil(cost - 1e-6);
}

// Refresh weapon image, upgrade cost text, and interactivity
function updateWeaponsUI() {
  if (!weaponsImage) return;
  weaponsImage.setTexture(`weapons${player.weaponLevel}`);
  if (player.weaponLevel >= 30) {
    weaponsCostText.setText('Max Level Reached');
    weaponUpgradeButton.disableInteractive();
    weaponUpgradeButton.setAlpha(0.5);
  } else {
    const cost = getWeaponUpgradeCost();
    weaponsCostText.setText(`Upgrade Cost: ${formatGold(cost)} gold`);
    weaponUpgradeButton.setAlpha(1);
    weaponUpgradeButton.setInteractive();
  }
  updateExecutionerWeaponTexture();
}

// Attempt to upgrade weapon if the player can afford it
function upgradeWeapon(scene) {
  if (player.weaponLevel >= 30) return;
  const cost = getWeaponUpgradeCost();
  if (player.gold >= cost) {
    player.gold -= cost;
    goldText.setText(formatGold(player.gold));
    weaponUpgradeButton.disableInteractive();
    player.weaponLevel++;
    weaponsImage.setTexture(`weapons${player.weaponLevel}`);
    weaponsImage.setScale(4);
    updateExecutionerWeaponTexture();
    updateZones();
    scene.tweens.add({
      targets: weaponsImage,
      scale: 1,
      duration: 300,
      ease: 'Cubic.easeOut',
      onComplete: () => {
        updateWeaponsUI();
        showWeaponQuote(weaponAfterQuotes);
      }
    });
  }
}

// Update executioner's carried weapon to current level
function updateExecutionerWeaponTexture() {
  if (executionerWeapon) {
    executionerWeapon.setTexture(`weapons${player.weaponLevel}`);
  }
}

// Total items currently stored in inventory
function getInventoryCount() {
  return Object.values(inventory).reduce((s, v) => s + v, 0);
}

// Fade completely to black, change cities, then reveal the new scene.
function travelToCity(scene, city) {
  const days = getTravelDays(currentCity, city.name);
  toggleTravel(scene, false, false);
  setGoldChestVisible(false);
  // Clear any residual screen dim from the travel menu before pausing the scene
  if (screenFadeTween) {
    screenFadeTween.stop();
    screenFadeTween = null;
  }
  screenFadeOverlay.setAlpha(0);
  screenFadeOverlay.setVisible(false);
  scene.scene.launch('TravelScene', { city, days, mainScene: scene });
  scene.scene.pause();
}

function showTradeMenu(scene, index, mode = 'buy') {
  tradeItemIndex = index;
  tradeMode = mode;
  tradeTitle.setText(marketItems[index].name);
  const showBuy = mode === 'buy';
  tradeBuyBtns.forEach(btn => btn.setVisible(showBuy));
  tradeSellBtns.forEach(btn => btn.setVisible(!showBuy));
  tradeOverlay.setVisible(true);
  tradeContainer.setVisible(true);
  if (currentWeather === 'rain' && rainEmitter && rainParts) {
    rainEmitter.stop();
    rainEmitter.killAll();
    rainParts.setVisible(false);
  } else if (currentWeather === 'fog' && fogEmitter && fogParts) {
    fogEmitter.stop();
    fogEmitter.killAll();
    fogParts.setVisible(false);
  } else if (currentWeather === 'wind' && windEmitter && windParts) {
    windEmitter.stop();
    windEmitter.killAll();
    windParts.setVisible(false);
  }
  if (hideMeterEvent) {
    hideMeterEvent.remove(false);
    hideMeterEvent = null;
  }
  swingActive = false;
  inputEnabled = false;
  cursor.setVisible(false);
  // backOverlayWasVisible = backOverlay.visible;
  // backOverlay.setVisible(false);
  scene.physics.world.pause();
  scene.tweens.pauseAll();
  scene.time.paused = true;
}

function hideTradeMenu(scene) {
  tradeOverlay.setVisible(false);
  tradeContainer.setVisible(false);
  // backOverlay.setVisible(backOverlayWasVisible);
  scene.physics.world.resume();
  scene.tweens.resumeAll();
  scene.time.paused = false;
  if (currentWeather === 'rain' && rainEmitter && rainParts) {
    rainParts.setVisible(true);
    rainEmitter.start();
  } else if (currentWeather === 'fog' && fogEmitter && fogParts) {
    fogParts.setVisible(true);
    fogEmitter.start();
  } else if (currentWeather === 'wind' && windEmitter && windParts) {
    windParts.setVisible(true);
    windEmitter.start();
  }
  releaseQueuedCoins(scene);
  startSwingMeter(scene);
}

// function resetBackOverlay(scene) {
//   // Stop any existing fade tweens and return the background overlay
//   // to a fully transparent starting state.
//   scene.tweens.killTweensOf(backOverlay);
//   backOverlay.setAlpha(0);
//   backOverlay.setVisible(true);
// }

function resetForNewCity(scene) {
  killStreak = 0;
  streakMultiplierText.setText(`x${killStreak}`);
  missStreak = 0;
  missText.setText(`Misses: ${missStreak}`);
  bodyGroup.clear(true, true);
  targetGroup.getChildren().forEach(t => {
    if (t.jester) t.jester.destroy();
    t.destroy();
  });
  bloodPool.setVisible(false);
  bloodPool.displayHeight = 1;
  stageBlood.setVisible(false);
  stageBlood.displayWidth = 1;
  speedMultiplier = 1;
  swingSpeed = baseSwingSpeed;
  resetHead(scene);
  executioner.setVisible(false);
  prisoner.setVisible(false);
  leftEscort.setVisible(false);
  rightEscort.setVisible(false);
  introExecutioner(scene, () => spawnPrisoner(scene, false, false));
}

// Update the background image based on the current city. If a specific
// texture is missing fallback to the generic background.
function updateBackground(scene) {
  const key = `background-${currentCity.toLowerCase()}`;
  if (scene.textures.exists(key)) {
    backgroundRect.setTexture(key);
  } else {
    backgroundRect.setTexture('background');
  }
}

function selectCity(scene, city) {
  if (!city.unlocked) return;
  if (city.name === currentCity) return;
  currentCity = city.name;
  // backgroundRect.setTint(city.bgColor); // disabled per request
  updateBackground(scene);
  locationText.setText(currentCity);
  // Ensure the travel UI overlay is hidden before starting the transition.
  // Force-close the travel menu in case it somehow remained visible
  // and ensure the dimming overlay disappears when travelling.
  travelOverlay.setVisible(false);
  travelContainer.setVisible(false);
  // Also hide other overlays in case they were inadvertently left open.
  shopOverlay.setVisible(false);
  shopContainer.setVisible(false);
  tradeOverlay.setVisible(false);
  tradeContainer.setVisible(false);
  // Reset the darkness overlay and begin the new city's intro fresh.
  // resetBackOverlay(scene);
  // Directly reset for the new city without fading the camera first.
  resetForNewCity(scene);
  applyRandomWeather(scene);
  roundCount = 1;
  // Extra safety: hide the travel overlay again in case any async events
  // re-enabled it during the city transition.
  travelOverlay.setVisible(false);
  setGoldChestVisible(true);
}

function savePrisoner(scene) {
  scene.tweens.add({
    targets: prisoner,
    x: 850,
    y: 460,
    duration: 2000,
    ease: 'Linear'
  });
}

function beheadPrisoner(scene, bloodAmount, angleDeg, power = 1) {
  if (headResetEvent) {
    headResetEvent.remove(false);
    headResetEvent = null;
  }
  const angle = angleDeg !== undefined ? angleDeg : Phaser.Math.Between(-110, -70);
  const rad = Phaser.Math.DegToRad(angle);
  const neckX = prisoner.x;
  const neckY = prisoner.y - 10;
  bloodEmitter.explode(bloodAmount, neckX, neckY);
  const headX0 = prisoner.x + prisonerHead.x;
  const headY0 = prisoner.y + prisonerHead.y;
  headEmitter.explode(bloodAmount / 2, headX0, headY0);

  if (lastGoldGain > 0) {
    showGoldGain(scene, lastGoldGain);
    lastGoldGain = 0;
  }

  // Create a physics body using the prisoner sprite for the falling corpse
  const corpse = scene.add.image(prisoner.x, prisoner.y + 50, prisonerBodyKey)
    .setOrigin(0.5, 1)
    .setDepth(0.5)
    .setTint(prisonerClass.color);
  scene.physics.world.enable(corpse);
  bodyGroup.add(corpse);
  corpse.isCorpse = true;
  corpse.bounceCount = 0;
  corpse.body.onWorldBounds = true;
  corpse.body.setBounce(0.05);
  corpse.body.setCollideWorldBounds(true);
  corpse.body.setDrag(50, 0);
  const corpseSpeed = 80 * power;
  // Throw the body based on the chosen slash angle and power
  corpse.body.setVelocity(Math.sin(rad) * corpseSpeed, Math.cos(rad) * corpseSpeed);
  // Spin faster so bodies topple onto their side
  corpse.body.setAngularVelocity(Phaser.Math.Between(-200, 200));

  // Pumping neck spurts while the body tumbles
  bloodEmitter.startFollow(corpse, 0, -50);
  bloodEmitter.setFrequency(60);
  bloodEmitter.setQuantity(Math.max(5, bloodAmount / 25));
  bloodEmitter.start();
  let pumpOn = true;
  if (neckPumpEvent) {
    neckPumpEvent.remove(false);
    neckPumpEvent = null;
  }
  neckPumpEvent = scene.time.addEvent({
    delay: 200,
    repeat: 6,
    callback: () => {
      pumpOn = !pumpOn;
      if (pumpOn) {
        bloodEmitter.start();
      } else {
        bloodEmitter.stop();
      }
    }
  });
  scene.time.delayedCall(1600, () => {
    bloodEmitter.stop();
    bloodEmitter.stopFollow();
    if (neckPumpEvent) {
      neckPumpEvent.remove(false);
      neckPumpEvent = null;
    }
  });

  // Reveal and grow the blood pool once the head is off
  bloodPool.setVisible(true);
  bloodPool.displayHeight = Math.min(bloodPool.displayHeight + 1, 100);
  stageBlood.setVisible(true);
  stageBlood.displayWidth = Math.min(stageBlood.displayWidth + 5, 300);

  // Hide the template prisoner while the physics body takes over
  prisoner.setVisible(false);

  // Spawn a new flying head sprite
  const flyingHead = scene.add.image(headX0, headY0, prisonerHeadKey)
    .setOrigin(0.5)
    .setDepth(0.8);
  scene.physics.world.enable(flyingHead);
  bodyGroup.add(flyingHead);
  flyingHead.isCorpse = true;
  flyingHead.isHead = true;
  flyingHead.bounceCount = 0;
  flyingHead.power = power;
  const hBody = flyingHead.body;
  scene.physics.add.overlap(flyingHead, targetGroup, (head, target) => {
    handleTargetHit(scene, target, head);
  });
  hBody.setAllowGravity(true);
  hBody.onWorldBounds = true;
  hBody.setCollideWorldBounds(true);
  hBody.checkCollision.left = false;
  hBody.checkCollision.right = false;
  hBody.checkCollision.up = false;
  hBody.setBounce(0.6);
  hBody.setDrag(50, 0);
  if (FEATURES.weather && currentWeather === 'rain') {
    hBody.setGravityY(0);
    flyingHead.rainGravityApplied = false;
  } else {
    hBody.setGravityY(0);
  }
  const speed = 250 * power;
  let vx = Math.sin(rad) * speed;
  if (FEATURES.weather && currentWeather === 'wind') {
    vx += windForce.x;
  }
  let vy = -Math.cos(rad) * speed;
  if (FEATURES.weather && currentWeather === 'wind') {
    vy += windForce.y;
  }
  hBody.setVelocity(vx, vy);
  hBody.setAngularVelocity(Phaser.Math.Between(-200, 200));

  headResetEvent = scene.time.delayedCall(2500, () => {
    headEmitter.stop();
    headEmitter.stopFollow();
    bloodEmitter.stop();
    bloodEmitter.stopFollow();
    if (neckPumpEvent) {
      neckPumpEvent.remove(false);
      neckPumpEvent = null;
    }
    headResetEvent = null;
  });

  // Continuous spurting from the flying head
  headEmitter.startFollow(flyingHead, 0, 15);
  headEmitter.setFrequency(20);
  headEmitter.setQuantity(Math.max(5, bloodAmount / 30));
  headEmitter.start();
}

function showAimArrow(scene, bloodAmount, nextSide) {
  pendingBlood = bloodAmount;
  pendingSpawnSide = 'left';
  awaitingPower = false;
  if (arrowPowerTween) arrowPowerTween.stop();
  // Start the arrow pointing left and sweep over the top to the right
  aimArrow.setAngle(-90);
  aimArrow.setScale(1);
  aimArrow.setVisible(true);
  arrowTween = scene.tweens.add({
    targets: aimArrow,
    angle: { from: -90, to: 90 },
    duration: 800,
    yoyo: true,
    repeat: -1
  });
  awaitingAngle = true;
}

function chooseAngle(scene) {
  if (!awaitingAngle) return;
  awaitingAngle = false;
  if (arrowTween) arrowTween.stop();
  selectedAngle = aimArrow.angle;
  // start power selection tween
  // grow the arrow length only, keeping width constant
  aimArrow.scaleX = 1;
  arrowPowerTween = scene.tweens.add({
    targets: aimArrow,
    scaleY: { from: 0.5, to: 2 },
    duration: 800,
    yoyo: true,
    repeat: -1
  });
  aimArrow.setVisible(true);
  awaitingPower = true;
}

function choosePower(scene) {
  if (!awaitingPower) return;
  awaitingPower = false;
  if (arrowPowerTween) arrowPowerTween.stop();
  let power = aimArrow.scaleY;
  aimArrow.setVisible(false);
  slashExecutioner(scene, selectedAngle, () => {
    beheadPrisoner(scene, pendingBlood, selectedAngle, power);
    // give the head time to fly off screen before the next prisoner arrives
    scene.time.delayedCall(2600, () => {
      spawnPrisoner(scene, pendingSpawnSide === 'right');
    });
  });
}

function slashExecutioner(scene, angle, onComplete) {
  if (slashTween) slashTween.stop();
  slashTween = scene.tweens.add({
    targets: executioner,
    angle: { from: 0, to: -angle },
    duration: 150,
    yoyo: true,
    ease: 'Cubic.easeOut',
    onComplete: () => {
      slashTween = null;
      if (onComplete) onComplete();
    }
  });
}
function introExecutioner(scene, onComplete) {
  executionerIntro = false;
  // Ensure previous background tweens don't conflict
  // scene.tweens.killTweensOf(backOverlay);
  // Darken the scene as the executioner arrives for dramatic effect
  fadeBackgroundOverlay(scene, 0.6, 800);
  executioner.setPosition(850, 460);
  executioner.setAlpha(0);
  executioner.setVisible(true);
  // backOverlay.setAlpha(0);
  // backOverlay.setVisible(true);
  // scene.tweens.add({
  //   targets: backOverlay,
  //   alpha: 0.72,
  //   duration: 1000,
  //   ease: 'Linear'
  // });
  scene.tweens.add({
    targets: executioner,
    x: 400,
    alpha: 1,
    duration: 1500,
    ease: "Linear",
    onComplete: () => {
      // Restore normal lighting once the executioner is in place
      fadeBackgroundOverlay(scene, 0, 800);
      if (onComplete) onComplete();
    }
  });
}

function resetHead(scene) {
  if (headResetEvent) {
    headResetEvent.remove(false);
    headResetEvent = null;
  }
  if (neckPumpEvent) {
    neckPumpEvent.remove(false);
    neckPumpEvent = null;
  }
  headEmitter.stop();
  headEmitter.stopFollow();
  bloodEmitter.stop();
  bloodEmitter.stopFollow();
  if (prisonerHead.body) {
    prisonerHead.body.stop();
    prisonerHead.body.setAllowGravity(false);
    scene.physics.world.disable(prisonerHead);
  }
  if (prisonerHead.parentContainer !== prisoner) {
    scene.children.remove(prisonerHead);
    prisoner.add(prisonerHead);
  }
  prisonerHead.setPosition(0, -20);
  prisonerHead.setRotation(0);
  prisonerBody.setAngle(0);
  prisonerBody.y = 50;
  prisoner.setAngle(0);
}



function spawnPrisoner(scene, fromRight, withTarget = true) {
  const city = cities.find(c => c.name === currentCity);
  roundCount++;
  if (FEATURES.weather && (roundCount === 1 || roundCount % 5 === 1)) {
    applyRandomWeather(scene);
  }
  // Temporarily disable background tinting when prisoners spawn
  // so we can determine if it is causing issues.
  // if (city) backgroundRect.setTint(city.bgColor);
  // Disable automatic dimming when a new prisoner spawns. Previously this
  // block would fade in the backOverlay to darken the scene whenever the
  // overlay's alpha was 0. This is temporarily removed as requested.
  // if (backOverlay.alpha === 0) {
  //   backOverlay.setAlpha(0);
  //   backOverlay.setVisible(true);
  //   scene.tweens.add({
  //     targets: backOverlay,
  //     alpha: 0.72,
  //     duration: 1000,
  //     ease: 'Linear'
  //   });
  // }
  prisoner.setVisible(true);
  // Birds now fly in once the jester has reached the stage
  resetHead(scene);
  prisonerClass = pickClass();
  if (prisonerClass.name === 'Clergy') {
    prisonerHeadKey = 'priestHead';
    prisonerBodyKey = 'priestBody';
  } else {
    const variant = Phaser.Math.Between(1, 3);
    prisonerHeadKey = `prisonerHead${variant}`;
    prisonerBodyKey = `prisonerBody${variant}`;
  }
  prisonerBody.setTexture(prisonerBodyKey);
  prisonerHeadSprite.setTexture(prisonerHeadKey);
  // Spawn up to 3 targets (jesters, barrels, etc.) each time a prisoner appears
  // The number of targets is chosen at random to keep gameplay varied
  if (withTarget) {
    const targetCount = Phaser.Math.Between(1, 3);
    for (let i = 0; i < targetCount; i++) {
      spawnTarget(scene);
    }
  }
  prisonerBody.setTint(prisonerClass.color);
  baseSwingSpeed = prisonerClass.speed;
  swingSpeed = baseSwingSpeed * speedMultiplier;
  // Keep body aligned under the head when resetting for a new prisoner
  prisonerBody.y = 50;
  
  const startX = -50;
  prisoner.setPosition(startX, 460);
  leftEscort.setPosition(startX - 50, 460);
  rightEscort.setPosition(startX + 50, 460);
  leftEscort.setVisible(true);
  rightEscort.setVisible(true);
  cursor.setVisible(false);
  swingBar.setVisible(false);
  redZone.setVisible(false);
  yellowZone.setVisible(false);
  greenZone.setVisible(false);
  scene.tweens.add({
    targets: prisoner,
    x: 400,
    duration: 1500,
    ease: 'Linear',
    onComplete: () => {
      // Once the prisoner reaches the center, have the escorts walk off
      // screen to the left instead of simply disappearing.
      scene.tweens.add({
        targets: leftEscort,
        x: -100,
        duration: 800,
        ease: 'Linear',
        onComplete: () => leftEscort.setVisible(false)
      });
      scene.tweens.add({
        targets: rightEscort,
        x: -100,
        duration: 800,
        ease: 'Linear',
        onComplete: () => rightEscort.setVisible(false)
      });
      // Keep the scene dimmed while the prisoner takes the stage
      startSwingMeter(scene);
    }
  });
  scene.tweens.add({ targets: leftEscort, x: 350, duration: 1500, ease: 'Linear' });
  scene.tweens.add({ targets: rightEscort, x: 450, duration: 1500, ease: 'Linear' });
}

// Wrapper for the hourly execution callback
function startExecutionRound() {
  if (game && game.scene && game.scene.scenes.length) {
    const scene = game.scene.scenes[0];
    // Prisoners now always enter from the left
    spawnPrisoner(scene, false);
  }
}

function startSwingMeter(scene) {
  if (hideMeterEvent) {
    hideMeterEvent.remove(false);
    hideMeterEvent = null;
  }
  if (arrowTween) arrowTween.stop();
  if (arrowPowerTween) arrowPowerTween.stop();
  aimArrow.setVisible(false);
  awaitingAngle = false;
  awaitingPower = false;
  swingActive = true;
  betweenSwings = false;
  inputEnabled = false;
  scene.time.delayedCall(200, () => { inputEnabled = true; });
  // Reset positions before making the meter visible to avoid visual jumps
  cursor.x = 250;
  const zoneX = 400;
  redZone.x = zoneX;
  yellowZone.x = zoneX;
  greenZone.x = zoneX;

  updateZones();

  cursor.setVisible(true);
  swingBar.setVisible(true);
  redZone.setVisible(true);
  yellowZone.setVisible(true);
  greenZone.setVisible(true);
  // leave bloodPool visible between swings
  scene.popupText.setVisible(false);

  // Ensure head is attached and physics disabled
  resetHead(scene);



  // Meter only starts once prisoner is in position
}

function endSwing(scene) {
  swingActive = false;
  betweenSwings = true;
  cursor.setVisible(false);
  const accuracy = Math.abs(cursor.x - redZone.x);
  let payout = 0;
  let message = '';
  let bloodAmount;
  let missed = false;
  let spawnSide = null;
  let spawnDelay = 500;
  if (accuracy <= greenZone.displayWidth / 2) {
    payout = 10;
    message = 'Perfect!';
    bloodAmount = 150; // big spurt
  } else if (accuracy <= yellowZone.displayWidth / 2) {
    payout = 5;
    message = 'Close!';
    bloodAmount = 60;
  } else if (accuracy <= redZone.displayWidth / 2) {
    payout = 2;
    message = 'Messy...';
    bloodAmount = 20;
  } else {
    payout = -2;
    bloodAmount = 5;
    missed = true;
  }

  // overall more blood
  bloodAmount *= 1.5;

  if (missed) {
    missStreak++;
    let strikeMsg = `Strike ${missStreak}`;
    if (missStreak >= 3) {
      payout -= 20;
      strikeMsg = 'Strike 3\nSaved!';
      missStreak = 0;
      savePrisoner(scene);
      spawnSide = 'left';
      pendingSpawnSide = 'left';
      spawnDelay = 2000; // wait for the freed prisoner to exit right
    }
    message = `Missed!\n${strikeMsg}`;
    killStreak = 0;
    speedMultiplier = 1;
    swingSpeed = baseSwingSpeed * speedMultiplier;
    streakMultiplierText.setText(`x${killStreak}`);
  } else {
    missStreak = 0;
    killCount++;
    killStreak++;
    if (killStreak > 1) {
      speedMultiplier *= 1.05;
    }
    swingSpeed = baseSwingSpeed * speedMultiplier;
    killText.setText(`Kills: ${killCount}`);
    streakMultiplierText.setText(`x${killStreak}`);
    addXP(scene, 1);
    showAimArrow(scene, bloodAmount, 'left');
    spawnSide = null;
    spawnDelay = 0;
  }
  missText.setText(`Misses: ${missStreak}`);

  const goldGain = missed ? payout : payout * killStreak;
  addGold(scene, goldGain);
  if (!missed && goldGain > 0) {
    lastGoldGain = goldGain;
  }

  // Increase and show blood bursts
  if (missed) {
    const neckX = prisoner.x;
    const neckY = prisoner.y - 10;
    bloodEmitter.explode(bloodAmount, neckX, neckY);
    const headX = prisoner.x + prisonerHead.x;
    const headY = prisoner.y + prisonerHead.y;
    headEmitter.explode(bloodAmount / 2, headX, headY);
  }

  // Show popup
  scene.popupText.setText(message);
  scene.popupText.setVisible(true);

  // Leave the meter visible briefly so players can see the result
  hideMeterEvent = scene.time.delayedCall(1000, () => {
    swingBar.setVisible(false);
    redZone.setVisible(false);
    yellowZone.setVisible(false);
    greenZone.setVisible(false);
    scene.time.delayedCall(spawnDelay, () => {
      if (awaitingAngle || awaitingPower) {
        return;
      }
      if (spawnSide) {
        spawnPrisoner(scene, spawnSide === 'right');
      } else {
        startSwingMeter(scene);
      }
    });
  });
}

function gainFame(scene, npc, amount = 1) {
  const fameGain = amount * fameMultiplier;
  fame += fameGain;
  fameText.setText(formatGold(Math.floor(fame)));
  addXP(scene, 5 * amount);
  const coinsToSpawn = Math.max(0, Math.floor(fameGain));
  for (let i = 0; i < coinsToSpawn; i++) {
    scene.time.delayedCall(i * 100, () => spawnFameCoin(scene));
  }
  const popup = scene.add.text(npc.x, npc.y - 40, `+${amount} Fame`, {
    font: '20px monospace',
    fill: '#ffff00'
  }).setOrigin(0.5);
  scene.tweens.add({
    targets: popup,
    y: popup.y - 20,
    alpha: 0,
    duration: 800,
    onComplete: () => popup.destroy()
  });
  // Jester will run off when the target hits the ground
}

function showGoldGain(scene, amount) {
  const popup = scene.add.text(prisoner.x, prisoner.y - 40, `+${formatGold(amount)} Gold`, {
    font: '20px monospace',
    fill: '#ffff88'
  }).setOrigin(0.5);
  scene.tweens.add({
    targets: popup,
    y: popup.y - 20,
    alpha: 0,
    duration: 800,
    onComplete: () => popup.destroy()
  });
}

function handleTargetHit(scene, target, head) {
  if (target.collected) return;
  if (target.targetType === 'woodenShield' && head && head.power < 1.5) {
    head.body.setVelocityX(-head.body.velocity.x * 0.5);
    return;
  }
  target.collected = true;
  if (target.moveTween) { target.moveTween.stop(); target.moveTween = null; }
  const jester = target.jester;
  let fameGain = 1;
  if (target.isMoving) fameGain *= 2;
  if (target.targetType === 'royal') fameGain *= 5;
  if (target.targetType === 'holyMonk') fameGain = -2;
  if (target.targetType === 'bird') {
    bloodFireworkEmitter.explode(25, target.x, target.y);
    if (target.birdKind === 'dove') {
      fame = Math.max(0, fame - 1);
      fameText.setText(formatGold(Math.floor(fame)));
      fameGain = 0;
    } else {
      gainFame(scene, target, 1);
      addGold(scene, 1);
      fameGain = 0;
    }
    gainFame(scene, target, fameGain);
    targetGroup.remove(target);
    target.body.setVelocity(0, 0);
    target.body.setAllowGravity(false);
    target.body.setImmovable(true);
    target.body.setCollideWorldBounds(false);
    target.body.enable = false;
    scene.tweens.add({
      targets: target,
      y: 560,
      duration: 600,
      ease: 'Linear',
      onComplete: () => target.destroy()
    });
    return;
  }
  gainFame(scene, target, fameGain);
  if (target.targetType === 'explodingBarrel') {
    targetGroup.getChildren().forEach(t => {
      if (!t.collected && Phaser.Math.Distance.Between(t.x, t.y, target.x, target.y) < 300) {
        handleTargetHit(scene, t, head);
      }
    });
    targetGroup.remove(target);
    fireworkEmitter.explode(25, target.x, target.y);
    fireworkCloseEmitter.explode(40, target.x, target.y);
    if (jester && !jester.running) {
      jester.running = true;
      const offX = jester.startFromRight ? 900 : -100;
      scene.tweens.add({
        targets: jester,
        x: offX,
        duration: 1500,
        ease: 'Linear',
        onComplete: () => jester.destroy()
      });
    }
    target.destroy();
    return;
  }
  targetGroup.remove(target);
  // blood spray at impact
  splatEmitter.explode(15, target.x, target.y);
  target.body.setVelocity(0, 0);
  target.body.setAllowGravity(false);
  target.body.setImmovable(true);
  target.body.setCollideWorldBounds(false);
  target.body.enable = false;
  const dropY = jester ? jester.y + 30 : target.y + 30;
  scene.tweens.add({
    targets: target,
    // Drop the target down near the jester's feet
    y: dropY,
    duration: 300,
    ease: 'Linear',
    onComplete: () => {
      if (jester && !jester.running) {
        jester.running = true;
        const offX = jester.startFromRight ? 900 : -100;
        scene.tweens.add({
          targets: [jester, target],
          x: offX,
          duration: 1500,
          ease: 'Linear',
          onComplete: () => {
            jester.destroy();
            target.destroy();
          }
        });
      }
    }
  });
}

function spawnHolyMonk(scene) {
  const fromRight = Phaser.Math.Between(0, 1) === 1;
  const startX = fromRight ? 850 : -50;
  const monk = scene.add.container(startX, 460).setDepth(20);
  monk.targetType = 'holyMonk';
  createTargetAppearance(scene, monk, 'holyMonk');
  scene.physics.world.enable(monk);
  monk.body.setAllowGravity(false);
  monk.body.setImmovable(true);
  monk.body.setVelocityX(fromRight ? -30 : 30);
  monk.collected = false;
  monk.jester = null;
  targetGroup.add(monk);
  const changes = Phaser.Math.Between(1, 2);
  let done = 0;
  const changeEvent = scene.time.addEvent({
    delay: 1000,
    loop: true,
    callback: () => {
      if (Phaser.Math.Between(0, 1) === 1 && done < changes) {
        monk.body.setVelocityX(-monk.body.velocity.x);
        done++;
      }
    }
  });
  scene.time.delayedCall(Phaser.Math.Between(2000, 5000), () => {
    changeEvent.remove();
    scene.tweens.add({
      targets: monk,
      x: fromRight ? 850 : -50,
      duration: 1500,
      ease: 'Linear',
      onComplete: () => {
        monk.destroy();
      }
    });
  });
}

function spawnRoyal(scene) {
  const fromRight = Phaser.Math.Between(0, 1) === 1;
  const startX = fromRight ? 850 : -50;
  const stopX = fromRight ? 500 : 300;
  const royal = scene.add.container(startX, 460).setDepth(20);
  royal.targetType = 'royal';
  createTargetAppearance(scene, royal, 'royal');
  scene.physics.world.enable(royal);
  royal.body.setAllowGravity(false);
  royal.body.setImmovable(true);
  royal.body.setVelocityX(fromRight ? -40 : 40);
  royal.collected = false;
  royal.jester = null;
  targetGroup.add(royal);
  scene.tweens.add({
    targets: royal,
    x: stopX,
    duration: 1500,
    ease: 'Linear',
    onComplete: () => {
      royal.body.setVelocityX(0);
      scene.time.delayedCall(Phaser.Math.Between(2000, 5000), () => {
        scene.tweens.add({
          targets: royal,
          x: fromRight ? 850 : -50,
          duration: 1500,
          ease: 'Linear',
          onComplete: () => royal.destroy()
        });
      });
    }
  });
}

function spawnBird(scene) {
  const fromRight = Phaser.Math.Between(0, 1) === 1;
  const startX = fromRight ? 850 : -50;
  const endX = fromRight ? -50 : 850;
  const kind = Phaser.Math.Between(0, 1) ? 'dove' : 'crow';
  const bird = scene.add.container(startX, 160).setDepth(20);
  bird.targetType = 'bird';
  bird.birdKind = kind;
  bird.fromRight = fromRight;
  createTargetAppearance(scene, bird, 'bird');
  scene.physics.world.enable(bird);
  bird.body.setAllowGravity(false);
  bird.body.setImmovable(true);
  bird.body.setVelocityX(fromRight ? -40 : 40);
  bird.collected = false;
  bird.jester = null;
  targetGroup.add(bird);
  bird.moveTween = scene.tweens.add({
    targets: bird,
    x: endX,
    duration: 3000,
    ease: 'Linear',
    yoyo: true,
    repeat: 0,
    onYoyo: () => {
      bird.body.setVelocityX(-bird.body.velocity.x);
      const base = bird.birdKind === 'dove' ? 'birdWhite' : 'birdBlack';
      const movingRight = bird.body.velocity.x > 0;
      const dir = movingRight ? 'Right' : 'Left';
      if (bird.birdSprite) bird.birdSprite.setTexture(base + dir);
    },
    onComplete: () => bird.destroy()
  });
}

function spawnTarget(scene) {
  const type = chooseTargetType();
  if (type === 'holyMonk') {
    spawnHolyMonk(scene);
    return;
  }
  if (type === 'royal') {
    spawnRoyal(scene);
    return;
  }
  const fromRight = Phaser.Math.Between(0, 1) === 1;
  const startX = fromRight ? 850 : -50;
  const targetX = Phaser.Math.Between(100, 700);
  const poleHeight = Phaser.Math.Between(80, 180);

  // Ensure jesters render above the lighting overlay and other background elements.
  const jester = scene.add.container(startX, 460).setDepth(20);
  jester.startFromRight = fromRight;
  const body = scene.add.image(0, 50, 'jesterBody1').setOrigin(0.5, 1);
  const pole = scene.add.rectangle(0, -20, 6, poleHeight, 0x8b4513)
    .setOrigin(0.5, 1);
  const head = scene.add.image(0, -20, 'jesterHead1').setOrigin(0.5);
  jester.add([body, pole, head]);

  const target = scene.add.container(startX, 460 - 20 - poleHeight).setDepth(20);
  target.targetType = type;
  createTargetAppearance(scene, target, type);

  if (type === 'woodenShield') {
    if (killStreak >= 3) {
      target.isMoving = true;
      const dur = killStreak >= 10 ? 400 : 800;
      target.moveTween = scene.tweens.add({
        targets: target,
        y: target.y - 20,
        duration: dur,
        yoyo: true,
        repeat: -1,
        ease: 'Sine.easeInOut'
      });
    }
  } else if (FEATURES.movingTargets && Phaser.Math.Between(0, 1) === 1) {
    target.isMoving = true;
    target.moveTween = scene.tweens.add({
      targets: target,
      y: target.y - 20,
      duration: 800,
      yoyo: true,
      repeat: -1,
      ease: 'Sine.easeInOut'
    });
  }

  let jBodyKey = 'jesterBody1';
  let jHeadKey = 'jesterHead1';
  if (type === 'woodenShield') {
    jBodyKey = 'jesterBody2';
    jHeadKey = 'jesterHead2';
  } else if (type === 'explodingBarrel') {
    jBodyKey = 'jesterBody3';
    jHeadKey = 'jesterHead3';
  }
  if (target.isMoving) {
    jBodyKey = 'jesterBody4';
    jHeadKey = 'jesterHead4';
  }
  body.setTexture(jBodyKey);
  head.setTexture(jHeadKey);

  target.collected = false;
  target.jester = jester;
  targetGroup.add(target);

  scene.tweens.add({
    targets: [jester, target],
    x: targetX,
    duration: 1500,
    ease: 'Linear',
    onComplete: () => {
      scene.physics.world.enable(target);
      if (type === 'explodingBarrel') {
        // Include the fuse above the barrel in the hitbox
        target.body.setSize(30, 46);
        target.body.setOffset(-15, -26);
      } else {
        target.body.setCircle(20);
        target.body.setOffset(-20, -20);
        target.body.x = target.x - target.body.halfWidth;
        target.body.y = target.y - target.body.halfHeight;
      }
      target.body.setAllowGravity(false);
      target.body.setImmovable(true);
      if (FEATURES.birds && Phaser.Math.Between(1, 10) === 1) {
        scene.time.delayedCall(2000, () => spawnBird(scene));
      }
    },
    onUpdate: () => {
      if (target.body) {
        target.body.x = target.x - target.body.halfWidth;
        target.body.y = target.y - target.body.halfHeight;
      }
    }
  });
}

function addXP(scene, amount) {
  xp += amount;
  if (xp >= xpThreshold) {
    xp -= xpThreshold;
    level++;
    xpThreshold = Math.floor(xpThreshold * 1.15);
    onLevelUp(scene);
  }
  updateXPUI();
}

function updateXPUI() {
  xpText.setText(`Level ${level} - ${xp}/${xpThreshold} XP`);
  const maxWidth = 300;
  xpBarFill.displayWidth = maxWidth * (xp / xpThreshold);
}

function onLevelUp(scene) {
  const msg = scene.add.text(400, 300, 'LEVEL UP!', { font: '48px monospace', fill: '#ffff00' })
    .setOrigin(0.5)
    .setDepth(25);
  scene.cameras.main.flash(250, 255, 255, 255);
  scene.tweens.add({
    targets: msg,
    y: 250,
    alpha: 0,
    duration: 1000,
    onComplete: () => msg.destroy()
  });
}

function update(time, delta) {

  if (!gameStarted) return;

  if (this.dayNight) {
    this.dayNight.update(delta / 1000);
  }

  if (FEATURES.clouds && cloudLayerFar && cloudLayerNear) {
    cloudLayerFar.getChildren().forEach(cloud => {
      cloud.x -= 0.2;
      if (cloud.x < -cloud.width / 2) {
        cloud.x = config.width + cloud.width / 2;
        cloud.y = Phaser.Math.Between(20, CLOUD_AREA_HEIGHT);
        cloud.setAlpha(Phaser.Math.FloatBetween(0.6, 0.9));
        cloud.setScale(Phaser.Math.FloatBetween(0.8, 1.2));
      }
    });
    cloudLayerNear.getChildren().forEach(cloud => {
      cloud.x -= 0.4;
      if (cloud.x < -cloud.width / 2) {
        cloud.x = config.width + cloud.width / 2;
        cloud.y = Phaser.Math.Between(40, CLOUD_AREA_HEIGHT);
        cloud.setAlpha(Phaser.Math.FloatBetween(0.6, 0.9));
        cloud.setScale(Phaser.Math.FloatBetween(0.8, 1.2));
      }
    });
  }

  // Move cursor
  if (swingActive) {
    cursor.x += swingDirection * swingSpeed;
    if (cursor.x > 550 || cursor.x < 250) {
      swingDirection *= -1;
    }
  }

  // Apply extra gravity once heads start falling in the rain
  if (FEATURES.weather && currentWeather === 'rain' && bodyGroup) {
    bodyGroup.getChildren().forEach(obj => {
      if (obj.isHead && !obj.rainGravityApplied && obj.body.velocity.y > 0) {
        obj.body.setGravityY(300);
        obj.rainGravityApplied = true;
      }
    });
  }


  // Splash when heads hit the blood pool
  if (bloodPool && bloodEmitter && bodyGroup) {
    const surfaceY = bloodPool.y - bloodPool.displayHeight;
    bodyGroup.getChildren().forEach(obj => {
      if (obj.isHead && !obj.hasSplashed && obj.y + obj.displayHeight / 2 >= surfaceY) {
        obj.hasSplashed = true;
        const depth = Math.min(bloodPool.displayHeight, 100);
        const ratio = depth / 100;
        const qty = Math.floor(10 + 40 * ratio);
        const minSpeed = 150 + 50 * ratio;
        const maxSpeed = 250 + 50 * ratio;
        bloodEmitter.setSpeed({ min: minSpeed, max: maxSpeed });
        bloodEmitter.explode(qty, obj.x, surfaceY);
        bloodEmitter.setSpeed({ min: 150, max: 250 });
      }
    });
  }
}

class TravelScene extends Phaser.Scene {
  constructor() {
    super({ key: 'TravelScene' });
  }
  init(data) {
    this.city = data.city;
    this.days = Math.max(1, data.days);
    this.mainScene = data.mainScene;
  }
  create() {
    const keys = travelBackgrounds.map((_, i) => `background-travel${i + 1}`);
    let bgKey = Phaser.Utils.Array.GetRandom(keys);
    if (!this.textures.exists(bgKey)) bgKey = 'background';
    this.add.image(400, 300, 'backgroundSky').setDisplaySize(800, 600).setDepth(-5);
    this.add.image(400, 300, bgKey).setDisplaySize(800, 600).setDepth(-2);
    this.add.text(400, 40, `Travelling to ${this.city.name}`, { font: '32px serif', fill: '#ffff00' }).setOrigin(0.5);
    let d = currentDay;
    let m = currentMonth;
    const date = this.add.text(400, 80, `${d} ${months[m]}`, { font: '28px monospace', fill: '#ffffff' }).setOrigin(0.5);
    const duration = this.days * 700;
    // Accelerate the day/night cycle so it completes one full day for each
    // travel day, keeping the visuals in sync with the journey length.
    this.dayNight = new DayNightCycle({ dayLengthSeconds: (duration / this.days) / 1000 });
    this.dayNight.init(this, { backCloudsDepth: -3, overlayDepth: -0.5 });
    const pickWeather = () =>
      Math.random() < 0.5
        ? 'Clear'
        : Phaser.Utils.Array.GetRandom(['Rain', 'Wind', 'Fog']);
    let weather = pickWeather();

    // Simple particle emitters to visualize travel weather
    const rainEmitter = this.add.particles('raindrop').createEmitter({
      x: { min: 0, max: 800 },
      y: 0,
      lifespan: 800,
      speedY: { min: 400, max: 600 },
      quantity: 15,
      frequency: 100,
      on: false
    });
    const fogEmitter = this.add.particles('fog').createEmitter({
      x: { min: -50, max: 850 },
      y: { min: 300, max: 580 },
      lifespan: 6000,
      speedX: { min: -20, max: 20 },
      speedY: { min: -5, max: 5 },
      quantity: 6,
      alpha: { start: 0.8, end: 0.1 },
      on: false
    });
    const windEmitter = this.add.particles('leaf').createEmitter({
      lifespan: 4000,
      quantity: 10,
      frequency: 20,
      scale: { start: 1, end: 0 },
      rotate: { min: -180, max: 180 },
      on: false
    });

    // Parallax clouds that drift during travel
    if (FEATURES.clouds) {
      if (!this.textures.exists('cloud-small')) {
        const gfx = this.make.graphics({ x: 0, y: 0, add: false });
        gfx.fillStyle(0xdddddd, 0.6);
        gfx.fillEllipse(50, 45, 60, 20);
        gfx.fillStyle(0xffffff, 0.9);
        gfx.fillCircle(30, 30, 20);
        gfx.fillCircle(50, 20, 25);
        gfx.fillCircle(70, 30, 20);
        gfx.fillCircle(40, 40, 18);
        gfx.fillCircle(60, 40, 18);
        gfx.generateTexture('cloud-small', 100, 60);
        gfx.clear();
        gfx.fillStyle(0xdddddd, 0.6);
        gfx.fillEllipse(70, 45, 80, 25);
        gfx.fillStyle(0xffffff, 0.9);
        gfx.fillCircle(40, 30, 25);
        gfx.fillCircle(70, 20, 35);
        gfx.fillCircle(100, 30, 25);
        gfx.fillCircle(55, 45, 20);
        gfx.fillCircle(85, 45, 20);
        gfx.generateTexture('cloud-big', 140, 60);
        gfx.destroy();
      }
      this.travelCloudLayerFar = this.add.group();
      this.travelCloudLayerNear = this.add.group();
      for (let i = 0; i < 1; i++) {
        const cloud = this.add.image(
          Phaser.Math.Between(0, config.width),
          Phaser.Math.Between(20, CLOUD_AREA_HEIGHT),
          'cloud-small'
        );
        cloud.setDepth(-3);
        cloud.setTint(0x888888);
        cloud.setAlpha(Phaser.Math.FloatBetween(0.3, 0.5));
        cloud.setScale(Phaser.Math.FloatBetween(0.8, 1.2));
        this.travelCloudLayerFar.add(cloud);
      }
      for (let i = 0; i < 1; i++) {
        const cloud = this.add.image(
          Phaser.Math.Between(0, config.width),
          Phaser.Math.Between(40, CLOUD_AREA_HEIGHT),
          'cloud-big'
        );
        cloud.setDepth(-1);
        cloud.setAlpha(Phaser.Math.FloatBetween(0.6, 0.9));
        cloud.setScale(Phaser.Math.FloatBetween(0.8, 1.2));
        this.travelCloudLayerNear.add(cloud);
      }
    }

    // Parallax grass tufts that blow past during travel
    const grassG = this.add.graphics();
    grassG.fillStyle(0x2e8b57, 1);
    grassG.beginPath();
    grassG.moveTo(2, 8);
    grassG.lineTo(4, 0);
    grassG.lineTo(6, 8);
    grassG.lineTo(2, 8);
    grassG.moveTo(0, 8);
    grassG.lineTo(1, 3);
    grassG.lineTo(2, 8);
    grassG.moveTo(6, 8);
    grassG.lineTo(7, 3);
    grassG.lineTo(8, 8);
    grassG.fillPath();
    grassG.generateTexture('grassTuft', 8, 8);
    grassG.destroy();

    const grassFarParts = this.add.particles('grassTuft').setDepth(0);
    grassFarParts.createEmitter({
      x: { min: 0, max: 800 },
      y: { min: 520, max: 560 },
      lifespan: 5000,
      speedX: { min: -80, max: -40 },
      speedY: { min: -20, max: 20 },
      quantity: 1,
      frequency: 300,
      alpha: { start: 1, end: 0 },
      scale: { start: 0.6, end: 0.2 }
    });
    const grassNearParts = this.add.particles('grassTuft').setDepth(2);
    grassNearParts.createEmitter({
      x: { min: 0, max: 800 },
      y: { min: 570, max: 600 },
      lifespan: 3000,
      speedX: { min: -200, max: -120 },
      speedY: { min: -30, max: 30 },
      quantity: 1,
      frequency: 150,
      alpha: { start: 1, end: 0 },
      scale: { start: 1.5, end: 0.7 }
    });
    const setWeather = (w) => {
      rainEmitter.stop();
      fogEmitter.stop();
      windEmitter.stop();
      if (w === 'Rain') {
        rainEmitter.start();
      } else if (w === 'Fog') {
        fogEmitter.start();
      } else if (w === 'Wind') {
        windEmitter.setSpeedX({ min: -50, max: 50 });
        windEmitter.setSpeedY({ min: 0, max: 0 });
        windEmitter.start();
      }
    };
    setWeather(weather);
    const exec = this.add.container(-100, 460).setDepth(1);
    const weapon = this.add.image(0, -20, `weapons${player.weaponLevel}`)
      .setOrigin(0.5)
      .setAngle(135);
    const body = this.add.image(0, 50, 'executionerBody').setOrigin(0.5, 1);
    const head = this.add.image(0, -30, 'executionerHead').setOrigin(0.5);
    exec.add([weapon, body, head]);
    this.add.existing(exec);

    // Storage upgrade image trails 50px lower behind the executioner
    const upgrade = this.add
      .image(-250, 510, `storage${player.storageLevel}`)
      .setOrigin(0.5, 1)
      .setDepth(0);

    this.tweens.add({ targets: exec, x: 900, duration, ease: 'Linear' });
    this.tweens.add({ targets: upgrade, x: 750, duration, ease: 'Linear' });
    this.time.addEvent({
      delay: duration / this.days,
      repeat: this.days - 1,
      callback: () => {
        d++;
        if (d > 30) { d = 1; m = (m + 1) % months.length; }
        date.setText(`${d} ${months[m]}`);
        if (Math.random() < 0.5) {
          weather = pickWeather();
          setWeather(weather);
        }
      }
    });

    this.time.delayedCall(duration, () => this.finish());
  }
  update(time, delta) {
    if (this.dayNight) {
      this.dayNight.update(delta / 1000);
    }
    if (FEATURES.clouds && this.travelCloudLayerFar && this.travelCloudLayerNear) {
      // Accelerate cloud movement to keep pace with the sped-up day/night cycle
      const speedMult = 180 / this.dayNight.config.dayLengthSeconds;
      this.travelCloudLayerFar.getChildren().forEach(cloud => {
        cloud.x -= 0.2 * speedMult;
        if (cloud.x < -cloud.width / 2) {
          cloud.x = config.width + cloud.width / 2;
          cloud.y = Phaser.Math.Between(20, CLOUD_AREA_HEIGHT);
          cloud.setAlpha(Phaser.Math.FloatBetween(0.6, 0.9));
          cloud.setScale(Phaser.Math.FloatBetween(0.8, 1.2));
        }
      });
      this.travelCloudLayerNear.getChildren().forEach(cloud => {
        cloud.x -= 0.4 * speedMult;
        if (cloud.x < -cloud.width / 2) {
          cloud.x = config.width + cloud.width / 2;
          cloud.y = Phaser.Math.Between(40, CLOUD_AREA_HEIGHT);
          cloud.setAlpha(Phaser.Math.FloatBetween(0.6, 0.9));
          cloud.setScale(Phaser.Math.FloatBetween(0.8, 1.2));
        }
      });
    }
  }
  finish() {
    advanceDays(this.days);
    selectCity(this.mainScene, this.city);
    dailyMarketUpdate();
    this.scene.stop();
    this.mainScene.scene.resume();
  }
}

game.scene.add('TravelScene', TravelScene, false);

// Inject styled gameplay instructions beneath the Phaser canvas once the page loads
window.addEventListener('load', () => {
  const instructions = document.createElement('div');
  instructions.id = 'game-instructions';
  instructions.style.padding = '30px';
  instructions.style.fontFamily = 'Georgia, serif';
  instructions.style.maxWidth = '800px';
  instructions.style.margin = '0 auto';
  instructions.style.textAlign = 'center';

  instructions.innerHTML = `
    <h1>⚔️ Welcome to <em>Chop To It</em> ⚔️</h1>
    <p><strong>This game is a work-in-progress demo — completely made by AI.</strong></p>

    <h2>🕹️ Instructions</h2>
    <ul style="list-style: none; padding-left: 0;">
      <li>🔪 Click in the centre of the meter to determine if you <strong>hit</strong> or <strong>miss</strong>.</li>
      <li>🎯 The second click sets the <strong>direction</strong> your customer’s head flies.</li>
      <li>💥 The third click determines the <strong>power</strong> of your strike.</li>
      <li>🎯 Aim for jesters and flying targets to maximise your rewards.</li>
    </ul>

    <h2>📦 Features</h2>
    <ul style="list-style: none; padding-left: 0;">
      <li>🌦️ Weather alters gravity and shot physics.</li>
      <li>🔥 Hit streaks increase gold and spawn rarer characters.</li>
      <li>🚚 Buy storage upgrades and travel to new cities.</li>
      <li>📉 Buy low, sell high — master the medieval market.</li>
    </ul>

    <h2>🏆 Your Goal</h2>
    <p><em>Earn <strong>1,000,001 gold</strong> within one year.</em></p>
    <p>Only the most brutal and brilliant executioner shall rise to glory.</p>
  `;

  document.body.appendChild(instructions);
});
</script>

</body>
</html>
